[#_7_2_modules_cheat_sheet]
=== 7.2. Определение модулей для управления областью действия и конфиденциальностью

В этом разделе мы поговорим о модулях и других частях модульной системы, а именно о _путях_ (_paths_), позволяющих именовать элементы; ключевом слове `use`, позволяющем использовать пути к областям действия; ключевом слове `pub` для управления доступом к элементам. Также обсудим ключевое слово `as`, внешние пакеты и оператор glob.

Для начала в справочных целях приведем полный список правил модульной системы, на которые будем ссылаться в дальнейшем изложении, а вам было бы легче ориентироваться при в вопросах организации кода в будущем. Затем подробно объясним каждое из правил.

==== Правила модульной системы

Правила описывают, как модули, пути, `use` и  `pub` работают в компиляторе и как большинство разработчиков организуют свой код. Заодно рассмотрим примеры каждого из этих правил.

* *Все начинается с корня крейта*: компилятор начинает поиск кода для компиляции с корневого файла крейта (обычно _src/lib.rs_ для библиотечного крейта или _src/main.rs_ для бинарного крейта).
* *Объявление модулей*: в корневом файле крейта можно объявлять новые модули; например, объявим модуль «garden» с помощью инструкции `mod garden;`. Компилятор будет последовательно искать код модуля в следующих местах:
** Внутри фигурных скобок `mod garden`, если они указаны вместо точки с запятой после `mod garden`
** В файле _src/garden.rs_
** В файле _src/garden/mod.rs_ (устаревший стиль)
* *Объявление подмодулей (submodules)*: В любом файле, кроме корня крейта, можно объявлять подмодули. Например, объявим в файле _src/garden.rs_ подмодуль с помощью инструкции `mod vegetables;`. Компилятор будет искать код подмодуля в каталоге с именем родительского модуля в следующих местах:
** Внутри фигурных скобок `mod vegetables`, если они указаны вместо точки с запятой после `mod vegetables`
** В файле _src/garden/vegetables.rs_
** В файле _src/garden/vegetables/mod.rs_ (устаревший стиль)
* *Пути к коду в модулях*: как только модуль станет частью вашего крейта, вы можете, используя путь к коду, ссылаться на код этого модуля из любого другого места в том же крейте, если это разрешено правилами конфиденциальности. Например, тип `Asparagus`, определенный в модуле garden vegetables, можно найти по пути `crate::garden::vegetables::Asparagus`.
* *Закрытый (частный, private) или открытый (общедоступный, public)*: код внутри модуля [.underline]#по умолчанию является закрытым# от его родительских модулей. Чтобы сделать модуль открытым, объявите его с помощью `pub mod` вместо `mod`. Открытие доступа к модулю не означает открытия доступа к его элементам; чтобы открыть элемент в открытом модуле, необходимо также использовать ключевое слово `pub` перед его объявлениями (если модуль является закрытым, ключевое слово `pub` на его элементе игнорируется, элемент остается недоступным извне).
* *Ключевое слово `use`*: внутри области действия ключевое слово `use` создает ярлыки (shortcuts) элементов, чтобы сократить повторный ввод длинных путей. В любой области действия, которая может ссылаться на `crate::garden::vegetables::Asparagus`, можно создать ярлык с помощью инструкции `use crate::garden::vegetables::Asparagus;` и с этого момента писать просто `Asparagus`, чтобы использовать этот тип в области действия.

Для иллюстрации работы правил создадим бинарный крейт с именем `backyard`. Каталог крейта с тем же названием _backyard_ содержит следующие файлы и каталоги:

[example]
----
backyard
├── Cargo.lock
├── Cargo.toml
└── src
    ├── garden
    │   └── vegetables.rs
    ├── garden.rs
    └── main.rs
----

Корневой файл крейта в этом случае — _src/main.rs_, и он содержит:

Файл: src/main.rs

[source,rust]
----
use crate::garden::vegetables::Asparagus;

pub mod garden;

fn main() {
    let plant = Asparagus {};
    println!("I'm growing {:?}!", plant);
}
----

Строка `pub mod garden;` указывает компилятору включить код, который он находит в _src/garden.rs_, а именно:

Файл: src/garden.rs

[source,rust]
----
pub mod vegetables;
----

Инструкция `pub mod vegetables;` означает, что нужно включить код из _src/garden/vegetables.rs_ также включен. Вот код этого подмодуля:

[source,rust]
----
#[derive(Debug)]
pub struct Asparagus {}
----

Теперь давайте углубимся в детали этих правил и продемонстрируем их в действии!

==== Группировка связанного кода в модулях

С помощью _модулей_ можно организовать код в крейте таким образом, чтобы его было удобно читать и повторно использовать. Модули также позволяют нам контролировать _конфиденциальность_ элементов, поскольку код внутри модуля по умолчанию является закрытым. Закрытые элементы — это детали внутренней реализации, недоступные для внешнего использования. При необходимости мы можем открыть доступ к модулям и их внутренним элементам, что позволит использовать и зависеть от них в любом внешнем модуле.

В качестве примера давайте напишем библиотечный крейт, который обеспечивает функциональность ресторана. Мы определим сигнатуры функций, но оставим их тела пустыми, чтобы сосредоточиться на организации, а не на реализации, кода.

В ресторанной индустрии некоторые части ресторана относятся к _фронт-хаусу_ (_front of house_), а другие - _бэк-хаусу_ (_back of house_). Во фронт-хаусе расположена клиентская зона; он включает места, где хозяева усаживают клиентов, официанты принимают заказы и оплату, а бармены готовят напитки. Бэк-хаус — это рабочая зона ресторана: места, где повара работают на кухне, посудомойщики убирают, а менеджеры выполняют административную работу.

Для структурирования нашего крейта сходным образом будем размещать его функции во вложенных модулях. Давайте создадим новую библиотеку (библиотечный крейт) с именем `restaurant` с помощью команды `cargo new restaurant --lib;` и добавим в файл _src/lib.rs_ код из листинга 7-1 с определением модулей и сигнатур функций для секции фронт-хауса:

--
.Листинг 7-1: модуль front_of_house, содержащий другие модули, которые в свою очередь содержат функции

Файл: src/lib.rs

[source,rust]
----
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
----
--

Мы определяем модуль с помощью ключевого слова `mod`, за которым следует имя модуля (в данном случае `front_of_house`). Затем тело модуля помещается в фигурные скобки. Внутри модулей можно размещать другие модули, как в данном случае с модулями `hosting` и `serving`. Модули также могут содержать определения других элементов, таких как структуры, перечисления, константы, трейты и — как в листинге 7-1 — функции.

Применяя модули, можно сгруппировать связанные (related) определения вместе и указать, почему эти определения связаны. Программисты, использующие нашу программу, могут ориентироваться в ней на основе наименований указанных групп, а не читать все определения, что существенно упрощает поиск нужных функций. Программисты, добавляющие в нее новые функции, должны знать, где разместить их код, чтобы программа по-прежнему оставалась правильно организованной.

Ранее мы упоминали, что файлы _src/main.rs_ и _src/lib.rs_ называются корнями крейта. Причина, по которой их так называют, заключается в том, что содержимое любого из этих двух файлов образует (корневой) модуль с именем `crate` в корне иерархической модульной структуры крейта, известной как _дерево модулей_ (_module tree_).

В листинге 7-2 показано дерево модулей для структуры из листинга 7-1.

--
.Листинг 7-2: Дерево модулей для кода из листинга 7-1.

[example]
----
crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
----
--

Это дерево показывает, как определенные модули вложены друг в друга; например, модуль `hosting` вложен в модуль `front_of_house`. Дерево также показывает, что некоторые модули являются _братьями_ (_siblings_) по отношению друг к другу, то есть определены в одном и том же модуле; например, модули `hosting` и `serving` являются братьями, определенными внутри модуля `front_of_house`. Если модуль A содержится внутри модуля B, мы говорим, что модуль A является _дочерним_ (_child_) по отношению к модулю B, а модуль B является _родителем_ (_parent_) модуля A. Обратите внимание, что корнем всего дерева модулей является неявный модуль с именем `crate`.

Дерево модулей напоминает дерево каталогов файловой системы на вашем компьютере; на самом деле, это очень удачное сравнение! Модули используются для организации кода, как и каталоги в файловой системе. И точно так же, как для файлов в каталогах, нам нужен способ указать местонахождение произвольного модуля в дереве модулей крейта.
