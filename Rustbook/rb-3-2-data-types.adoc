[#_3_2_data_types]
=== 3.2. Типы данных

Каждое значение в Rust имеет определенный _тип данных_, который сообщает Rust, какие данные мы будем использовать и как работать с этими данными. Мы рассмотрим два подмножества типов данных: скалярные и составные.

Имейте в виду, что Rust — _статически типизированный_ язык; это значит, что он должен знать типы всех переменных во время компиляции. Компилятор обычно может вывести (infer) тип переменной на основе ее значения и того, как используется это значение в коде. В случаях, когда вывод типа не является возможным или однозначным, как, например, при преобразовании строки в числовой тип с помощью `parse` в разделе xref:_2_3_comparing[«Сравнение числа игрока с секретным числом»] в Главе 2, нам нужно добавить аннотацию типа, например:

[source,rust]
----
let guess: u32 = "42".parse().expect("Not a number!");
----

Если мы не добавим аннотацию типа `: u32`, Rust выдаст ошибку, так как компилятору нужно больше информации от нас, чтобы знать, какой тип мы хотим использовать:

[example]
----
$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 --> src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^ consider giving `guess` a type

For more information about this error, try `rustc --explain E0282`.
error: could not compile `no_type_annotations` due to previous error
----

[#_3_2_1_scalar_types]
==== Скалярные типы

_Скалярный тип_ представляет одно значение. В Rust есть четыре основных скалярных типа:

* Целые числа (integers)
* Числа с плавающей запятой (floating-point numbers)
* Логический тип (Booleans)
* Символы (characters).

Вы можете знать их по другим языкам программирования. Давайте перейдем к тому, как они работают в Rust.

[#_3_2_1_1_integers]
===== Целые числа

_Целое число_ — это число без дробной части. В xref:_2_1_processing_user_input[Главе 2] мы использовали один целочисленный тип — `u32`. Это объявление типа указывает, что значение, с которым он связан, должно быть целым числом без знака (целочисленные типы со знаком начинаются с `i` вместо `u`) и занимает 32 бита в памяти. В таблице 3-1 показаны встроенные целочисленные типы в Rust. Мы можем использовать любой из этих вариантов для объявления типа целочисленного значения.

--
.Таблица 3-1: Целочисленные типы в Rust

|===
| Length  | Signed | Unsigned

| 8-bit   | `i8`     | `u8`
| 16-bit  | `i16`    | `u16`
| 32-bit  | `i32`    | `u32`
| 64-bit  | `i64`    | `u64`
| 128-bit | `i128`   | `u128`
| arch    | `isize`  | `usize`
|===
--

Каждый вариант может быть как со знаком, так и без знака и имеет явный размер. _Знаковые_ и _беззнаковые_ типы, как следует из названия, различаются тем, могут ли числа быть отрицательными, другими словами, должно ли число иметь знак (знаковое) или оно всегда будет только положительным и, следовательно, может быть представлено без знака (беззнаковое). Это как писать числа на бумаге: когда знак имеет значение, число показывается со знаком плюс или со знаком минус; однако, когда можно с уверенностью предположить, что число положительное, оно отображается без знака. Числа со знаком хранятся в виде "дополнения до двух", детальное описание см. по адресу _https://en.wikipedia.org/wiki/Two%27s_complement_.

Знаковый тип может хранить числа от -2^(n-1)^ до 2^(n-1)^ - 1 включительно, где n — количество битов, которые использует вариант типа. Например, `i8` может хранить числа от -2^7^ до 2^7^ - 1, то есть от -128 до 127. Беззнаковый тип может хранить числа от 0 до 2^n^ - 1, поэтому `u8` может хранить числа от 0 до 2^8^ - 1, то есть от 0 до 255.

Кроме того, типы `isize` и `usize` зависят от архитектуры компьютера, на котором работает ваша программа. В таблице архитектура обозначена как «arch»: 64-битная, если вы используете 64-битную аппаратную архитектуру, и 32-битная, если у вас 32-битная архитектура.

Целочисленные литералы можно записывать в любой из форм, показанных в таблице 3-2. Обратите внимание, что числовые литералы, которые могут быть отнесены к разным числовым типам, позволяют использовать суффикс для обозначения нужного нам типа, например `57u8`. Для упрощения чтения длинных чисел числовые литералы также могут использовать подчеркивание `_` в качестве визуального разделителя, например `1_000` с тем же значением, что и `1000`.

--
.Таблица 3-2: Целочисленные литералы в Rust

|===
| Числовой литерал  | Пример

| Десятичный        | `98_222`
| Шестнадцатеричный | `0xff`
| Восьмеричный      | `0o77`
| Двоичный          | `0b1111_0000`
| Байт              | `+b'A'+`
|===
--

Так как же узнать, какой тип целого числа использовать? Если вы не уверены, то можно использовать значения по умолчанию: целочисленный тип по умолчанию — `i32`. Основная ситуация, в которой вы будете использовать `isize` или `usize`, — это индексация какой-либо коллекции.

[sidebar]
.Целочисленное переполнение
****

Допустим, у вас есть переменная типа `u8`, которая может содержать значения от 0 до 255. Если вы попытаетесь изменить переменную на значение вне этого диапазона, например 256, произойдет _целочисленное переполнение_, что может привести к одному из двух вариантов поведения.

Первый вариант поведения реализуется при компиляции программы в режиме отладки; Rust добавляет в нее свой код с проверками целочисленного переполнения, в которых факт переполнения вызывает _панику_ вашей программы во время выполнения. В Rust термин «паника» используется для обозначения поведения, при котором программа аварийно завершает работу с ошибкой; мы обсудим панику более подробно в разделе «Неисправимые ошибки с `panic!`» Главы 9.

Второй вариант поведения реализуется при компиляции программы с флагом `--release`; Rust добавляет в вашу программу код _не_ с проверками целочисленного переполнения, вызывающего панику, а с _переносом дополнения до двух_ (_two’s complement wrapping_). Это значит, что в случае переполнения, когда переменная типа Т имеет значение, превышающее максимальное допустимое значение для типа Т, то происходит «переход» к минимальному значению для типа Т. Например, в случае `u8` значение 256 становится равным 0, значение 257 становится равным 1 и так далее. Программа не будет паниковать, но переменная будет иметь значение, которое отличается от того, что вы ожидали. Полагаться на такое поведение считается ошибкой и требуется явная обработка всех возможных ситуаций переполнения.

Для явной обработки ситуаций переполнения для числовых типов в стандартной библиотеке Rust существует ряд семейств методов:

* Арифметика с переносом (wrap) с помощью методов `wrapping_*`, таких как `wrapping_add`
* Возврат значения `None`, если есть переполнение с помощью методов `checked_*`
* Возврат значения и логического значения, являющегося предикатом переполнения, с помощью методов `overflowing_*`
* Насыщение при минимальном или максимальном значениях с помощью методов `saturating_*`

С детальной информацией о работе этих методов можно ознакомиться в документации стандартной библиотеки.
****

[#_3_2_1_2_floats]
===== Числа с плавающей запятой

В Rust также есть два скалярных типа для чисел с плавающей запятой (float). Типы чисел с плавающей запятой в Rust — это `f32` и `f64`, которые имеют размер 32 и 64 бита соответственно. Тип по умолчанию — `f64`, потому что в современных процессорах он имеет примерно ту же скорость, что и `f32`, но с большей точностью. Все типы с плавающей запятой являются знаковыми.

Вот пример, который показывает числа с плавающей запятой в действии:

Файл: src/main.rs

[source,rust]
----
fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
----

Числа с плавающей запятой в Rust соответствуют стандарту IEEE-754. Тип `f32` — это число с плавающей запятой одинарной точности, а `f64` — число с двойной точностью.

===== Числовые операции

Rust поддерживает основные математические операции, которые ожидаются для всех типов чисел: сложение, вычитание, умножение, деление и взятие остатка. Целочисленное деление округляется до ближайшего целого числа. В следующем коде показано, как использовать каждую числовую операцию в инструкции `let`:

Файл: src/main.rs

[source,rust]
----
fn main() {
    // сложение
    let sum = 5 + 10;

    // вычитание
    let difference = 95.5 - 4.3;

    // умножение
    let product = 4 * 30;

    // деление
    let quotient = 56.7 / 32.2;
    let floored = 2 / 3; // Результат = 0

    // остаток
    let remainder = 43 % 5;
}
----

Каждое выражение в этих инструкциях использует математический оператор и возвращает одно значение, которое затем привязывается к переменной. Приложение B содержит список всех операторов, которые предоставляет Rust.

[#_3_2_1_3_boolean]
===== Логический тип

Как и в большинстве других языков программирования, логический тип (Boolean) в Rust имеет два возможных значения: `true` и `false`. Булевы значения имеют размер один байт. Логический тип в Rust задается ключевым словом `bool`. Например:

Файл: src/main.rs

[source,rust]
----
fn main() {
    let t = true;

    let f: bool = false; // явная аннотация типа
}
----

Основной способ использования логических значений — условные выражения, такие как выражение `if`. Мы расскажем в разделе «Управление потоком управления», как выражения `if` работают в Rust.

[#_3_2_1_4_chars]
===== Символы

Тип `char` — самый примитивный алфавитный тип в Rust. Вот несколько примеров объявления значений `char`:

Файл: src/main.rs

[source,rust]
----
fn main() {
    let c = 'z';
    let z: char = 'Z'; // явная аннотация типа
    let heart_eyed_cat = '😻';
}
----

Обратите внимание, что мы указываем символьные литералы в одинарных кавычках, в отличие от строковых литералов, которые используют двойные кавычки. Тип `char` в Rust имеет размер четыре байта и представляет собой скалярное значение в кодировке Unicode, следовательно, он может представлять гораздо больше, чем просто символ в кодировке ASCII. Буквы с ударением; китайские, японские и корейские иероглифы; эмодзи; и пробелы нулевой ширины являются допустимыми значениями  `char` в Rust. Скалярные значения в кодировке Unicode находятся в диапазоне от `U+0000` до `U+D7FF` и от `U+E000` до `U+10FFFF` включительно. Однако понятие «символ» в привычном нам понимании на самом деле не соответствует концепции Unicode, поэтому ваша интуиция в этом отношении может не совпадать с тем, чем является `char` в Rust. Мы подробно обсудим эту тему в разделе «Сохранение текста в кодировке UTF-8» Главы 8.

[#_3_2_2_compound_types]
==== Составные типы

Составные типы могут группировать несколько значений в один тип. В Rust есть два примитивных составных типа: кортежи (tuples) и массивы (arrays).

[#_3_2_2_1_tuples]
===== Кортежи

Кортеж — это общий способ группировки нескольких значений различных типов в один составной тип. Кортежи имеют фиксированную длину: после объявления они не могут увеличиваться или уменьшаться в размере.

Кортеж создается как список значений, разделенных запятыми, внутри круглых скобок. Каждая позиция в кортеже имеет тип, и типы различных значений в кортеже необязательно должны быть одинаковыми. В этом примере мы добавили необязательные аннотации типов:

Файл: src/main.rs

[source,rust]
----
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
----

Переменная `tup` связывается со всем кортежем, поскольку кортеж считается одним составным элементом. Чтобы получить отдельные значения из кортежа, мы можем использовать сопоставление с образцом (pattern matching) для деструктурирования значения кортежа, например:

Файл: src/main.rs

[source,rust]
----
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {y}");
}
----

Эта программа сначала создает кортеж и привязывает его к переменной `tup`. Затем в `let` используется образец, чтобы взять `tup` и превратить его в три отдельные переменные: `x`, `y` и `z`. Это называется _деструктурированием_, потому что один кортеж разбивается на три части. Наконец, программа выводит значение `y`, равное `6.4`.

Можно также напрямую обращаться к элементу кортежа, используя точку (`.`), за которой следует индекс нужного нам значения. Например:

Файл: src/main.rs

[source,rust]
----
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
----

Эта программа создает кортеж `x`, а затем обращается к каждому элементу кортежа, используя соответствующие индексы. Как и в большинстве языков программирования, первый индекс в кортеже равен 0.

Кортеж без каких-либо значений имеет специальное имя `unit`. Это значение и соответствующий ему тип записываются как `()` и представляют собой пустое значение или пустой возвращаемый тип. Если выражения явно не возвращают никакого значения, то, на самом деле, они неявно возвращают значение типа `unit`.

[#_3_2_2_2_arrays]
===== Массивы

Другой способ получить набор из нескольких значений — это _массив_. Если в кортеже типы элементов могут быть произвольными, то каждый элемент массива должен иметь один и тот же тип. В отличие от массивов в некоторых других языках, массивы в Rust имеют фиксированную длину.

Значения в массиве записываются в виде списка, разделенного запятыми, внутри квадратных скобок:

Файл: src/main.rs

[source,rust]
----
fn main() {
    let a = [1, 2, 3, 4, 5];
}
----

Массивы полезны, когда нужно разместить наши данные в стеке, а не в куче (мы обсудим стек и кучу подробнее в xref:_chapter_4[Главе 4]) или зафиксировать некоторое количество элементов. Однако тип массива не такой гибкий, как тип вектора. Вектор — это аналогичный по функциональности (_Примечание переводчика: но не по внутреннему устройству_!) массиву вид коллекции, предоставляемый стандартной библиотекой, размер которой может увеличиваться или уменьшаться. Если в конкретной ситуации нет уверенности, что использовать — массив или вектор, скорее всего, следует использовать вектор. В Главе 8 векторы обсуждаются более подробно.

Однако массивы более эффективны, когда известно, что количество элементов не нужно будет изменять. Например, если в вашей программе будут использоваться названия месяцев, то с большой вероятностью вы примените для этого массив, а не вектор, потому что знаете, что он всегда будет содержать 12 элементов:

[source,rust]
----
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
----

Тип массива аннотируется посредством квадратных скобок, внутри которых указываются тип каждого элемента, точка с запятой, а затем количество элементов в массиве, например:

[source,rust]
----
let a: [i32; 5] = [1, 2, 3, 4, 5];
----

Здесь `i32` — это тип каждого элемента. Число `5` после точки с запятой означает, что массив содержит пять элементов.

Можно так же инициализировать массив, чтобы он содержал одно и то же значение для каждого элемента, указав начальное значение, за которым следует точка с запятой, а затем длину массива в квадратных скобках, как показано здесь:

[source,rust]
----
let a = [3; 5]; // массив содержит 5 элементов с одинаковым значением 3
----

Массив с именем `a` будет содержать 5 элементов, для которых изначально будет установлено значение `3`. Это краткое представление выражения `let a = [3, 3, 3, 3, 3]`.

====== Доступ к элементам массива

Массив — это отдельный фрагмент памяти известного фиксированного размера, который может быть размещен в стеке. Получить доступ к элементам массива можно с помощью операции индексации, например:

Файл: src/main.rs

[source,rust]
----
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
----

В этом примере переменная с именем `first` получит значение `1`, потому что это значение с индексом `[0]` в массиве. Переменная с именем `second` получит значение `2` из индекса `[1]` в массиве.

====== Недопустимый доступ к элементу массива

Давайте посмотрим, что произойдет, если мы попытаемся получить элемент с индексом, превышающим длину массива. Чтобы сделать это чисто, нам нужен код, который будет получать произвольный индекс во время выполнения, например, запрашивать его у пользователя. В xref:_2_1_processing_user_input[Главе 2] мы уже реализовали похожее решение, поэтому воспользуемся им и модифицируем его для наших целей:

Файл: src/main.rs

[source,rust]
----
use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!("Please enter an array index.");

    let mut index = String::new();

    io::stdin()
        .read_line(&mut index)
        .expect("Failed to read line");

    let index: usize = index
        .trim()
        .parse()
        .expect("Index entered was not a number");

    let element = a[index];

    println!("The value of the element at index {index} is: {element}");
}
----

Этот код успешно компилируется. Если его запустить, используя команду `cargo run`, и ввести 0, 1, 2, 3 или 4, программа выведет соответствующее значение по этому индексу в массиве. Если вместо этого вы введете число больше длины массива, например 10, то получите ошибку:

[example]
----
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10',
src/main.rs:19:19 note: run with `RUST_BACKTRACE=1` environment variable to display
a backtrace
----

Программа упала с _ошибкой времени выполнения_ (_runtime error_) в момент использования недопустимого значения в операции индексирования. При завершении было выдано сообщение об ошибке и не выполнился `println!` в последней строке. Когда в программе есть операции с индексами массива, Rust для каждой такой операции добавляет свой код с проверкой индекса на выход за границы массива. Если во время выполнения эта проверка покажет, что индекс выходит за границы массива (меньше 0 или больше длины массива), ваша программа запаникует. Очевидно, что указанные проверки должны выполняться во время выполнения, особенно в нашем случае, когда компилятору неизвестно, какое значение индекса введет пользователь при запуске программы.

Это пример принципов безопасности памяти Rust в действии. Во многих низкоуровневых языках такая проверка не выполняется, и когда вы указываете неправильный индекс, может быть получен доступ к недопустимой памяти. Rust защищает вас от такого рода ошибок, немедленно завершая выполнение кода, вместо того, чтобы разрешать доступ к памяти и продолжать работу. В Главе 9 подробнее обсуждаются обработка ошибок в Rust и техники разработки безопасного кода, который не позволяет получить недопустимый доступ к памяти, но при этом не вызывает паники.
