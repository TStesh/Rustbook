[#_4_2_referencing]
=== 4.2. Ссылки и заимствование

Проблема с кодом в листинге 4-5 заключается в том, что поскольку владение `String` было перемещено в функцию `calculate_length`, то нужно вернуть это владение вызывающей функции для дальнейшего использования `String` после вызова `calculate_length`. Но вместо передачи и возврата владения можно предоставить ссылку на значение `String`! _Ссылка_ (_reference_) похожа на указатель (pointer) в том смысле, что это адрес в памяти, где хранятся данные; по факту эти данные принадлежат какой-то другой переменной. В отличие от указателя, ссылка в течение всего срока своего существования гарантированно указывает на действительное значение определенного типа. Значение, на которые указывает ссылка, называется _референтом_.

Вот как можно было бы определить и использовать функцию `calculate_length`, у которой в качестве параметра используется ссылка на объект вместо передачи владения этим объектом:

Файл: src/main.rs

[source,rust]
----
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{s1}' is {len}.");
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
----

Обратите внимание на два момента. Во-первых, в объявлении переменной и возвращаемом значении функции исчезли кортежи. Во-вторых, в функцию `calculate_length` передается `&s1` и в ее сигнатуре используется `&String`, а не `String`. Символ `&` представляет синтаксис _ссылки_. С его помощью можно получить ссылку (referencing) на значение, не становясь его владельцем. Эта концепция показана на рисунке 4-5.

image::trpl04-05.svg[caption="Рисунок 4-5: ", title="Схема ссылки &String, указывающей на String", pdfwidth=90%]

[sidebar]
Операцией, противоположной получению ссылки, является операция разыменования (dereferencing), которая выполняется с помощью оператора разыменования `*`. Мы рассмотрим некоторые варианты использования этого оператора в Главе 8 и обсудим детали его работы в Главе 15.

Давайте подробнее рассмотрим вызов функции:

[source,rust]
----
    let s1 = String::from("hello");

    let len = calculate_length(&s1);
----

Выражение `&s1` позволяет создать ссылку на значение `s1` и не владеть им. Поскольку ссылка не владеет значением, то это значение, на которое указывает ссылка, не будет удалено, когда ссылка перестанет использоваться.

Точно так же `&` используется в сигнатуре функции для обозначения, что тип параметра `s` является ссылкой. Добавим несколько поясняющих комментариев:

[source,rust]
----
fn calculate_length(s: &String) -> usize { // s — ссылка на String
    s.len()
} // Здесь s выходит из области действия. Но так как она не владеет тем,
  // на что ссылается, то String не удаляется.
----

Область действия переменной `s` совпадает с областью действия функции `calculate_length`, но когда `s` перестает использоваться (в нашем случае при выходе из функции), значение, на которое указывает `s`, не удаляется, потому что `s` не является его владельцем. Когда в функциях в качестве параметров вместо фактических значений используются ссылки, возвращать значения для передачи владения уже не требуется, потому что никакого владения у таких параметров нет.

Получение ссылки называется в Rust _заимствованием_ (_borrow_). Это похоже на то, что происходит в реальной жизни: если кто-то владеет вещью, вы можете ее одолжить. После завершения пользования вам нужно вернуть вещь владельцу, так как не владеете ее.

Что произойдет, если мы попытаемся изменить то, что заимствовали? Попробуйте выполнить код из листинга 4-6. Спойлер: он не работает!

--
.Листинг 4-6: Попытка изменить заимствованное значение

Файл: src/main.rs

[source,rust]
----
fn main() {
    let s = String::from("hello");

    change(&s);
}

fn change(some_string: &String) {
    some_string.push_str(", world");
}
----
--

Ошибка:

[example]
----
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&` reference
 --> src/main.rs:8:5
  |
7 | fn change(some_string: &String) {
  |                        ------- help: consider changing this to be a mutable reference:
  |                                     `&mut String`
8 |     some_string.push_str(", world");
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `some_string` is a `&` reference, so the data it
  |                                      refers to cannot be borrowed as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership` due to previous error
----

Ссылки, как переменные, неизменяемы по умолчанию. Нам не разрешено изменять заимствованное значение.

==== Изменяемые ссылки

Можно разрешить изменение заимствованного значения с помощью ключевого слова `mut`. Покажем это на примере кода из листинга 4-6, в котором несколькими небольшими правками перейдем к использованию _изменяемой ссылки_:

Файл: src/main.rs

[source,rust]
----
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
----

Что мы сделали: заменили `s` на `mut s`, затем в функции `change` создали изменяемую ссылку с помощью `&mut s`, и обновили сигнатуру функции `some_string: &mut String`, чтобы принимать изменяемую ссылку. Теперь функция `change` получила возможность изменять заимствованное значение.

У изменяемые ссылок есть одно большое ограничение: при наличии в коде изменяемой ссылки на какое-то значение нельзя создать никакие другие ссылки на это значение. Ниже приведен пример кода, в котором делается попытка создать две изменяемые ссылки на `s`, которая приведет к ошибке на этапе компиляции:

Файл: src/main.rs

[source,rust]
----
    let mut s = String::from("hello");

    let r1 = &mut s;
    let r2 = &mut s;

    println!("{r1}, {r2}");
----

Ошибка:

[example]
----
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --> src/main.rs:5:14
  |
4 |     let r1 = &mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 |
7 |     println!("{r1}, {r2}");
  |                -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership` due to previous error
----

Эта ошибка говорит, что нельзя заимствовать `s` как изменяемую ссылку более одного раза подряд. Первое изменяемое заимствование находится в `r1` и должно длиться до тех пор, пока оно не будет использовано в `println!`, но между созданием этой изменяемой ссылки и ее использованием мы попытались создать еще одну изменяемую ссылку `r2`, которая заимствует те же данные, что и `r1`.

Запрет иметь одновременно несколько изменяемых ссылок на одни и те же данные, тем не менее можно обойти, но сделать это очень непросто. Новые пользователи Rust, впервые сталкиваясь с таким ограничением, не сразу принимают его и пытаются с ним бороться, потому что в большинстве других языков ничего подобного нет. Ключевое преимущество ограничения заключается в том, что благодаря ему Rust может предотвратить гонки данных (data races) во время компиляции. _Гонка данных_ похожа на состояние реальной гонки и возникает, когда одномоментно выполняются следующие три условия:

* Два или более указателя одновременно обращаются к одним и тем же данным.
* По крайней мере один из указателей используется для записи данных.
* Механизм синхронизации доступа к данным не используется.

Гонки данных вызывают _неопределенное поведение_ (_undefined behavior = UB_), их крайне сложно диагностировать и исправлять, особенно при отслеживании работы кода во время выполнения; Rust предотвращает эту проблему еще на этапе компиляции, отказываясь компилировать код с гонками данных!

Как обычно, мы можем использовать фигурные скобки для создания новой области действия, позволяющей использовать несколько изменяемых ссылок, но не _одновременно_; этот код успешно компилируется и работает:

[source,rust]
----
    let mut s = String::from("hello");

    {
        let r1 = &mut s;
    } // r1 здесь выходит из области действия, поэтому можем без проблем создать новую ссылку.

    let r2 = &mut s;
----

Rust применяет запрет на гонки данных и в случае совместного использования изменяемых и неизменяемых ссылок. Следующий код не компилируется:

[source,rust]
----
    let mut s = String::from("hello");

    let r1 = &s; // нет проблемы
    let r2 = &s; // нет проблемы
    let r3 = &mut s; // БОЛЬШАЯ ПРОБЛЕМА

    println!("{r1}, {r2}, and {r3}");
----

Ошибка:

[example]
----
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --> src/main.rs:6:14
  |
4 |     let r1 = &s; // нет проблемы
  |              -- immutable borrow occurs here
5 |     let r2 = &s; // нет проблемы
6 |     let r3 = &mut s; // БОЛЬШАЯ ПРОБЛЕМА
  |              ^^^^^^ mutable borrow occurs here
7 |
8 |     println!("{r1}, {r2}, and {r3}");
  |                -- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
----

Вот так! У нас _также_ не может быть изменяемой ссылки, пока у нас есть неизменяемая ссылка на то же значение.

Пользователи неизменяемой ссылки не ожидают, что значение внезапно изменится! Однако разрешается создавать более одной неизменяемой ссылки на одни и те же данные, потому что при одновременном доступе к данным на чтение ситуации гонок данных не возникает: никакой из читателей данных не может повлиять на их чтение другими читателями.

Но тут есть важный нюанс. Обратите внимание, что область действия ссылки начинается с того места, где она была введена, и продолжается до момента ее последнего использования. Например, следующий код будет скомпилирован, потому что последнее использование неизменяемой ссылки, `println!`, происходит до того, как будет введена изменяемая ссылка:

[source,rust]
----
    let mut s = String::from("hello");

    let r1 = &s; // нет проблемы
    let r2 = &s; // нет проблемы
    println!("{r1} and {r2}");
    // переменные r1 and r2 дальше не используются
    // их область действия заканчивается здесь

    let r3 = &mut s; // нет проблемы
    println!("{r3}");
----

Область действия неизменяемых ссылок `r1` и `r2` заканчивается после `println!`, где они использовались в последний раз, то есть до создания изменяемой ссылки `r3`. Область `r1` и `r2` не перекрывается (overlap) областью `r3`, поэтому этот код разрешен. Способность компилятора учитывать, что ссылка больше не используется с какого-то момента до конца области действия, называется _Non-Lexical Lifetimes_ (сокращенно NLL); более детально об этом можно прочитать здесь: _https://doc.rust-lang.org/edition-guide/rust-2018/ownership-and-lifetimes/non-lexical-lifetimes.html_.

Несмотря на то, что ошибки заимствования могут иногда вызывать разочарование, помните, что компилятор Rust заранее указывает на потенциальную проблему (во время компиляции, а не во время выполнения) и точно показывает, в чем ее суть. Тогда вам не придется выяснять, почему что-то не так с вашими данными, и они не такие, как вы думали.

[#_4_2_dangling_reference]
==== Висячие ссылки

В языках с указателями легко ошибочно создать _висячий (dangling) указатель_ — указатель, ссылающийся на место в памяти, которое могло быть передано кому-то другому — путем освобождения части памяти при сохранении указателя на эту память. В Rust, напротив, компилятор гарантирует, что ссылки никогда не станут висячими: если у вас есть ссылка на какие-то данные, компилятор гарантирует, что данные не выйдут за пределы области действия до того, как это произойдет со ссылкой на эти данные.

Давайте попробуем создать висячую ссылку, чтобы посмотреть, как Rust предотвратит нашу попытку с помощью ошибки времени компиляции:

Файл: src/main.rs

[source,rust]
----
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");

    &s
}
----

Ошибка:

[example]
----
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 --> src/main.rs:5:16
  |
5 | fn dangle() -> &String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for
          it to be borrowed from
help: consider using the `'static` lifetime
  |
5 | fn dangle() -> &'static String {
  |                ~~~~~~~~

For more information about this error, try `rustc --explain E0106`.
error: could not compile `ownership` due to previous error
----

Сообщение об ошибке относится к пока не рассмотренной нами концепции: временам жизни (lifetimes), о которых мы подробно поговорим в <<_10_3_lifetimes,Главе 10>>. Если не обращать внимание на текст о времени жизни, сообщение об ошибке на самом деле содержит ключ к тому, почему этот код является проблемным:

[example]
----
this function's return type contains a borrowed value, but there is no value for it to be
borrowed from (возвращаемый тип этой функции содержит заимствованное значение, но значение
для этого заимствования отсутствует)
----

Давайте подробнее рассмотрим, что именно происходит на каждом этапе функции `dangle`:

[source,rust]
----
fn dangle() -> &String { // dangle возвращает ссылку на String

    let s = String::from("hello"); // s — новый String

    &s // мы возвращаем ссылку на s
} // Здесь s выходит из области действия и удаляется. Ее память освобождается.
  // Опасность!
----

Поскольку переменная `s` создается внутри `dangle`, то при завершении функции `s` будет освобождена. Но мы то пытаемся вернуть ссылку на эту переменную. Это означает, что ссылка в вызывающей функции будет указывать на недействительный `String`. Это очень плохо! Rust не позволит нам этого сделать.

Решение состоит в том, чтобы вернуть `String` напрямую:

[source,rust]
----
fn no_dangle() -> String {
    let s = String::from("hello");

    s
}
----

Функция работает без проблем. Владение перемещается вовне, и ничего не нужно освобождать.

==== Правила заимствования

Давайте подытожим, что мы узнали о ссылках:

[IMPORTANT]
====
* В любой момент времени у вас может быть либо одна изменяемая ссылка, либо любое количество неизменяемых ссылок.
* Ссылки всегда должны быть действительными.
====

Далее мы рассмотрим особую разновидность ссылок: срезы (slices).
