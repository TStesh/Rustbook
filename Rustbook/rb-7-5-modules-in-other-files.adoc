[#_7_5_separating_modules_into_different_Files]
=== 7.5. Разделение модулей по разным файлам

До сих пор все примеры в этой главе определяли несколько модулей в одном файле. Когда модули становятся большими, для упрощения навигации по коду может возникнуть необходимость перемещения их определений в разные файлы.

Давайте начнем с кода в листинге 7-17, в котором было несколько модулей программы ресторана. Вместо определения всех модулей в корневом файле крейта перенесем модули в отдельные файлы. Корневой файл крейта в данном случае — _src/lib.rs_, но процедура работает точно также и с бинарными крейтами, у которых корневой файл — _src/main.rs_.

Сначала перенесем в отдельный файл модуль `front_of_house`. Удалите код внутри фигурных скобок модуля `front_of_house`, оставив только строку с объявлением `mod front_of_house;`; таким образом _src/lib.rs_ содержит код, показанный в листинге 7-21. Обратите внимание, что этот код не будет компилироваться, пока мы не создадим файл _src/front_of_house.rs_ с кодом из листинга 7-22.

--
.Листинг 7-21. Объявление модуля front_of_house, тело которого будет в файле src/front_of_house.rs

Файл: src/lib.rs

[source,rust]
----
mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
----
--

Затем поместите код, который был в фигурных скобках, в новый файл с именем _src/front_of_house.rs_, как показано в листинге 7-22. Компилятор знает, что нужно смотреть в этот файл, потому что видит объявление модуля с именем `front_of_house` в корне крейта, но не видит его определения в коде корневого модуля.

--
.Листинг 7-22. Содержимое модуля front_of_house в файле src/front_of_house.rs

Файл: src/front_of_house.rs

[source,rust]
----
pub mod hosting {
    pub fn add_to_waitlist() {}
}
----
--

Обратите внимание, что нужно только _один раз_ загрузить файл в дерево модулей с помощью инструкции `mod`. Другие файлы в вашем проекте должны ссылаться на код загруженного файла, используя путь к области действия, где он был объявлен, в соответствии с описанием раздела «Пути для ссылки на элемент в дереве модулей» этой главы. Другими словами, `mod` — это _не_ операция «включения», которую вы могли видеть в других языках программирования (например, инструкция препроцессора `#include` в языках С и С++).

Теперь перенесем в отдельный файл модуль `hosting`. Процесс немного отличается, потому что этот модуль является дочерним модулем модуля `front_of_house`, а не корневого модуля. Мы поместим файл для `hosting` в новый каталог, который будет назван по именам всех его предков в дереве модулей, в данном случае _src/front_of_house/_.

Чтобы начать перенос модуля `hosting`, изменим файл _src/front_of_house.rs_ так, чтобы он содержал только объявление `hosting`:

Файл: src/front_of_house.rs

[source,rust]
----
pub mod hosting;
----

Далее создадим каталог _src/front_of_house_ и в нем файл _hosting.rs_ с определением модуля `hosting`:

Файл: src/front_of_house/hosting.rs

[source,rust]
----
pub fn add_to_waitlist() {}
----

Если вместо этого поместить файл _hosting.rs_ в каталог _src_, компилятор будет ожидать, что код _hosting.rs_ будет находиться в модуле `hosting`, объявленном в корне крейта, а не в дочернем модуле модуля `front_of_house`. Из правил компилятора для сверки файлов с кодом модулей следует, что каталоги и файлы наиболее точно соответствуют дереву модулей.

[sidebar]
.Альтернативные файловые пути
****
Рассмотренные в этой главе файловые пути являются наиболее идиоматическими в компиляторе Rust, но в Rust также поддерживается устаревший стиль файловых путей. Для модуля с именем `front_of_house`, объявленного в корне крейта, компилятор будет искать код модуля в:

* _src/front_of_house.rs_ (этот вариант мы рассмотрели)
* _src/front_of_house/mod.rs_ (устаревший стиль, все еще поддерживаемый способ задания пути к файлу)

Для модуля с именем `hosting`, который является подмодулем `front_of_house`, компилятор будет искать код модуля в:

* _src/front_of_house/hosting.rs_ (этот вариант мы рассмотрели)
* _src/front_of_house/hosting/mod.rs_ (устаревший стиль, все еще поддерживаемый способ задания пути к файлу)

Если вы используете оба стиля для одного и того же модуля, то получите ошибку компилятора. В рамках одного проекта смешивать стили разрешено только для разных модулей, но это может сбить с толку разработчиков, перемещающихся по вашему проекту.

Основной недостаток стиля, в котором используются файлы с именами _mod.rs_, проявляется в случае, когда в вашем проекте много разных файлов с именами _mod.rs_ — может возникнуть путаница при их одновременном открытии в текстовом редакторе.
****

Мы перенесли код каждого модуля в отдельный файл, при этом дерево модулей осталось прежним. Вызовы функций в функции `eat_at_restaurant` будут работать без каких-либо изменений, несмотря на то, что их определения теперь находятся в разных файлах. Этот метод позволяет без проблем перемещать модули в новые файлы по мере их увеличения.

Обратите внимание, что в _src/lib.rs_ не изменилась и инструкция `pub use crate::front_of_house::hosting`, а `use` никак не влияет на компиляцию файлов как частей крейта. Ключевое слово `mod` объявляет модули, и Rust ищет код модуля в файле с тем же именем, что и имя модуля.
