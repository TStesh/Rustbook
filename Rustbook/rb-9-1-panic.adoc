[#_9_1_panic]
=== 9.1 Неустранимые ошибки и panic!

Иногда ваш код сбоит, и с этим ничего не поделаешь (_Примечание переводчика: в оригинале написано так: "Sometimes, bad things happen in your code, and there’s nothing you can do about it". Это отсылка к известной фразе "sometimes s**t happens" из фильма "Форрест Гамп"_). Для таких случаев в Rust есть макрос `panic!`. На практике вызвать панику можно двумя способами: выполнить действие, приводящее к аварийному завершению кода (например, попытаться получить доступ к массиву за его границами), или явным образом выполнить макрос `panic!`. В состоянии паники по умолчанию выводится сообщение об ошибке, раскручивается (unwind) и очищается стек, завершается работа программы. Через переменную среды также можно активировать режим распечатки стека вызовов при возникновении паники, чтобы упростить отслеживание ее источника.

.Раскрутка стека или прерывание в ответ на панику
****
По умолчанию, когда возникает паника, в программе запускается _раскрутка_ (_unwinding_): Rust идет по стеку и очищает данные каждой функции, с которой сталкивается. Однако этот процесс очищения стека может занять много времени. В связи с этим Rust позволяет вам выбрать альтернативу — _немедленное прерывание_ (_aborting_), которая завершает программу без очистки.

В случае немедленного завершения забота об очистке памяти, которую использовала программа, ложится на операционную систему. Если в вашем проекте нужно сделать размер исполняемого файла как можно меньше, добавьте `panic = 'abort'` в соответствующие разделы `[profile]` файла _Cargo.toml_, чтобы переключиться из режима раскрутки в режим прерывания при возникновении паники. Например, для режима релизной сборки должно быть так:

[source,toml]
----
[profile.release]
panic = 'abort'
----
****

Давайте попробуем вызвать `panic!` в простейшей программе:

Файл: src/main.rs

[source,rust]
----
fn main() {
    panic!("crash and burn");
}
----

При запуске программе вы увидите что-то вроде этого:

[example]
----
$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/panic`
thread 'main' panicked at 'crash and burn', src/main.rs:2:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
----

Макрос `panic!` выводит сообщение об ошибке, содержащееся в последних двух строках. Первая строка показывает текст сообщения, переданного макросу в качестве параметра и место в исходном коде, где произошла паника: _src/main.rs:2:5_ указывает, что это вторая строка, пятый символ в нашем файле _src/main.rs_.

В данном случае указанная строка является частью нашего кода, и если мы перейдем к этой строке, то увидим вызов макроса `panic!`. В других случаях `panic!` может быть вызван в коде, запускаемом нашей программой, и тогда имя файла и номер строки, указанные в сообщении об ошибке, будут относиться, не к нашему, а к стороннему коду, в котором произошел вызов макроса `panic!`. Чтобы выяснить, что вызывает проблему в нашем коде, можно использовать обратную трассировку (backtrace) функций, начиная с функции, в которой произошел вызов `panic!`. Давайте обсудим обратные трассировки более подробно.

==== Использование обратной трассировки

Рассмотрим другой пример, в котором вызов `panic!` происходит в коде стандартной библиотеки из-за ошибки в нашей программе, а не когда мы непосредственным вызываем макрос. В листинге 9-1 делается попытка получить доступ к индексу в векторе за пределами допустимого диапазона:

.Листинг 9-1. Попытка доступа к элементу за границами вектора приведет к панике
[source,rust]
----
fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
----

В этом коде мы пытаемся получить доступ к 100-му элементу нашего вектора (который имеет индекс 99, потому что индексация начинается с нуля), но вектор имеет только 3 элемента. В этой ситуации Rust паникует: оператор `[]` должен возвращать элемент, но когда ему передается недопустимый индекс, возвращать нечего.

В языке C попытка чтения за пределами границ структуры данных является неопределенным поведением. Вы можете получить все что-угодно из области памяти, на которую в текущий момент ссылается код, даже если эта память не принадлежит этой структуре. Такое действие называется _buffer overread_ (детали см. по ссылке _https://en.wikipedia.org/wiki/Buffer_over-read_) и может привести к серьезной проблеме в системе безопасности, если злоумышленнику удастся получить возможность манипулировать индексом таким образом, чтобы прочитать хранящиеся после структуры данных данные, к которым у него не должно быть доступа.

Для защиты программы от такого рода уязвимости, Rust при попытке прочитать элемент по несуществующему индексу просто аварийно завершит выполнение кода. Давайте попробуем:

[example]
----
$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
----

Ошибка указывает на строку 4 нашего _main.rs_, где мы пытаемся получить доступ к индексу 99. Следующая строка сообщает нам, что можно установить переменную среды `RUST_BACKTRACE`, чтобы получить обратную трассировку того, что именно произошло и стало причиной ошибки. _Обратная трассировка_ — это список всех функций, которые были вызваны в процессе выполнения к моменту достижения текущей точки кода. Работа с обратными трассировками в Rust ничем не отличается от других языков: чтобы правильно понять ее вывод, надо начать сверху и читать до тех пор, пока не встретите упоминание исходных файлов, которые написаны вами. Это место, где возникла проблема. Строки выше — это код, вызываемый вашей программой; строки ниже - код, вызывающий вашу программу. Эти строки «до и после» могут включать код ядра Rust, код стандартной библиотеки или крейтов, которые вы используете. Давайте получим обратную трассировку, установив для переменной среды `RUST_BACKTRACE` любое значение, кроме 0. В листинге 9-2 показан пример вывода:

.Листинг 9-2: Вывод сгенерированной вызовом `panic!` обратной трассировки после установки переменной среды RUST_BACKTRACE
[example]
----
$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/std/src/panicking.rs:483
   1: core::panicking::panic_fmt
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/panicking.rs:85
   2: core::panicking::panic_bounds_check
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/panicking.rs:62
   3: <usize as core::slice::index::SliceIndex<[T]>>::index
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/slice/index.rs:255
   4: core::slice::index::<impl core::ops::index::Index<I> for [T]>::index
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/slice/index.rs:15
   5: <alloc::vec::Vec<T> as core::ops::index::Index<I>>::index
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/alloc/src/vec.rs:1982
   6: panic::main
             at ./src/main.rs:4
   7: core::ops::function::FnOnce::call_once
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/ops/function.rs:227
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
----

Как видим, выводится много всего! Текст вывода зависит от операционной системы и версии Rust, поэтому с большой вероятностью вы увидите немного другой набор строк. Укажем еще на одну деталь: чтобы получить трассировки как в примере, должны быть активированы символы отладки (debug symbols); по умолчанию они активируются, когда используются команды `cargo build` и `cargo run` без флага `--release`.

В выводе в листинге 9-2 строка 6 обратной трассировки указывает на проблемную строку в нашем проекте: это строка 4 файла _src/main.rs_. Чтобы разобраться, почему наша программа запаниковала, мы должны начать исследование с места, на которое в тексте трассировки указывает строка с упоминанием первого же написанного нами файла. В листинге 9-1, где мы преднамеренно написали код, вызывающий панику, понятно, что стало причиной проблемы и как ее исправить — не запрашивать элемент за пределами допустимого диапазона векторных индексов. Когда в будущем в вашем коде возникнет паника, вам нужно будет выяснить, какое действие и с какими значениями вызывает панику в вашем коде, и что предпринять для исключения такого поведения кода.

Мы еще вернемся к `panic!` в разделе «Паниковать или нет?» далее в этой главе, где обсудим необходимость применения паники при обработке условий ошибки. Теперь давайте рассмотрим, как работать с восстановимыми ошибками с помощью перечисления `Result`.
