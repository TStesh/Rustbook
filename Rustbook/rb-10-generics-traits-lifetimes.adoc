[#_chapter_10]
== Глава 10. Обобщенные типы, трейты и времена жизни

В каждом языке программирования есть инструменты для эффективного устранения дублирования кода. В Rust одним из таких инструментов являются _обобщенные типы_ (_generics_): абстрактные заменители для конкретных типов или других свойств. Мы можем описать поведение обобщенных типов или то, как они соотносятся с другими обобщенными типами, не зная, какой конкретный тип будет на их месте при компиляции и запуске кода.

Функции могут принимать параметры некоторого обобщенного типа вместо конкретного типа, такого как `i32` или `String`, точно так же как принимают параметры с заранее неизвестными значениями для запуска одного и того же кода с различными конкретными значениями этих параметров. На самом деле, мы уже использовали обобщенные типы в <<_6_1_option,Главе 6>> с `Option<T>`, в <<_8_1_vectors,Главе 8>> с `Vec<T>` и `HashMap<K, V>` и в <<_9_2_result,Главе 9>> с `Result<T, E>`. В этой главе вы узнаете, как применять обобщенные типы в ваших собственных структурах данных, функциях и методах!

Сначала мы рассмотрим, как извлечь функцию, чтобы уменьшить дублирование кода. Затем воспользуемся той же техникой, чтобы создать обобщенную функцию из двух функций, которые отличаются только типами своих параметров. Также объясним, как использовать обобщенные типы в определениях структур и перечислений.

Затем вы узнаете, как применять _трейты_ (_traits_) для определения поведения обобщенным способом и комбинировать их с обобщенными типами для настройки этих типов таким образом, чтобы обобщенный тип принимал не произвольный конкретный тип, а только типы с определенным поведением.

Наконец, мы обсудим _времена жизни_ (_lifetimes_): разновидность обобщенных типов, которые предоставляют компилятору информацию о том, как ссылки связаны друг с другом. Благодаря временам жизни компилятор получает от нас дополнительную информацию о заимствованных значениях, которая позволяет ему гарантировать действительность ссылок в большем количестве ситуаций, чем в случае отсутствия такой информации с нашей стороны.

=== Исключение дублирования путем извлечения функции

Обобщенные типы позволяют нам заменять конкретные типы параметрами типа, чтобы исключить дублирование кода. Прежде чем погрузиться в синтаксис обобщенных типов, давайте сначала посмотрим, как исключить дублирование без применения обобщенного типа. Для это применяется техника извлечения функции, в которой конкретные значения заменяются параметром, представляющим сразу множество значений. Затем мы применим ту же технику для извлечения обобщенной функции! Разобравшись в том, как распознавать дублированный код, который можно извлечь в функцию, вы сможете делать то же самое и с использованием обобщенных типов.

Начнем с короткой программы в листинге 10-1, которая находит наибольшее число в списке.

--
.Листинг 10-1: Поиск максимального в списке чисел

Файл: src/main.rs

[source,rust]
----
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = &number_list[0];

    for number in &number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);
    assert_eq!(*largest, 100);
}
----
--

Список целых чисел хранится в переменной `number_list`, ссылку на первое число в списке размещена в переменной с именем `largest`. Затем перебираем все числа в списке, и если текущее число больше, чем число, хранящееся в `largest`, записываем ссылку на него в `largest`. Если же текущее число меньше или равно наибольшему из просмотренных до сих пор чисел, переменная не изменяется, и код переходит к следующему числу в списке. После рассмотрения всех чисел в списке `largest` должно ссылаться на самое большое число, которое в данном случае равно 100.

Теперь перед нами стоит задача найти наибольшее число в двух разных списках чисел. Для этого мы можем дублировать код из листинга 10-1 и использовать ту же логику в двух разных местах программы, как показано в листинге 10-2.

--
.Листинг 10-2: Поиск максимального в двух списках чисел

Файл: src/main.rs

[source,rust]
----
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = &number_list[0];

    for number in &number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = &number_list[0];

    for number in &number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);
}
----
--

Хотя эта программа и работает, дублирование кода утомительно и чревато ошибками. Нужно также постоянно помнить об обновлении кода в нескольких местах в случае изменения логики программы.

Для исключения дублирования давайте создадим абстракцию, определив функцию, которая работает с любым списком целых чисел, переданным в параметре. Благодаря этому наш код будет более понятным, а выражение концепции нахождения наибольшего числа в списке станет более общей.

В листинге 10-3 извлекаем код, который находит наибольшее число, в функцию с именем `largest`. Затем вызываем эту функцию, чтобы найти наибольшее число в двух списках из листинга 10-2. Очевидно, что использовать эту функцию можно для любого другого списка значений `i32`, который может появиться в будущем.

--
.Листинг 10-3: Более общий код для поиска наибольшего числа в двух списках

Файл: src/main.rs

[source,rust]
----
fn largest(list: &[i32]) -> &i32 {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);
    assert_eq!(*result, 100);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&number_list);
    println!("The largest number is {}", result);
    assert_eq!(*result, 6000);
}
----
--

Параметр `list` функции `largest` является срезом произвольных значений `i32`, которые можно передать в функцию. В результате при вызове функции код работает с конкретными значениями, которые ей передаются.

Итак, вот шаги, которые мы предприняли, чтобы изменить код из листинга 10-2 в листинг 10-3:

. Определили повторяющийся код.
. Извлекли повторяющийся код в тело функции и указали входные и возвращаемые значения этого кода в сигнатуре функции.
. Изменили два экземпляра дублированного кода на вызов функции.

Мы пойдем дальше в исключении дублирования кода, и применяя те же шаги, придем к обобщенным типам. Идею таких типов можно выразить следующим образом: как в теле функции можно работать с более общим, абстрактным `list` вместо конкретных значений, точно так же обобщенные типы позволяют коду работать с более общими, абстрактными структурами данных.

Например, предположим, что у нас есть две функции: одна находит наибольший элемент в срезе значений `i32`, а другая - в срезе значений `char`. Как бы мы устранили это дублирование? Давайте выясним!

include::rb-10-1-generic-data-types.adoc[]

include::rb-10-2-traits.adoc[]

include::rb-10-3-lifetimes.adoc[]
