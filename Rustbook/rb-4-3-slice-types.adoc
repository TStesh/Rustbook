[#_4_3_slices]
=== 4.3. Срезы

_Срезы_ позволяют ссылаться на непрерывную последовательность элементов в коллекции, причем необязательно на всю коллекцию в целом. Срез является разновидностью ссылки, поэтому относится к категории не владеющих типов (not-owned types).

Рассмотрим небольшую задачу по программированию: написать функцию, которая принимает строку слов, разделенных пробелами, и возвращает первое слово, найденное в этой строке. Если функция не находит пробела в строке, строка считается состоящей из одного слова, и должна быть возвращена целиком как результат работы функции.

Давайте рассмотрим, как бы мы написали сигнатуру этой функции без использования срезов, чтобы понять проблему, которую срезы помогают решить:

[source,rust]
----
fn first_word(s: &String) -> ?
----

У функции `first_word` в качестве параметра указан `&String`. Владение нам не требуется, так что все в порядке. Но что мы должны вернуть? На самом деле, у нас пока нет способа определения _части_ строки (подстроки). Но мы могли бы например вернуть индекс конца слова, обозначенного пробелом. Давайте попробуем это сделать; соответствующий код как показан в листинге 4-7.

--
.Листинг 4-7. Функция first_word, возвращающая значение индекса байта в параметре String

Файл: src/main.rs

[source,rust]
----
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
----
--

Поскольку нам нужно посимвольно просмотреть `String` и проверить, является ли очередной символ пробелом, то преобразуем нашу строку в массив байтов с помощью метода `as_bytes`:

[source,rust]
----
    let bytes = s.as_bytes();
----

Далее создадим итератор коллекции байтов, используя метод `iter`:

[source,rust]
----
    for (i, &item) in bytes.iter().enumerate() {
----

Мы обсудим итераторы более подробно в Главе 13. А пока достаточно знать, что `iter` — это метод, который возвращает каждый элемент коллекции, а `enumerate` преобразует результат `iter` в кортеж: первый элемент кортежа является индексом очередного элемента из коллекции, второй элемент — ссылкой на этот элемент. Это удобнее, чем вычислять индекс самостоятельно.

Поскольку метод `enumerate` возвращает кортеж, мы можем использовать сравнение с образцом для его деструктурирования. Подробнее о сравнении с образцом мы поговорим в xref:_6_2_match[Главе 6]. В цикле `for` указываем образец, в котором из кортежа в переменную `i` копируется значение первого элемента (в нашем случае индекс), а в переменную `&item` — значение второго элемента (в нашем случае ссылка на байт). Поскольку из `.iter().enumerate()` приходит ссылка на элемент, в образце используется оператор `&`.

Внутри цикла `for` ищем байт, соответствующий пробелу, используя синтаксис байтового литерала. Если находим пробел, то возвращаем соответствующий индекс (позицию символа в строке). В противном случае возвращаем длину строки с помощью `s.len()`:

[source,rust]
----
        if item == b' ' {
            return i;
        }
    }

    s.len()
----

Теперь у нас есть способ узнать индекс конца первого слова в строке, но при этом возникает следующая проблема. Хотя мы возвращаем только `usize`, его значение имеет смысл только в контексте `&String`. Другими словами, поскольку значение `usize` является независимым от `String`, нет никакой гарантии, что оно будет корректным в будущем. Рассмотрим программу в листинге 4-8, которая использует функцию `first_word` из листинга 4-7.

--
.Листинг 4-8. Сохранение результата вызова функции first_word и последующего изменения содержимого String

Файл: src/main.rs

[source,rust]
----
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s); // word получает значение 5

    s.clear(); // содержимое String очищается, s становится пустой строкой ("")

    // Здесь word все еще имеет значение 5, но больше нет строки,
    // для которой можно осмысленно использовать это значение 5.
    // Таким образом, переменная word является некорректной!
}
----
--

Эта программа компилируется без каких-либо ошибок; она также успешно бы компилировалась, если бы мы использовали `word` после вызова `s.clear()`. Поскольку переменная `word` вообще не связана с состоянием `s`, то, по-прежнему, содержит значение `5`; попытка применить это значение к текущей переменной `s` (пустой строке), приведет к ошибке времени выполнения, потому что содержимое `s` уже не то, для которого мы сохранили `5` в `word`.

Отсутствие синхронизации индекса в `word` с данными в `s` приводит к утомительной и подверженной ошибкам работе по управлению этими индексами! Это управление становится еще более ненадежным, если мы напишем функцию `second_word`. Ее сигнатура должна выглядеть так:

[source,rust]
----
fn second_word(s: &String) -> (usize, usize) {
----

Здесь приходится отслеживать начальный _и_ конечный индексы. Значений, рассчитанных на основе данных в определенном состоянии и не привязанных к этому состоянию, становится больше: теперь у нас уже есть три несвязанные переменные, которые необходимо синхронизировать.

К счастью, в Rust есть решение этой проблемы: строковые срезы.

==== Строковые срезы

_Строковый срез_ является ссылкой на часть `String` и его определение в программе Rust выглядит следующим образом:

[source,rust]
----
    let s = String::from("hello world");

    let hello = &s[0..5];
    let world = &s[6..11];
----

Переменная `hello` является срезом — ссылкой не на весь `String` целиком, а на его часть, указанную в дополнительном элементе `[0..5]`. Срез создается посредством указания диапазона в квадратных скобках `[starting_index..ending_index]`, где `starting_index` — позиция в строке первого элемента среза, а `ending_index` — на единицу большая позиция в строке последнего элемента среза. Внутри себя структура данных среза хранит начальную позицию и длину среза, равную разности между `ending_index`и `starting_index`. Таким образом, в инструкции `let world = &s[6..11];` будет создан срез `world` с размещением в стеке его структуры данных: указателя на символ с индексом 6 в `s` и длины, равной 11 - 6 = 5.

Рисунок 4-6 показывает анатомию среза в виде схемы.

image::trpl04-06.svg[caption="Рисунок 4-6: ", title="Строковый срез, относящийся к части String", pdfwidth=60%]

В синтаксисе диапазона `..` можно не указывать ни `starting_index`, ни `ending_index`. Если не указан `starting_index`, то он принимается равным 0; если не указан `ending_index`, то он принимается равным длине строки. Таким образом, диапазон `..` эквивалентен всей строке.

Примеры эквивалентных определений:

[source,rust]
----
let s = String::from("hello");

let len = s.len();

let slice1 = &s[0..2];
let slice2 = &s[..2];

assert_eq!(slice1, slice2);

let slice3 = &s[3..len];
let slice4 = &s[3..];

assert_eq!(slice3, slice4);

let slice5 = &s[0..len];
let slice6 = &s[..];

assert_eq!(slice5, slice6);
----

В этом коде переменная `slice1` эквивалентна `slice2`, переменная `slice3` эквивалентна `slice4` и переменная `slice5` эквивалентна `slice6`.

[sidebar]
Индексы диапазона строковых срезов должны располагаться на допустимых границах символов UTF-8. Если вы попытаетесь создать фрагмент строки в середине многобайтового символа, ваша программа завершится с ошибкой. В учебных целях мы предполагаем, что в строках используются только однобайтовые символы в кодировке ASCII; более подробное обсуждение обработки UTF-8 приведено в разделе «Сохранение текста в кодировке UTF-8» Главы 8.

С учетом сказанного, давайте перепишем `first_word` так, чтобы функция возвращала срез. Тип строкового среза записывается как `&str`:

Файл: src/main.rs

[source,rust]
----
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
----

Мы получаем индекс конца слова так же, как в листинге 4.7, находя первое вхождение пробела. Когда находим пробел, то возвращаем строковый срез, используя начало строки и индекс пробела в качестве начального и конечного индексов.

Теперь, когда вызываем `first_word`, то возвращаем одно значение, привязанное к исходным данным. Значение состоит из ссылки на начальную позицию среза и количества элементов в срезе.

Возврат среза также будет работать для функции `second_word`:

[source,rust]
----
fn second_word(s: &String) -> &str {
----

Теперь у нас есть простой API, который гораздо сложнее сломать, потому что компилятор гарантирует, что ссылки в `String` останутся действительными. Помните ошибку в программе в листинге 4-8, когда мы получили индекс конца первого слова, но затем очистили строку, так что наш индекс стал недействительным? Этот код был логически неправильным, но не показывал ошибок при компиляции. Проблемы проявятся позже, на этапе выполнения, когда мы попытаемся использовать индекс первого слова на пустой строке. Со срезами сделать такую ошибку уже невозможно, и Rust сообщит о проблеме с нашим кодом гораздо раньше, на этапе компиляции. Вот как выглядит попытка скомпилировать некорректный код:

Файл: src/main.rs

[source,rust]
----
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear(); // ошибка!

    println!("the first word is: {word}");
}
----

Ошибка:

[example]
----
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --> src/main.rs:18:5
   |
16 |     let word = first_word(&s);
   |                           -- immutable borrow occurs here
17 |
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 |
20 |     println!("the first word is: {word}");
   |                                   ---- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
----

Напомним из правил заимствования, что если у нас есть неизменяемая ссылка на какие-то данные, мы уже не можем получить на эти данные изменяемую ссылку. Поскольку функции `clear` необходимо обрезать строку, она должна получить изменяемую ссылку. Макрос `println!` после вызова `clear` использует ссылку в `word`, поэтому неизменяемая ссылка в этот момент все еще должна быть действительной. Rust запрещает одновременное существование изменяемой ссылки в переменной `clear` и неизменяемой ссылки в переменной `word`, и компиляция завершается ошибкой. Rust не только упростил использование нашего API, но и устранил целый класс ошибок во время компиляции!

===== Строковые литералы как срезы

Вспомните, что мы говорили о строковых литералах, хранящихся внутри исполняемого файла. Теперь, когда мы узнали о срезах, то можем правильно понять, чем являются строковые литералы на самом деле:

[source,rust]
----
let s = "Hello, world!";
----

Тип `s` — `&str`: это срез, указывающий на конкретное место исполняемого файла, где хранится содержимое литерала. Вот почему строковые литералы неизменяемы: потому что `&str` — неизменяемая ссылка.

[#_4_3_slice_as_parameter]
===== Строковые срезы как параметры

Применяя срезы строковых литералов и значений `String` можно сделать еще одно улучшение функции `first_word`: заменить в ее сигнатуре `&String` на `&str`!

Опытный разработчик Rust вместо текущей сигнатуры

[source,rust]
----
fn first_word(s: &String) -> &str {
----

написал бы сигнатуру, показанную в листинге 4.9, потому что такая сигнатура позволяет использовать одну и ту же функцию как для значений `&String`, так и для значений `&str`.

--
.Листинг 4-9. Улучшение функции first_word за счет использования строкового среза для типа параметра s

[source,rust]
----
fn first_word(s: &str) -> &str {
----
--

Если у нас есть строковый срез, мы можем передать его напрямую. Если у нас есть `String`, мы можем передать срез `String` или ссылку на `String`. Такая гибкость преимущественно основана на _приведении `deref`_, функции, которую мы рассмотрим в разделе «Неявное приведение Deref в функциях и методах» Главы 15. Определение функции, принимающей строковый срез вместо ссылки на `String`, делает наш API более общим и полезным без потери функциональности:

Файл: src/main.rs

[source,rust]
----
fn main() {
    let my_string = String::from("hello world");

    // `first_word` работает со срезами `String`, частичными или полными
    let word = first_word(&my_string[0..6]);
    let word = first_word(&my_string[..]);

    // `first_word` также работает со ссылкой на `String`,
    // который эквивалентен полному срезу `String`
    let word = first_word(&my_string);

    let my_string_literal = "hello world";

    // `first_word` работает со срезами строковых литералов, частичными или полными
    let word = first_word(&my_string_literal[0..6]);
    let word = first_word(&my_string_literal[..]);

    // Так как строковые литералы — это уже строковые срезы,
    // то такой вызов тоже работает, без применения синтаксиса срезов!
    let word = first_word(my_string_literal);
}
----

==== Другие варианты срезов

Строковые срезы, очевидно, специфичны для строк. Но есть и более общий тип среза. Рассмотрим вот такой массив:

[source,rust]
----
let a = [1, 2, 3, 4, 5];
----

Точно так же, как мы можем ссылаться на часть строки, мы можем ссылаться и на часть массива. Это делается так:

[source,rust]
----
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3];

assert_eq!(slice, &[2, 3]);
----

Этот срез имеет тип `&[i32]`. Он работает так же, как и строковые срезы, сохраняя в стеке указатель на первый элемент и свою длину (количество элементов в срезе). В обобщенном виде тип среза аннотируется как `&[T]`. Этот тип будет использоваться во многих других коллекциях. Мы подробно обсудим все это, когда будем говорить о векторах в Главе 8.
