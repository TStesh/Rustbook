[#_4_1_ownership]
=== 4.1. Что такое владение?

_Владение_ — это набор правил, определяющих, как программа на Rust управляет памятью. Все программы должны следить за использованием памяти компьютера во время работы. В некоторых языках этим занимаются сборщики мусора, которые регулярно ищут неиспользуемую память во время работы программы; в других языках сам программист должен явно выделять и освобождать память. В Rust используется третий подход: память управляется через систему владения с набором правил, которые проверяет компилятор. Если выявлено нарушение какого-либо из правил, программа скомпилирована не будет. Владение в никаком своем аспекте не замедляет работу вашей программы.

Поскольку владение является новой концепцией для многих программистов, требуется некоторое время, чтобы привыкнуть к ней. Хорошая новость заключается в том, что чем более опытными вы становитесь в Rust и правилах системы владения, тем легче вам будет естественным образом разрабатывать безопасный и эффективный код. Поэтому не пожалейте времени и сил на усвоение концепции владения.

Когда вы поймете, что такое владение, появится прочная основа для понимания особенностей, которые делают Rust уникальным. В этой главе мы будем изучать владение на примерах работы с очень распространенной структурой данных: строкой (string).

.Стек и куча
****
Во многих языках программирования нет необходимости часто думать о стеке (stack) и куче (heap). Но в языке системного программирования, таком как Rust, место хранения значения — стек или куча — влияет на поведение языка и на то, почему вам приходится принимать те или иные решения. Связь владения со стеком и кучей будет описана позже в этой главе, сейчас дадим краткое объяснение в качестве введения в тему.

И стек, и куча — это части памяти, доступные вашему коду для использования во время выполнения, но они структурированы по-разному. Стек более организован: значения сохраняются в порядке их получения и удаляются в обратном порядке. Это поведение называется «_последний пришел, первый вышел_» (_last input, first output = LIFO_). Представьте стопку тарелок: когда вы добавляете тарелки, то кладете их сверху стопки, а когда вам нужна тарелка, вы берете одну сверху. Добавление или удаление тарелок посередине или снизу работать не будет! Добавление данных в стек называется _помещением в стек_, а удаление данных из стека называется _извлечением из стека_. Все данные, хранящиеся в стеке, должны иметь известный фиксированный размер. Данные с неизвестным размером во время компиляции или размером, который может измениться, должны храниться в куче.

Куча менее организована: когда вы помещаете данные в кучу, то запрашиваете определенное количество места. Распределитель памяти находит достаточно большое пустое место в куче, помечает его как используемое и возвращает _указатель_, являющийся адресом этого места. Этот процесс называется _выделением в куче_ и иногда сокращенно просто _выделением_ (помещение значений в стек не считается выделением). Поскольку указатель на кучу имеет известный фиксированный размер, вы можете хранить указатель в стеке, но когда вам нужны фактические данные, вы должны следовать за указателем. Представьте себя в ресторане. Когда вы входите, то называете количество человек в вашей группе, и персонал находит подходящий свободный стол, и ведет вас туда. Если кто-то из вашей группы опаздывает, он может спросить, где вы сидите, чтобы найти вас.

Помещение в стек происходит быстрее, чем выделение в куче, потому что распределителю никогда не приходится искать место для хранения новых данных; это место всегда находится наверху стека. Для сравнения, выделение пространства в куче требует больше работы, потому что распределитель должен сначала найти достаточно большое пространство для хранения данных, а затем выполнить некоторую учетную работу, чтобы подготовиться к следующему выделению.

Доступ к данным в куче медленнее, чем доступ к данным в стеке, потому что вам нужно следовать указателю, чтобы добраться туда. Современные процессоры работают быстрее, если они меньше "прыгают" в памяти. Продолжая аналогию, рассмотрим официанта в ресторане, принимающего заказы со многих столов. Наиболее эффективно получить все заказы за одним столом, прежде чем переходить к следующему столу. Получение заказа от А, затем заказа от В, затем снова от А, а затем снова от В было бы гораздо более медленным процессом. Точно так же процессор может выполнять свою работу лучше, если он работает с данными, которые находятся близко к другим данным (как в стеке), а не дальше (как это может быть в куче).

Когда ваш код вызывает функцию, значения, переданные в функцию (включая потенциально указатели на данные в куче), и локальные переменные функции помещаются в стек. Когда функция завершается, эти значения извлекаются из стека.

Отслеживание того, какие части кода используют какие данные в куче, минимизация количества дублирующихся данных и очистка неиспользуемых данных в куче, чтобы не исчерпать пространство, — все это проблемы, которые решает владение. Как только вы поймете, что такое владение, вам не нужно будет слишком часто думать о стеке и куче, но знание того, что основная цель владения — управление данными кучи, может помочь объяснить, почему оно работает именно так.
****

==== Правила владения

В первую очередь давайте посмотрим на сами правила владения. Помните об этих правилах при работе с примерами, которые их иллюстрируют:

[IMPORTANT]
====
* У каждого значения в Rust есть _владелец_.
* В каждый момент времени владелец может быть только один.
* Когда владелец выходит за пределы области действия, значение удаляется из памяти.
====

==== Область действия переменной

Теперь, после прохождения базового синтаксиса Rust, мы не будем приводить в примерах весь код целиком от начального `fn main() {` до финальной фигурной скобки `}`; вы в состоянии делать это самостоятельно, добавляя при необходимости все нижеследующие примеры в функцию `main` вручную. В результате наши примеры будут более лаконичными, что позволит нам сосредоточиться на реальных деталях, а не стандартном коде.

В качестве первого примера владения рассмотрим _область действия_ (_scope_) некоторых переменных. Область действия — это диапазон внутри программы, в котором элемент (item) является действительным (valid). Рассмотрим следующую переменную:

[source,rust]
----
    let s = "hello";
----

Переменная `s` относится к строковому литералу, значение которого жестко задано (hardcoded) в тексте нашей программы. Переменная действительна с момента ее объявления до конца текущей области. В листинге 4-1 показана программа с пояснениями по тексту кода, указывающими, где допустима переменная `s`.

--
.Листинг 4-1. Переменная и область действия, в которой она действительна

[source,rust]
----
    {                       // s здесь не действительна, так как еще не объявлена
        let s = "hello";    // s является действительной с этого момента и далее

    // делаем что-то с s
    }                       // область действия закончилась,
                            // и s больше недействительна
----
--

Укажем на два важных момента:

* Когда переменная `s` появляется в области действия, то становится действительной.
* Переменная `s` остается действительной до тех пор, пока не выйдет из области действия.

Пока связь между областью действия и действительностью переменных ничем не отличается от того, как это реализовано в других языках программирования. Для дальнейших шагов в изучении темы владения введем тип `String`.

[#_4_1_string_type]
==== Тип String

Чтобы проиллюстрировать правила владения, нам нужен более сложный тип данных по сравнению с типами, рассмотренными в xref:_3_2_data_types[разделе «Типы данных»] Главы 3. Эти типы имеют известный размер, могут помещаться в стек и извлекаться из стека, когда их область действия заканчивается, а также быстро копируются в случае повторного использования в другом месте кода. Теперь же нам нужны данные, которые хранятся в куче, чтобы разобраться в том, как Rust понимает, когда нужно удалить эти данные из кучи; тип `String` — отличный пример для этого.

Сконцентрируемся на тех аспектах `String`, которые связаны с владением. То, что мы узнаем, будет применимо и к другим сложным типам данных, независимо от того, предоставлены они стандартной библиотекой или созданы вами. Мы обсудим `String` более подробно в Главе 8.

Нам уже встречались строковые литералы, значение которых жестко задается в программе. Строковые литералы удобны, но они подходят не для каждой ситуации, в которой мы можем захотеть использовать текст. Первая причина заключается в том, что они неизменяемы. Во-вторых, не каждое строковое значение может быть заранее известно, когда мы разрабатываем наш код: например, что, если требуется принять и сохранить пользовательский ввод? Для таких ситуаций в Rust есть другой строковый тип — `String`. Этот тип управляет данными, размещенными для него в куче, и поэтому может хранить строку с неизвестным размером во время компиляции. Можно создать `String` из строкового литерала, используя функцию `from`, например:

[source,rust]
----
    let s = String::from("hello");
----

Оператор `::` позволяет использовать пространство имен типа для вызова ассоциированной с ним функции `from` вместо того, чтобы определять отдельную функцию с похожим именем `string_from`. Мы обсудим этот синтаксис более подробно в разделе <<_5_3_method_syntax,«Синтаксис метода»>> Главы 5 и когда будем говорить о пространствах имен модулей в <<_7_3_paths,разделе «Пути для ссылки на элемент в дереве модулей»>> в Главе 7.

Экземпляры `String` _могут быть_ изменяемыми:

[source,rust]
----
    let mut s = String::from("hello");

    s.push_str(", world!"); // push_str() добавляет литерал в экземпляр String

    println!("{s}"); // Будет напечатано `hello, world!`
----

Почему экземпляры `String` могут быть изменяемыми, а литералы нет? В чем разница? А разница в том, как эти два типа работают с памятью.

==== Память и распределение

В случае строкового литерала его содержимое известно во время компиляции, поэтому оно размещается непосредственно внутри исполняемого файла. Вот почему строковые литералы работают быстро и эффективно. Но эти свойства обусловлены только неизменяемостью строкового литерала. К сожалению, мы не можем поместить в исполняемый файл блоки памяти для каждого фрагмента текста, размер которого неизвестен во время компиляции и может меняться во время работы программы.

Для поддержки изменяемости `String` требуется выделить некоторый неизвестный во время компиляции объем памяти в куче для хранения строкового значения экземпляра `String`. Это означает:

* Память должна быть запрошена у распределителя памяти во время выполнения.
* Нам нужен способ вернуть эту память в распределитель, когда экземпляр `String` больше не нужен.

Первый пункт выполняется при вызове `String::from`, его реализация запрашивает необходимую память. Так происходит во многих языках программирования и Rust здесь ничем не выделяется.

С вторым пунктом все гораздо сложнее. В языках со _сборщиком мусора_ (_Garbage Collector = GC_) сборщик отслеживает и очищает память, которая больше не используется, и нам не нужно об этом думать. В языках без GC на разработчика ложится обязанность определить, когда память больше не используется, и вызвать код для ее явного освобождения, точно так же, как он явно запрашивает выделение этой памяти. Правильно это делать исторически было сложной проблемой программирования. Если мы забудем освободить память, то потратим (waste) ее. Если сделаем это слишком рано, у нас будет недействительная (invalid) переменная. Если сделаем это дважды, это тоже будет ошибкой. Нам нужно соединить ровно одно выделение (allocate) ровно с одним освобождением (free).

Rust идет другим путем: выделенная для переменной память автоматически возвращается, как только переменная выходит из области действия. Вот версия примера из листинга 4-1, в которой вместо строкового литерала используется переменная типа `String`; в комментариях указана ее область действия:

[source,rust]
----
    {
        let s = String::from("hello");  // s является действительной, начиная
                                        // с этого момента и далее

        // делаем что-то с s
    }                                   // эта область действия закончилась,
                                        // s больше не является действительной
----

Существует естественный момент, когда мы можем вернуть распределителю память, выделенную для нашего `String`: когда `s` выходит за пределы области действия. Когда переменная выходит за пределы области действия, Rust вызывает специальную функцию, которая называется `drop`. Ее код определяет действия, которые необходимо выполнить при выходе переменной из области действия, а также для возврата выделенной памяти распределителю. Rust автоматически вставляет вызов функции `drop` рядом с закрывающей фигурной скобкой.

[sidebar]
В C++ шаблон освобождения ресурсов в конце жизненного цикла элемента иногда называется _получением ресурсов при инициализации_ (_Resource Acquisition Is Initialization = RAII_). Если вы использовали RAII, функция `drop` в Rust не будет для вас чем-то новым.

Этот шаблон оказывает глубокое влияние на дизайн кода Rust. Сейчас это может показаться простым, но поведение кода может быть неожиданным в более сложных ситуациях, когда нужно, чтобы несколько переменных использовали данные, которые мы разместили в куче. Давайте рассмотрим некоторые из таких ситуаций.

[#_4_1_ownership_moving]
==== Способы взаимодействия переменных и данных: перемещение

Несколько переменных могут по-разному взаимодействовать с одними и теми же данными в Rust. Давайте рассмотрим пример использования целого числа в листинге 4-2.

--
.Листинг 4-2: Присвоение целочисленного значения переменной x переменной y

[source,rust]
----
    let x = 5;
    let y = x;
----
--

С большой вероятностью мы можем догадаться, что делает этот код: «привязать значение `5` к `x`; затем сделать копию значения `x` и привязать его к `y`». Теперь у нас есть две переменные, `x` и `y`, и обе равны `5`. Это действительно то, что происходит на самом деле, потому что целые числа — это скалярные значения с известным фиксированным размером, и эти два значения `5` помещаются в стек.

Теперь давайте посмотрим на версию `String`:

[source,rust]
----
    let s1 = String::from("hello");
    let s2 = s1;
----

Код выглядит очень похоже, поэтому мы можем предположить, что способ работы будет таким же: вторая строка сделает копию значения в `s1` и привяжет его к `s2`. Но в данном случае предположение неверно: на самом деле код ведет совершенно иначе.

Взгляните на рисунок 4-1, чтобы увидеть, что происходит со `String` под капотом. `String` состоит из трех частей, показанных слева: указатель на память, в которой хранится содержимое строки, длина (length) и емкость (capacity). Эта группа данных хранится в стеке. Справа — память в куче, в которой хранится содержимое `String`.

image::trpl04-01.svg[caption="Рисунок 4-1: ", title="Представление в памяти строки, содержащей значение «hello», привязанное к s1", pdfwidth=90%]

Длина — это объем памяти в байтах, который в текущий момент использует содержимое `String`. Емкость — это общий объем памяти в байтах, который `String` получил от распределителя. Разница между длиной и емкостью имеет значение, но не в данном контексте, поэтому пока емкость можно игнорировать.

Когда мы присваиваем `s1` переменной `s2`, происходит копирование группы данных `String` (данные "слева"), то есть указателя, длины и емкости, которые находятся в стеке. Но копирования данных в куче, на которые указывает указатель (данные "справа"), не происходит. Другими словами, представление данных в памяти выглядит так, как показано на рисунке 4-2.

image::trpl04-02.svg[caption="Рисунок 4-2: ", title="Представление в памяти переменной s2, имеющей копию указателя, длины и емкости s1", pdfwidth=60%]

Представление _не похоже_ на рис. 4-3, на котором показано как выглядит память в случае копирования данных кучи. Если бы Rust делал такое копирование по умолчанию, то в случае больших данных операция `s2 = s1` заняла бы большое время во время выполнения и оказала влияние на производительности программы.

image::trpl04-03.svg[caption="Рисунок 4-3: ", title="Другой вариант того, что делает s2 = s1 в случае копирования данных в куче", pdfwidth=60%]

Ранее мы говорили, что когда переменная выходит за пределы области действия, Rust автоматически вызывает функцию `drop` и очищает динамическую память, выделенную для этой переменной. Но на рисунке 4-2 оба указателя данных ссылаются на одно и то же место. Это проблема: когда `s2` и `s1` выходят из области действия, они обе будут пытаться освободить одну и ту же память. Такая ситуация известна как ошибка _двойного освобождения_ (_double free_ error) и является одной из ошибок безопасности памяти, о которых мы упоминали ранее. Двойное освобождение памяти может привести к ее повреждению (corruption), и потенциально может повлечь уязвимости в ее системе безопасности.

Чтобы обеспечить безопасность памяти, после строки `let s2 = s1` Rust считает переменную `s1` более недействительной (invalid). Следовательно, Rust не нужно ничего освобождать, когда `s1` выходит из области действия. Посмотрим, что произойдет при попытке использовать `s1` после создания `s2`; этот код не скомпилируется:

[source,rust]
----
    let s1 = String::from("hello");
    let s2 = s1;

    println!("{s1}, world!");
----

Так как Rust не позволяет использовать недействительную переменную, будет выведено сообщение об ошибке:

[example]
----
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --> src/main.rs:5:28
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`,
  |            which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!("{s1}, world!");
  |                ^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl`
    (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` due to previous error
----

Если из опыта работы с другими языками вам знакомы термины _поверхностная (shallow) копия_ и _глубокая (deep) копия_, то концепция копирования указателя, длины и емкости без копирования данных, вероятно, звучит как создание поверхностной копии. Но так как Rust при этом делает недействительной первую переменную, такое поведение называется не поверхностной копией, а _перемещением_ (_move_). Тогда можно сказать, что в приведенном примере переменная `s1` _перемещена_ в `s2`. Что происходит на самом деле, показано на рисунке 4-4.

image::trpl04-04.svg[caption="Рисунок 4-4: ", title="Представление в памяти после того, как s1 была объявлена недействительной", pdfwidth=60%]

Такое поведение решает нашу проблему! Если действительной является только переменная `s2`, то когда она выйдет за пределы области действия, будет только одно освобождение памяти, и все хорошо.

Кроме того, отсюда следует выбор дизайна: Rust никогда не будет автоматически создавать «глубокие» копии ваших данных. Следовательно, любое _автоматическое_ копирование происходит только в стеке и его можно считать недорогим с точки зрения производительности во время выполнения (_Примечание переводчика: справедливости ради стоит отметить, что и автоматическое копирование данных, размещенных в стеке, может оказаться плохим решением, например, в случае больших массивов из сотен тысяч вещественных чисел_ `f64`).

[#_4_1_ownership_cloning]
==== Способы взаимодействия переменных и данных: клонирование

Для глубокого копирования содержимого `String` в куче, а не только данных стека применяется общий метод, называемый `clone`. Синтаксис методов обсуждается в xref:_5_3_method_syntax[Главе 5], но, с большой вероятностью вы встречались с ними раньше, поскольку методы широко используются во многих языках программирования.

Вот пример метода `clone` в действии:

[source,rust]
----
    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {s1}, s2 = {s2}");
----

Этот код отлично работает, его поведение показано на рисунке 4-3, где реально копируются данные в куче.

Подчеркнем еще раз — выполнение метода `clone` может быть весьма дорогостоящей операцией, поэтому его наличие в коде является визуальным индикатором "чего-то нехорошего" (it’s a visual indicator that something different is going on). По мнению опытных разработчиков Rust признаком хорошего кода является отсутствие вызовов метода `clone` для значений, хранящихся в куче (_Примечание переводчика: см. предыдущее примечание_).

[#_4_1_ownership_coping]
==== Данные только в стеке: копирование

В свете сказанного посмотрим еще раз на работающий код из листинга 4-2:

[source,rust]
----
    let x = 5;
    let y = x;

    println!("x = {x}, y = {y}");
----

Этот код, кажется, противоречит тому, что мы только что узнали: у нас нет вызова `clone`, но переменная `x` все еще является действительной в момент ее вывода на печать, ее перемещения в `y` не произошло.

Причина в том, что такие типы, как целые числа, размер которых известен во время компиляции, полностью хранятся в стеке, поэтому копии их фактических значений создаются очень быстро. Это означает, что после создания переменной `y` нет никаких причин делать переменную `x` недействительной. Другими словами, здесь нет разницы между глубоким и поверхностным копированием, поэтому вызов `clone` ничем не отличается от обычного поверхностного копирования, и мы можем его опустить.

В Rust есть специальная аннотация, называемая трейтом `Copy`, которую можно указывать для типов со значениями в стеке аналогично целым числам (подробнее о трейтах мы поговорим в Главе 10). Если тип реализует трейт `Copy`, переменные, которые его используют, не перемещаются, а копируются, так что после присвоения другой переменной они остаются действительными.

Rust не позволит аннотировать тип посредством `Copy`, если он или любая из его частей реализуют трейт `Drop`. Если указать аннотацию `Copy` для типа, у которого выполняются какие-то действия при выходе за пределы области действия, то будет получена ошибка на этапе компиляции. Чтобы узнать, как добавить аннотацию `Copy` к вашему типу для реализации этого трейта, см. раздел «Производные трейты» в Приложении C.

Итак, какие типы реализуют трейт `Copy`? При необходимости всегда можно свериться с документацией, но, как правило, любая группа простых скалярных значений может реализовать `Copy`, а всякий тип, значение которое требует прямого или косвенного выделения памяти в куче, не может реализовать `Copy`. Вот некоторые из типов, которые реализуют `Copy`:

* Все целочисленные типы, такие как `u32`.
* Логический тип, `bool`, со значениями `true` и `false`.
* Все типы с плавающей запятой, такие как `f64`.
* Тип символа, `char`.
* Кортежи, если они содержат только типы, которые также реализуют `Copy`. Например, (`i32`, `i32`) реализует копирование, а (`i32`, `String`) — нет.

==== Владение и функции

Передача значения в функцию ничем не отличается от присваивания значения переменной. Передача переменной в функцию приведет к ее перемещению или копированию, как и операция присваивания. В листинге 4-3 есть пример с комментариями, детально поясняющими, что происходит с переменными в их областях действия.

--
.Листинг 4-3. Функции с аннотированными владельцами и областью действия

Файл: src/main.rs

[source,rust]
----
fn main() {
    let s = String::from("hello");  // s появляется в области действия

    takes_ownership(s);             // Значение s перемещается в функцию...
                                    // ... и с этого момента s перестает быть действительной
                                    // в этой области

    let x = 5;                      // x появляется в области действия

    makes_copy(x);                  // Значение x было бы перемещено в функцию,
                                    // но i32 это тип с Copy, так что все еще можно
                                    // использовать x и далее в этой области

}   // Так как переменные размещены в стеке, здесь, сначала x выходит из области действия, потом s.
    // Но так значение s перемещено, ничего конкретного с s не происходит.

fn takes_ownership(some_string: String) { // some_string появляется в области действия
    println!("{some_string}");
}   // Здесь some_string выходит из области действия и вызывается `drop`.
    // Зарезервированная память освобождается.

fn makes_copy(some_integer: i32) { // some_integer появляется в области действия
    println!("{some_integer}");
}   // Здесь some_integer выходит из области действия. Ничего не происходит.
----
--

Если бы мы попытались использовать `s` после вызова `take_ownership`, Rust выдал бы ошибку времени компиляции. Такие статические проверки защищают нас от ошибок. Попробуйте добавить в `main` код, который использует `s` и `x`, чтобы увидеть, где можно их использовать, а где правила владения не позволяют этого сделать.

==== Возвращаемые значения и область действия

Возвращаемые значения также могут передавать владение. В листинге 4-4 показан пример функции, возвращающей некоторое значение, с такими же аннотациями, как в листинге 4-3.

--
.Листинг 4-4: Передача владения возвращаемыми значениями

Файл: src/main.rs

[source,rust]
----
fn main() {
    let s1 = gives_ownership();         // gives_ownership перемещает возвращенное значение в s1

    let s2 = String::from("hello");     // s2 появляется в области действия

    let s3 = takes_and_gives_back(s2);  // s2 перемещается в takes_and_gives_back,
                                        // которая также перемещает возвращенное значение в s3
}   // Здесь, s3 выходит из области действия и удаляется.
    // s2 была перемещена, с ней ничего не происходит.
    // s1 выходит из области действия и удаляется.

fn gives_ownership() -> String {        // gives_ownership будет перемещать возвращаемое значение
                                        // в функцию, которая ее вызвала

    let some_string = String::from("yours"); // some_string появляется в области действия

    some_string                         // some_string возвращается из функции и перемещается
                                        // в функцию, которая вызвала текущую функцию
}

// Эта функция принимает String и возвращает String
fn takes_and_gives_back(a_string: String) -> String { // a_string появляется в области действия

    a_string    // a_string возвращается из функции и перемещается в функцию, которая вызвала
                // текущую функцию
}
----
--

Владение переменной каждый раз следует одной и той же схеме: присвоение значения другой переменной перемещает ее. Когда переменная, содержащая данные в куче, выходит за пределы области действия, значение очищается путем удаления из кучи при условии, что владение на данные не было передано другой переменной.

В случае нескольких параметров функции реализовать передачу с возвратом технически несложно. Rust позволяет возвращать несколько значений с помощью кортежа, как показано в листинге 4-5.

--
.Листинг 4-5: Возврат владения параметрами функции

Файл: src/main.rs

[source,rust]
----
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{s2}' is {len}.");
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len() возвращает длину String

    (s, length)
}
----
--

Хотя описанный способ и работает, но сама по себе необходимость получения и последующего возврата владения в каждой функции загромождает код формальными выражениями. Очень неудобно, что при передаче значений требуется обратный возврат некоторых из них для повторного использования. По факту получаем слишком много церемоний и рутинной работы для концепции, которая лежит в основе всего языка. Возникает закономерный вопрос: возможно ли, чтобы функция использовала значение, но не становилась владельцем?

К счастью для нас, такая возможность в Rust есть — так называемые ссылки, которые позволяют оперировать значениями без передачи владения.
