[#_2_3_comparing]
=== 2.3. Сравнение числа игрока с секретным числом

Теперь, когда у нас есть пользовательский ввод и случайное число, мы можем их сравнить. Этот шаг показан в листинге 2-4. Обратите внимание, что этот код не будет компилироваться по причинам, которые, разумеется, будут объяснены.

--
.Листинг 2-4: Обработка возможных результатов сравнения двух чисел

Файл: src/main.rs

[source,rust]
----
use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --snip--

    println!("You guessed: {guess}");

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => println!("You win!"),
    }
}
----
--

Сначала мы добавляем в область действия тип `std::cmp::Ordering` из стандартной библиотеки. Тип `Ordering` — еще одно перечисление, имеющее варианты `Less`, `Greater` и `Equal`. Это три результата, которые возможны при сравнении двух значений.

Затем мы добавляем пять новых строк внизу, которые используют тип `Ordering`. Метод `cmp` сравнивает два значения и может вызываться для всего, что можно сравнить. Методу требуется ссылка на сравниваемое значение: в нашем коде сравнивается `guess` с `secret_number`. Метод возвращает вариант перечисления `Ordering`. Чтобы понять, что делать дальше в зависимости от возвращенного варианта, мы используем выражение `match`.

Выражение `match` состоит из _веток_ (_arms_). Ветка состоит из _образца_ (_pattern_) для сопоставления и кода, который нужно запустить, если значение, заданное для `match`, соответствует образцу этой ветки. Rust берет значение, указанное для `match`, и по очереди просматривает образец в каждой ветке. Образцы и `match` являются мощными конструкциями Rust, позволяющими эффективно справляться с множеством различных ситуаций в нашем коде. Подробно они будут рассмотрены в xref:_chapter_6[Главе 6] и Главе 18.

Давайте рассмотрим как работает наше выражение `match` на конкретном примере. Пусть сгенерировано случайное число 38. Пользователь вводит число 50. Когда код сравнивает 50 с 38, метод `cmp` вернет `Ordering::Greater`, поскольку 50 больше, чем 38. Выражение `match` получает значение `Ordering::Greater` и начинает последовательно проверять образцы в каждой ветке. В первой ветке `Ordering::Less` не совпадает с `Ordering::Greater`, код этой ветки игнорируется и сопоставление переходит к следующей ветке. Образец в следующей ветке — `Ordering::Greater` — соответствует искомому `Ordering::Greater`! Выполнится связанный код в этой ветке, и на экран будет выведен текст `Too big!`. Выражение `match` заканчивается после первого успешного совпадения, поэтому в этом примере последняя ветка рассматриваться не будет.

Однако код в листинге 2.4 не компилируется:

[example]
----
$ cargo build
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_core v0.6.2
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.3
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --> src/main.rs:22:21
   |
22 |     match guess.cmp(&secret_number) {
   |                     ^^^^^^^^^^^^^^ expected struct `String`, found integer
   |
   = note: expected reference `&String`
              found reference `&{integer}`

error[E0283]: type annotations needed for `{integer}`
   --> src/main.rs:8:44
    |
8   |     let secret_number = rand::thread_rng().gen_range(1..=100);
    |         -------------                      ^^^^^^^^^ cannot infer type for type `{integer}`
    |         |
    |         consider giving `secret_number` a type
    |
    = note: multiple `impl`s satisfying `{integer}: SampleUniform` found in the `rand` crate:
            - impl SampleUniform for i128;
            - impl SampleUniform for i16;
            - impl SampleUniform for i32;
            - impl SampleUniform for i64;
            and 8 more
note: required by a bound in `gen_range`
   --> /Users/carolnichols/.cargo/registry/src/github.com-1ecc6299db9ec823/rand-0.8.3/src/rng.rs:
       129:12
    |
129 |         T: SampleUniform,
    |            ^^^^^^^^^^^^^ required by this bound in `gen_range`
help: consider specifying the type arguments in the function call
    |
8   |     let secret_number = rand::thread_rng().gen_range::<T, R>(1..=100);
    |                                                     ++++++++

Some errors have detailed explanations: E0283, E0308.
For more information about an error, try `rustc --explain E0283`.
error: could not compile `guessing_game` due to 2 previous errors
----

Суть ошибки заключается в том, что коде есть _несоответствующие типы_. Rust построен на сильной статической системе типов, но для упрощения ее использования реализован механизм их автоматического вывода. Когда Rust видит строку `let mut guess = String::new()`, то делает вывод, что переменная `guess` должна иметь тип `String`, и не обязывает нас писать тип этой переменной явно. С другой стороны, переменная `secret_number` является числовым типом. Если числовой тип явно не задан, то Rust по умолчанию считает, что это тип `i32`, который в нашем случае и будет типом `secret_number`. Заметим, что если где-то в коде `secret_number` окажется связанной с переменной другого числового типа, то Rust выведет для `secret_number` тип этой переменной.

Чтобы код компилировался, нам нужно преобразовать значение типа `String`, которое мы получаем из буфера ввода, в значение числового типа, для последующего его сравнения с секретным числом. Для этого используется метод `parse`. Добавим преобразование в код:

Файл: src/main.rs

[source,rust]
----
    // --snip--

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    let guess: u32 = guess.trim().parse().expect("Please type a number!");

    println!("You guessed: {guess}");

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => println!("You win!"),
    }
----

[#_2_3_shdowing_example]
Рассмотрим строку

[source,rust]
----
    let guess: u32 = guess.trim().parse().expect("Please type a number!");
----

В этой строке создается переменная с именем `guess`. Но подождите-ка, разве в программе уже нет переменной с именем `guest`? Так и есть, но Rust разрешает нам _затенить_ (_shadowing_) предыдущее значение `guess` новым. Затенение позволяет повторно использовать имя переменной `guess` вместо того, чтобы создавать две уникальные переменные, например, `guess_str` и `guess`. Мы рассмотрим этот механизм более подробно в xref:_3_1_2_shadowing[Главе 3], пока же заметим, что он часто используется, когда нужно преобразовать значение из одного типа в другой.

Мы привязываем к новой переменной выражение `guess.trim().parse()`. Выражение начинается с исходной переменной `guess`, которая содержит введенную пользователем строку. Метод `trim` позволяет "обрезать" все пробелы в начале и в конце этой строки; кроме этого, удаляются символы новой строки (`\n` в ОС Linux и MacOS, и `\n\r` в ОС Windows), которые функция `read_line` добавляет в конец строки после нажатия пользователем на клавишу kbd:[Enter]. Например, если пользователь вводит 5 и нажимает клавишу kbd:[Enter], значение `guess` выглядит как `5\n` (в ОС Windows `5\r\n`). Метод `trim` исключает `\n` или `\r\n` из введенного строчного значения, в результате чего получается просто `5`. Применение `trim` для строковых значений является обязательным для их корректного преобразования в число.

Метод `parse` (детальное описание метода см. по адресу _https://doc.rust-lang.org/std/primitive.str.html#method.parse_) преобразует строковое значение в другой тип. Мы используем этот метод для его преобразования в число. Для этого требуется сообщить Rust нужный нам тип числа с помощью команды `let guess: u32`. Двоеточие после `guess` говорит Rust, что это аннотация типа переменной. В Rust есть несколько встроенных числовых типов; `u32` представляет собой 32-битное беззнаковое целое число. Это хороший выбор для небольшого положительного числа; в xref:_3_2_1_scalar_types[Главе 3] мы поговорим и о других числовых типах. Кроме того, с учетом аннотации `u32` сравнение с `secret_number` заставит Rust вывести тип переменной `secret_number` как `u32`. Итак, теперь сравнение будет выполняться между двумя значениями одного и того же типа!

Метод `parse` будет работать только с теми символами, которые логически могут быть преобразованы в числа, и это становится источником множества ошибок. Если бы, например, `String` содержал `A👍%`, то преобразовать его в число было бы невозможно. Поскольку такого рода ошибки более чем вероятны, метод `parse` возвращает тип `Result`, как это делает метод `read_line` (рассмотренный ранее в разделе «Обработка возможных сбоев с помощью типа Result»). Для обработки этого результата мы также используем метод `expect`. Если `parse` возвращает значение `Result` в варианте `Err` из-за ошибки создания числа из строки, тогда `expect` аварийно завершит программу и выведет переданное ему в аргументе сообщение. Если же `parse` успешно преобразует строку в число, то вернет значение `Result` в варианте `Ok`, а `expect`, в свою очередь, вернет результирующее число, содержащееся в `Ok`.

Давайте запустим программу:

[example]
----
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
----

Отлично! Несмотря на то, что перед числом были добавлены пробелы, метод `trim` отрезает эти пробелы и позволяет получить число 76 из пользовательского ввода. Запустите программу несколько раз, чтобы проверить различное поведение при различных вариантах ввода:

* при вводе правильного числа;
* при вводе числа, которое меньше секретного числа;
* при вводе числа, которое больше секретного числа.

Сейчас у нас работает большая часть игры, но пользователь может сделать только одно предположение. Давайте изменим это, добавив цикл!
