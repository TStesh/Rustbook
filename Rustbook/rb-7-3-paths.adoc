[#_7_3_paths]
=== 7.3. Пути для указания на элементы в дереве модулей

Чтобы показать Rust, где найти элемент в дереве модулей, мы используем путь так же, как для навигации по файловой системе. Чтобы вызвать функцию, нам нужно знать путь к ней.

Путь может принимать две формы:

* _Абсолютный путь_ — это полный путь, начинающийся от корня крейта; в случае внешнего крейта абсолютный путь начинается с имени крейта, а для текущего крейта - с литерала `crate`.
* _Относительный путь_ — начинается с текущего модуля и использует `self`, `super` или идентификатор в текущем модуле.

За абсолютным и относительным путями следует один или несколько идентификаторов, разделенных двойным двоеточием (`::`).

Вернемся к листингу 7-1 и предположим, что хотим вызвать функцию `add_to_waitlist`. Чтобы ее вызвать, нам нужно знать путь к функции. Для дальнейшего перепишем листинг 7-1, удалив в нем некоторые модули и функции, так, как показано на листинге 7-3.

Мы покажем два способа вызова функции `add_to_waitlist` из новой функции `eat_at_restaurant`, определенной в корне крейта. Хотя пути в коде указано верно, но остается еще одна проблема, из-за которой этот пример не может быть скомпилирован как есть; пояснения будут даны чуть позже.

Функция `eat_at_restaurant` является частью открытого API нашего библиотечного крейта, поэтому помечена ключевым словом `pub`. Мы более подробно рассмотрим его в разделе «Отображение путей с помощью ключевого слова pub».

--
.Листинг 7-3: Вызов функции add_to_waitlist с использованием абсолютного и относительного путей

Файл: src/lib.rs

[source,rust]
----
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Абсолютный путь
    crate::front_of_house::hosting::add_to_waitlist();

    // Относительный путь
    front_of_house::hosting::add_to_waitlist();
}
----
--

В первом вызове функции `add_to_waitlist` из функции `eat_at_restaurant` используется абсолютный путь. Функция `add_to_waitlist` определена в том же крейте, что и функция `eat_at_restaurant`, это означает, что можно применить ключевое слово `crate` в начале абсолютного пути. Затем указывается последовательность модулей, ведущая из корня дерева модулей крейта до `add_to_waitlist`. Можно представить себе файловую систему с такой же структурой: мы указываем путь _/front_of_house/hosting/add_to_waitlist_ для запуска программы `add_to_waitlist`; ключевое слово `crate` аналогично использованию _/_ для указания на корень файловой системы.

Во втором вызове применяется относительный путь. Путь начинается с названия модуля `front_of_house`, определенного на том же уровне дерева модулей, что и функция `eat_at_restaurant`. В данном случае эквивалентным путем в файловой системе будет _front_of_house/hosting/add_to_waitlist_. Указание имени модуля в начале пути означает, что путь является относительным.

Решение разработчика использовать относительные или абсолютные пути зависит от того, будет ли перемещаться код с определением элемента вместе с кодом, использующим этот элемент или независимо от последнего. Например, если модуль `front_of_house` и функция `eat_at_restaurant` перемещаются в модуль `customer_experience`, то абсолютный путь до функции `add_to_waitlist` изменится, но относительный путь к ней останется тем же. Однако, если функцию `eat_at_restaurant` отдельно переместить в модуль с именем `Dining`, то наоборот, абсолютный путь к функции `add_to_waitlist` останется прежним, а относительный путь нужно будет обновить. Обычно [.underline]#мы предпочитаем абсолютные пути относительным#, так как с большой вероятностью код с определением элементов и код с вызовом элементов будут перемещаться независимо друг от друга.

Давайте попробуем скомпилировать код из листинга 7-3 и выясним, почему он не компилируется! Полученная ошибка показана в листинге 7-4.

--
.Листинг 7-4: Ошибки компиляции кода в листинге 7-3

[example]
----
$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `hosting` is private
 --> src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^ private module
  |
note: the module `hosting` is defined here
 --> src/lib.rs:2:5
  |
2 |     mod hosting {
  |     ^^^^^^^^^^^

error[E0603]: module `hosting` is private
  --> src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^ private module
   |
note: the module `hosting` is defined here
  --> src/lib.rs:2:5
   |
2  |     mod hosting {
   |     ^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` due to 2 previous errors
----
--

В сообщениях об ошибках говорится, что модуль `hosting` является закрытым. Другими словами, у нас указаны правильные пути к модулю `hosting` и функции `add_to_waitlist`, но Rust не дает нам их использовать, потому что у него нет доступа к закрытым секциям. В Rust все элементы (функции, методы, структуры, перечисления, модули и константы) по умолчанию являются закрытыми для родительских модулей. Если требуется закрыть доступ к элементу, например функции или структуре, его нужно разместить в модуле.

Элементы в родительском модуле не могут использовать закрытые элементы дочерних модулей, но элементы в дочерних модулях могут использовать любые элементы модулей-предков. Это связано с тем, что дочерние модули оборачивают и скрывают детали своей реализации, но могут видеть контекст, в котором определены. Продолжая метафору ресторана, можно провести аналогию между правилами конфиденциальности и бэк-хаусом: то, что там происходит, является закрытым для посетителей ресторана, но менеджеры могут видеть и делать в ресторане, которым они управляют, все, что считают нужным.

Разработчики Rust приняли решение, что в модульной системе внутренние детали реализации являются закрытыми по умолчанию. Таким образом, есть полная определенность, какие части внутреннего кода можно изменять, не ломая работу внешнего кода. Rust предоставляет возможность открывать внутренние части кода дочерних модулей для внешних модулей-предков посредством ключевого слова `pub`, разрешая таким образом использовать их элементы во внешнем коде.

==== Экспозиция путей с помощью ключевого слова pub

Вернемся к ошибке в листинге 7-4, которая сообщает, что модуль хостинга является закрытым. Так как нам нужно, чтобы функция `eat_at_restaurant` в родительском модуле имела доступ к функции `add_to_waitlist` в дочернем модуле, то помечаем модуль `hosting` ключевым словом `pub`, как показано в листинге 7-5.

--
.Листинг 7-5: Объявление модуля hosting как pub для использования его из eat_at_restaurant

Файл: src/lib.rs

[source,rust]
----
mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
----
--

К сожалению, код в листинге 7-5 по-прежнему приводит к ошибке, как показано в листинге 7-6.

--
.Листинг 7-6: Ошибки компиляции кода в листинге 7-5

[example]
----
$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `add_to_waitlist` is private
 --> src/lib.rs:9:37
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                                     ^^^^^^^^^^^^^^^ private function
  |
note: the function `add_to_waitlist` is defined here
 --> src/lib.rs:3:9
  |
3 |         fn add_to_waitlist() {}
  |         ^^^^^^^^^^^^^^^^^^^^

error[E0603]: function `add_to_waitlist` is private
  --> src/lib.rs:12:30
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^ private function
   |
note: the function `add_to_waitlist` is defined here
  --> src/lib.rs:3:9
   |
3  |         fn add_to_waitlist() {}
   |         ^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` due to 2 previous errors
----
--

Что теперь не так? Добавление ключевого слова `pub` перед `mod hosting` открывает доступ в модуль внешнему коду. Теперь, если мы можем получить доступ к `front_of_house`, то получим и доступ к `hosting`. Но _содержимое_ модуля `hosting` по-прежнему является закрытым; открытие модуля не делает открытым его содержимое! Ключевое слово `pub` в модуле позволяет ссылаться на него в коде модулей-предков, но не на его внутренние элементы. Поскольку модули являются контейнерами, мы мало что можем сделать, просто объявив модуль открытым; нужно пойти дальше и открыть один или несколько элементов в самом модуле.

Ошибки в листинге 7-6 говорят о том, что функция `add_to_waitlist` является закрытой. Правила конфиденциальности применяются к структурам, перечислениям, функциям и методам, а также к модулям.

Давайте также откроем функцию `add_to_waitlist`, добавив ключевое слово `pub` перед ее определением, как в листинге 7-7.

--
.Листинг 7-7: Добавление ключевого слова pub к mod hosting и fn add_to_waitlist позволяет вызывать функцию из eat_at_restaurant

Файл: src/lib.rs

[source,rust]
----
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
----
--

Теперь код успешно компилируется! Чтобы понять, почему добавление ключевого слова `pub` позволяет нам успешно вызывать функцию `add_to_waitlist` с учетом правил конфиденциальности, давайте детально рассмотрим абсолютный и относительный пути к этой функции.

В абсолютном пути мы начинаем с `crate`, корня дерева модулей нашего крейта. Модуль `front_of_house` определен в корне крейта. Хотя `front_of_house` не является открытым, поскольку функция `eat_at_restaurant` определена в том же модуле, что и модуль `front_of_house` (то есть, `eat_at_restaurant` и `front_of_house` являются братьями), мы можем ссылаться на `front_of_house` из `eat_at_restaurant`. Далее идет помеченный как `pub` модуль `hosting`. Так как у нас есть доступ к его родительскому модулю, то нам доступен и сам `hosting`. Наконец, функция `add_to_waitlist` помечена как `pub`, у нас есть доступ к её родительскому модулю, так что в итоге получаем успешный вызов функции!

В относительном пути логика такая же, как и в абсолютном, за исключением первого шага: путь начинается не с корня крейта, а с `front_of_house`. Модуль `front_of_house` определен в том же модуле, что и функция `eat_at_restaurant`, поэтому относительный путь начинается с модуля, в котором определена эта функция. Далее, поскольку `hosting` и `add_to_waitlist` помечены как `pub`, то остальная часть пути и сам вызов функции являются корректными!

Если вы планируете предоставить общий доступ к своему библиотечному крейту, чтобы другие проекты могли использовать ваш код, то [.underline]#открытый API является контрактом с пользователями вашего крейта, определяющим, как они могут взаимодействовать с вашим кодом#. Для обеспечения этого контракта и удобства пользования крейтом требуется специальным образом управлять изменениями нашего открытого API; для этого разработаны разные методики, но их обсуждение выходит за рамки этой книги; если вам интересна эта тема, см. "Руководство Rust API" по ссылке _https://rust-lang.github.io/api-guidelines/_.

[sidebar]
.Лучшие практики для пакетов с исполняемым файлом и библиотекой
****
Мы упоминали, что пакет может содержать как корень бинарного крейта — файл _src/main.rs_, так и корень библиотечного крейта — файл _src/lib.rs_, и оба крейта по умолчанию будут называться тем же именем, что и имя пакета. Как правило, в пакетах, содержащих как библиотеку, так и бинарный крейт, в бинарном крейте достаточно кода, чтобы запустить исполняемый файл, в котором используется код из библиотечного крейта. Благодаря этому и тому, что код библиотеки можно использовать совместно, другие проекты получают больше пользы (benefit) от применения функциональности, предоставляемой пакетом.

Дерево модулей должно быть определено в _src/lib.rs_. В бинарном крейте можно использовать любые открытые элементы, начиная пути для доступа к этим элементам с имени пакета. Таким образом бинарный крейт становится пользователем библиотечного крейта точно так же, как его использует полностью внешний крейт: ему доступен только открытый API. Это помогает проектировать хороший API; ведь теперь вы не только автор, но и клиент!

В Главе 12 мы продемонстрируем такую организацию кода на практике, разработав утилиту командной строки, которая будет содержать как бинарный, так и библиотечный крейты.
****

==== Применение ключевого слова super в начале относительных путей

Мы можем задавать относительные пути, которые начинаются не с текущего модуля или корня крейта, а с родительского модуля — для этого в начале пути указываем ключевое слово `super`. Это похоже на синтаксис `..`  в начале путей файловой системы, который обозначает родительский каталог. Ключевое слово `super` позволяет ссылаться на элемент, который находится в родительском модуле, что при наличии тесной связи модуля с его родителем может упростить переупорядочение дерева модулей в случае перемещения родительского модуля в другое место дерева.

Рассмотрим код в листинге 7.8 с моделированием ситуации, в которой шеф-повар исправляет неверный заказ и лично приносит его посетителю. Функция `fix_incorrect_order`, определенная в модуле `back_of_house`, вызывает определенную в родительском модуле функцию `delivery_order` с указанием пути к этой функции, начинающегося с `super`:

--
.Листинг 7-8: Вызов функции с использованием относительного пути, начинающегося с super

Файл: src/lib.rs

[source,rust]
----
fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}
----
--

Функция `fix_incorrect_order` находится в модуле `back_of_house`, поэтому можно использовать `super` для перехода к родителю модуля `back_of_house`, которым в данном случае является `crate`, корень крейта. Оттуда начинается поиск функции `delivery_order` и, разумеется, она успешно находится. Мы полагаем, что модуль `back_of_house` и функция `delivery_order`, скорее всего, останутся в той же взаимосвязи друг с другом и в случае реорганизации дерева модулей крейта будут перемещаться вместе. Поэтому используем `super`, чтобы в будущем было как можно меньше точек изменения кода, если будет принято решение о его перемещении в другой модуль.

==== Открытие доступа к структурам и перечислениям

Ключевое слово `pub` можно использовать и для открытия доступа к структурам и перечислениям, но есть несколько нюансов, о которых следует сказать. Если мы применяем `pub` перед определением структуры, то делаем ее доступной извне, но поля структуры по-прежнему остаются закрытыми (так же как в случае модулей). Можно открыть доступ к тем ли иным полям в зависимости от конкретной ситуации. В листинге 7-9 мы определили открытую структуру `back_of_house::Breakfast` с открытым полем `toast`, но с закрытым полем `season_fruit`. Такая организация структуры моделирует ситуацию в ресторане, когда посетитель может выбрать тип хлеба, который подается с едой, но состав фруктовой корзины определяет шеф-повар, исходя из сезонности и того, что есть в наличии. Так как состав доступных фруктов быстро меняется, клиенты не могут их произвольно выбирать или даже посмотреть, что есть в наличии.

--
.Листинг 7-9: Структура с открытыми и закрытыми полями

Файл: src/lib.rs

[source,rust]
----
mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &str) -> Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaches"),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Заказ летнего завтрака с гренками из ржаного хлеба
    let mut meal = back_of_house::Breakfast::summer("Rye");
    // Передумали и поменяли тип хлеба на пшеничный
    meal.toast = String::from("Wheat");
    println!("I'd like {} toast please", meal.toast);

    // Следующая строка не будет компилироваться, если ее раскомментировать;
    // у нас нет доступа к полю seasonal fruit экземпляра meal структуры Breakfast
    // meal.seasonal_fruit = String::from("blueberries");
}
----
--

Поскольку поле `toast` в структуре `back_of_house::Breakfast` является открытым, в функции `eat_at_restaurant` можно записывать значения в это поле и читать из него, используя точечную нотацию. Обратите внимание, что мы не можем использовать поле `season_fruit` в функции, потому что поле является закрытым. Попробуйте раскомментировать строку, в которой изменяется значение `season_fruit` и посмотрите, какую ошибку выдаст компилятор!

Также обратите внимание, что, поскольку в структуре `back_of_house::Breakfast` есть закрытое поле, то требуется наличие открытой ассоциированной функции для создания экземпляра `Breakfast` (в нашем случае это `summer`). Если бы у `Breakfast` не было такой функции, мы не смогли бы создать экземпляр `Breakfast` в функции `eat_at_restaurant` из-за невозможности установить значение закрытого поля `season_fruit`.

В случае перечисления ситуация обратная: [.underline]#если мы открываем доступ к перечислению, то все его варианты становятся открытыми#. Таким образом, для открытия перечисления со всем своим внутренним содержанием достаточно просто указать `pub` перед ключевым словом `enum`, как показано в листинге 7-10.

--
.Листинг 7-10: Обозначение перечисления как открытого делает все его варианты открытыми

Файл: src/lib.rs

[source,rust]
----
mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}
----
--

Поскольку мы открыли доступ к перечислению `Appetizer`, то можем использовать варианты `Soup` и `Salad` в функции `eat_at_restaurant`.

Почему так сделано? Открытые перечисления не очень полезны, если их варианты не являются открытыми (попробуйте написать работающий `match` хотя бы с одним закрытым вариантом), а постоянно маркировать их ключевым словом `pub` было бы шаблонным кодом; поэтому в дизайне Rust принято решение все варианты открытого перечисления считать по умолчанию открытыми. Структуры часто более полезны, если их поля не являются открытыми, поэтому они следуют общему правилу: все поля по умолчанию являются закрытыми, если только они не аннотированы ключевым словом `pub`.

Осталась еще одна не рассмотренная ситуация, связанная с `pub`: речь идет о ключевом слове модульной системы `use`. Сначала мы обсудим `use` отдельно, а затем покажем, как комбинировать `pub` и `use`.
