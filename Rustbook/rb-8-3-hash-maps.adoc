[#_8_3_hash_maps]
=== 8.3. Хранение ключей со связанными значениями в HashMap

Последняя из наших общих коллекций — это _хэшированное отображение_ (_hash map_). Тип `HashMap<K, V>` хранит сопоставление ключей типа `K` со значениями типа `V` с помощью _хэш-функции_, которая определяет, как эти ключи и значения помещаются в память. Многие языки программирования поддерживают такую структуру данных, но часто используют другие имена, такие как хэш (hash), отображение (map), объект (object), хеш-таблица (hash table), словарь (dictionary) или ассоциативный массив (associative array), и это лишь некоторые из них.

Хэшированные отображения полезны, когда вы хотите искать данные не с помощью индекса, как это можно сделать с векторами, а с помощью ключа, который может быть любого типа. Например, в игре вы можете отслеживать счет каждой команды в виде хэшированного отображения, в которой каждый ключ — это название команды, а значения — счет каждой команды. Зная название команды, вы можете получить ее счет.

В этом разделе мы рассмотрим базовый API хэшированных отображений, но в функциях, определенных для `HashMap<K, V>` стандартной библиотекой, скрывается гораздо больше полезного. Как всегда, дополнительную информацию можно найти в документации стандартной библиотеки.

==== Создание нового HashMap

Один из способов создать пустое хэшированное отображение — использовать `new`, а потом добавлять в него элементы с помощью `insert`. В листинге 8-20 мы отслеживаем очки двух команд — Синей и Желтой. Синяя команда начинает с 10 очков, Желтая — с 50.

.Листинг 8-20: Создание нового HashMap и вставка нескольких ключей и значений
[source,rust]
----
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);
----

Обратите внимание, что нам нужно сначала портировать `HashMap` из части коллекций стандартной библиотеки с помощью инструкции `use`. Из трех наших общих коллекций `HashMap` используется реже всего, поэтому не включена в прелюдию. Также коллекции `HashMap` меньше поддерживаются стандартной библиотекой; например, нет встроенного макроса для их создания.

Как и векторы, хэшированные отображения хранят свои данные в куче. В нашем примере `HashMap` имеет ключи типа `String` и значения типа `i32`. Как и векторы, хэшированные отображения однородны: все ключи должны иметь один и тот же тип, и все значения должны иметь один и тот же тип.

==== Доступ к значениям в HashMap

Мы можем получить значение из `HashMap`, предоставив ключ этого значения методу `get`, как показано в листинге 8-21.

.Листинг 8-21: Доступ к счету Синей команды, хранящемуся в HashMap
[source,rust]
----
    let team_name = String::from("Blue");
    let score = scores.get(&team_name).copied().unwrap_or(0);
----

В этом коде `score` будет иметь значение, связанное с Синей командой, то есть 10. Метод `get` возвращает `Option<&V>`; если в `HashMap` нет значения для этого ключа, `get` вернет `None`. Программа обрабатывает `Option`, вызывая метод `copied` для получения `Option<i32>`, а не `Option<&i32>`, а затем метод `unwrap_or`, чтобы установить нулевое значение `score`, если в `scores` нет записи для ключа.

Мы можем перебирать каждую пару ключ/значение в `HashMap` так же, как это делали в векторах, используя цикл `for`:

[source,rust]
----
    for (key, value) in &scores {
        println!("{}: {}", key, value);
    }
----

Этот код будет печатать каждую пару в произвольном порядке:

[example]
----
Yellow: 50
Blue: 10
----

==== HashMap и владение

Для типов, реализующих трейт `Copy`, таких как `i32`, значения копируются в `HashMap`. Для значений с владением, таких как `String`, значения будут перемещаться, и `HashMap` будет становиться их владельцем, как показано в листинге 8-22.

.Листинг 8-22: Ключи и значения принадлежат HashMap после их вставки
[source,rust]
----
    use std::collections::HashMap;

    let field_name = String::from("Favorite color");
    let field_value = String::from("Blue");

    let mut map = HashMap::new();
    map.insert(field_name, field_value);
    // field_name и field_value в этой точке недействительны,
    // попробуйте их использовать и посмотрите какую ошибку
    // комплятора получите!
----

Мы не можем использовать переменные `field_name` и `field_value` после того, как они были перемещены в `map` вызовом метода `insert`.

Если мы вставим в `HashMap` ссылки на значения, сами значения туда перемещены не будут. Значения, на которые указывают ссылки, должны быть действительными, по крайней мере, до тех пор, пока действителен сам `HashMap`. Подробнее об этих проблемах мы поговорим в разделе «Проверка ссылок с временем жизни» в Главе 10.

==== Изменение HashMap

Хотя количество пар ключ/значение может увеличиваться, каждый уникальный ключ может иметь в любой момент времени только одно связанное с ним значение (но не наоборот: например, и Синяя команда, и Желтая команда могут иметь одинаковое значение 10, хранящееся в `scores`).

Когда нужно изменить данные в `HashMap`, возникает вопрос - что делать в случае, когда ключу уже присвоено значение. Вот возможные сценарии: заменить старое значение новым значением, полностью игнорируя старое значение; оставить старое значение и проигнорировать новое значение, добавляя его только в том случае, если у ключа еще нет значения; наконец, объединить старое значение и новое значение. Давайте посмотрим, как реализовать каждый из них!

===== Перезапись значения

Если мы вставим ключ и значение в `HashMap`, а затем вставим тот же ключ с другим значением, значение, связанное с этим ключом, будет заменено. Несмотря на то, что в коде листинга 8-23 дважды вызывается метод `insert`, `scores` будет содержать только одну пару ключ/значение, потому что мы оба раза вставляем значение для ключа Синей команды.

.Листинг 8-23: Замена значения, сохраненного с определенным ключом
[source,rust]
----
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Blue"), 25);

    println!("{:?}", scores);
----

Этот код выведет `+{"Blue": 25}+`. Исходное значение 10 было перезаписано.

===== Добавление ключа и значения, только если ключ отсутствует

Обычно перед вставкой значения разработчик добавляет в код проверку наличия заданного ключа в `HashMap`. Далее могут выполняться любые действия в зависимости от задачи, решаемой разработчиком, здесь мы рассмотрим следующий вариант: если проверка показала, что ключ в `HashMap` существует, то связанное с ним значение остается неизменным, как есть; если ключ не существует, выполняется обычная вставка в `HashMap` новой пары ключ / значение.

У `HashMap` есть специальный метод `entry`; в качестве параметра этот метод принимает ключ, который вы хотите проверить. Метод возвращает перечисление с именем `Entry`, представляющее значение, которое может существовать, а может и не существовать. Допустим, мы хотим проверить, связано ли с ключом Желтой команды какое-либо значение. Если это не так, то добавляем в `scores` значение 50 и то же самое для Синей команды. При использовании метода `entry` код выглядит так, как показано в листинге 8-24.

.Листинг 8-24: Использование метода entry для вставки только в том случае, если ключ еще не имеет значения
[source,rust]
----
    use std::collections::HashMap;

    let mut scores = HashMap::new();
    scores.insert(String::from("Blue"), 10);

    scores.entry(String::from("Yellow")).or_insert(50);
    scores.entry(String::from("Blue")).or_insert(50);

    println!("{:?}", scores);
----

Метод `or_insert` для `Entry` работает следующим образом: если ключ существует, то возвращает из `Entry` изменяемую ссылку на значение для этого ключа, а если нет — вставляет аргумент в качестве нового значения ключа и возвращает изменяемую ссылку на новое значение. Этот метод намного чище, чем самостоятельно написанная логика, и, кроме того, лучше взаимодействует с системой проверки заимствования.

При запуске код из листинга 8-24 выведет `+{"Желтый": 50, "Синий": 10}+`. Первый вызов `entry` вставит ключ для Желтой команды со значением 50, потому что у этой команды еще нет значения. Второй вызов `entry` не изменит `scores`, потому что Синяя команда уже имеет значение 10.

===== Изменение текущего значения для ключа в HashMap

Другой распространенный вариант использования `HashMap` — это поиск значения по ключу, а затем изменение найденного значения. Например, в листинге 8-25 показан код, который подсчитывает, сколько раз каждое слово встречается в некотором тексте. Мы используем `HashMap` со словами в качестве ключей и увеличиваем значение для слова на 1 всякий раз, когда встречаем это слово в тексте. Начальным значением для слова, которое еще не встречалось, будет 0.

.Листинг 8-25: Подсчет вхождений слов с использованием HashMap, которая хранит слова и счетчики
[source,rust]
----
    use std::collections::HashMap;

    let text = "hello world wonderful world";

    let mut map = HashMap::new();

    for word in text.split_whitespace() {
        let count = map.entry(word).or_insert(0);
        *count += 1;
    }

    println!("{:?}", map);
----

При запуске этот код выведет `+{"world": 2, "hello": 1, "wonderful": 1}+`. Вывод пар ключ/значение выполняется в порядке, отличном от расположения слов-ключей в `text`: выше в разделе «Доступ к значениям в HashMap» мы отмечали, что итерация по `HashMap` происходит в произвольном порядке.

Метод `split_whitespace` разбивает строковый литерал `text` на части, разделенные пробелами (это будут наши слова) и возвращает их в виде итератора, который перебирает их в цикле `for`. Метод `or_insert` возвращает изменяемую ссылку (`&mut V`) на значение для указанного ключа. Здесь мы сохраняем эту изменяемую ссылку в переменной `count`, так что для изменения значения нужно сначала разыменовать `count`, используя звездочку (`*`). Изменяемая ссылка выходит из области действия в конце цикла `for`, поэтому все эти изменения безопасны и разрешены правилами заимствования.

==== Функции хэширования

По умолчанию `HashMap` использует функцию хэширования _SipHash_, которая посредством использования хэш-таблиц может обеспечить защиту от атак типа «отказ в обслуживании» (DoS) (подробности см. по ссылке _https://en.wikipedia.org/wiki/SipHash_). Это не самый быстрый алгоритм хеширования из имеющихся, но компромисс в пользу лучшей безопасности, хотя и приводящий к падению производительности, того стоит. Если вы профилируете свой код и обнаружите, что эта хеш-функция является слишком медленной для ваших целей, то можете переключиться на другую функцию, указав другой хэшер. _Хэшер_ (_hasher_) — это тип, реализующий трейт `BuildHasher` (о трейтах и о том, как их реализовать, мы поговорим в Главе 10). Вам необязательно создавать собственный хэшер с нуля; на портале _https://crates.io_ можно найти соответствующие библиотеки с реализацией многих распространенных алгоритмов хеширования.
