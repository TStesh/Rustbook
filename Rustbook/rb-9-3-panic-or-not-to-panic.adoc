[#_9_3_panic_or_not_panic]
=== 9.3. Паниковать или не паниковать?

_Примечание переводчика: оригинальный заголовок "To panic! or Not to panic!" отсылает нас к знаменитой фразе "To be or not to be" из шекспировской драмы "Гамлет". Тем самым авторы недвусмысленно намекают на некоторую экзистенциальность обозначенной в заголовке темы, в которой нет и может быть единственно правильных ответов, и все рассуждения в ней будут носить оценочный или рекомендательный характер; каждый разработчик должен исходить исключительно из своего опыта и личных убеждений в верности принимаемых решений_

Итак, как решить при реализации функции, когда вам следует вызвать `panic!`, а когда — вернуть `Result`? Когда код паникует, восстановить его невозможно. Вы можете вызвать `panic!` в любой ошибочной ситуации, независимо от того, есть ли возможность восстановления или нет, но это именно вы принимаете решение о том, что ситуация неустранима, а не вызывающий код. В случае вашего решения возвращать значения Result, эта опция остается за вызывающим кодом. Вызывающий код может выбрать попытку восстановления способом, подходящим для его ситуации, или, на основании типа ошибки в варианте `Err` может решить, что восстанавливаться не нужно и лучше вызвать `panic!`, превратив исправимую ошибку в неисправимую. Таким образом, когда вы определяете функцию, которая может завершиться ошибкой, возврат `Result` является хорошим выбором по умолчанию.

Когда вы разрабатываете функции для примеров, программы прототипов или тесты, более уместно писать код, который вызывает панику, а не возвращает `Result`. Давайте разберемся, почему, а затем обсудим ситуации, в которых компилятор не может сказать, что сбой невозможен, но вы, как человек, можете. Глава завершится некоторыми общими рекомендациями о принятии решения, стоит ли паниковать в библиотечном коде.

==== Примеры, прототипы и тесты

Когда вы пишете пример для иллюстрации какой-то концепции, включение надежного кода обработки ошибок может сделать пример менее понятным. В примерах подразумевается, что вызов метода с потенциальной паникой внутри, такого как `unwrap`, заменяет реализацию более сложного поведения с обработкой различных ошибок, потому что в примерах эта сложность ни к чему.

Точно так же методы `unwrap` и `expect` очень удобны при прототипировании, когда еще нет полной готовности к обработке ошибок, потому что в целом перспективы прототипируемого кода неясны и тратить время и ресурсы на дополнительную обработку ошибок по меньшей мере неразумно. С другой стороны, упомянутые методы, как "хлебные крошки", оставляют в вашем коде четкие отметки (clear markers), к которым вы вернетесь позже, когда появится потребность улучшить надежность программы.

Если в тесте вызов метода завершается ошибкой, очевидно, совершенно правильным является требование непрохождения всего теста, даже если сам этот метод не относится к тестируемой функциональности. Поэтому, чтобы тест помечался как неудачный, мы должны использовать `panic!` в любой ситуации, и тут без вызовов `unwrap` или `expect` не обойтись.

==== Ситуации, в которых у вас больше информации, чем у компилятора

Еще одной ситуацией, в которой было бы уместно вызывать `unwrap` или `expect`, является реализация логика, относительно которой вы абсолютно уверены, что `Result` всегда будет иметь значение `Ok`, но со стороны компилятора требуется формально обеспечить полноту обработки всех вариантов `Result`. Если в вашем коде применяется операция, которая может закончиться неудачей, и стало быть, возвращает `Result`, обойти обработку `Result` не получится. С другой стороны, после ручной проверки кода и подтверждения, что у вас гарантированно никогда не будет варианта `Err`, вполне приемлемо для обработки `Result` вызвать `unwrap`, а еще лучше - `expect`, в текстовом аргументе которого указать причину принятия решения, что у вас никогда не будет варианта `Err`. Например:

[source,rust]
----
    use std::net::IpAddr;

    let home: IpAddr = "127.0.0.1"
        .parse()
        .expect("Hardcoded IP address should be valid");
----

Мы создаем экземпляр `IpAddr`, разбирая заданный в коде строковый литерал. Нам известно, что `127.0.0.1` является действительным IP-адресом, поэтому здесь допустимо использовать `expect`. Однако наличие такой допустимой строки не меняет тип возвращаемого значения метода `parse`: мы по-прежнему получаем значение `Result`, и компилятор по-прежнему заставляет нас обрабатывать `Result`, как если бы вариант `Err` был возможен; компилятору неизвестно, что указанная строка всегда является допустимым IP-адресом. Если бы строка IP-адреса приходила от пользователя, а не была задана явным образом в программе, и, следовательно, _существовала_ вероятность сбоя при ее разборе, то потребовалась бы более сложная обработка `Result`, чем метод `expect`. Если в будущем нам потребуется вместо IP-адреса, явно заданного в коде, получать IP-адрес из какого-либо другого источника, памятка в виде текста в `expect` позволит написать более совершенный код обработки ошибок.

==== Рекомендации по обработке ошибок

Желательно, чтобы ваш код паниковал, когда возникает его перехода в плохое состояние. В этом контексте _плохое состояние_ — это когда какое-то предположение, гарантия, контракт или инвариант были нарушены, например, когда в ваш код передаются недопустимые значения, противоречивые значения или отсутствующие значения, — а также одно или более из следующего:

* Плохое состояние — это что-то неожиданное, в отличие от того, что может происходить время от времени, например, когда пользователь вводит данные в неправильном формате.
* Ваш код после этого момента все равно считает, что не находится в плохом состоянии, какие-либо проверки наличия проблемы отсутствуют на каждом этапе.
* Нет хорошего способа выявить проблему на основе информации в типах, которые вы используете. Мы рассмотрим пример того, что мы имеем в виду, в разделе «Кодирование Состояния и Поведение как типов» главы 17.

Если кто-то вызывает ваш код и передает бессмысленные значения, лучше по возможности вернуть ошибку, чтобы пользователь библиотеки мог решить, что ему нужно делать в этой ситуации. Однако в тех случаях, когда продолжение может быть небезопасным или вредным, лучшим выбором может быть вызов `panic!` и предупредите пользователя об ошибке в их коде, чтобы он мог исправить ее во время разработки. Похожим образом, применение `panic!` часто уместно, если вы вызываете внешний код, находящийся вне вашего контроля, и он возвращает недопустимое состояние, которое вы не можете исправить.

Однако, в случае предсказуемого сбоя более уместно вернуть `Result`, чем вызывать `panic!`. В качестве примеров можно привести парсер, получающий искаженные данные, или HTTP-запрос, возвращающий статус, указывающий, на достижение предела скорости. В этих случаях возврат `Result` указывает на то, что сбой является ожидаемой возможностью, и вызывающий код должен решить, как обработать ошибку.

Допустим, ваш код выполняет операцию, которая может подвергнуть пользователя риску. Если эта операция может быть выполнена с использованием недопустимых значений, ваш код до выполнения операции должен проверить значения на корректность и аварийно завершиться, если значения недействительны. В основном это делается из соображений безопасности: попытка работать с неверными данными может выявить уязвимости в вашем коде и использовать их для обхода системы безопасности. Это основная причина, по которой стандартная библиотека вызывает `panic!` в случае попытки получить доступ к памяти за пределами допустимых границ: доступа к памяти, не принадлежащей текущей структуре данных, является распространенной проблемой безопасности. Функции часто следуют _контракту_, что их поведение гарантируется только в том случае, если входные данные удовлетворяют определенным требованиям. Паника при нарушении контракта имеет смысл, потому что это нарушение всегда указывает на ошибку на вызывающей стороне; нам не нужно, чтобы вызывающий код явно ее обрабатывал. На самом деле нет никакого разумного способа восстановить код вызова; задача _разработчиков_ этого кода — его исправить. Контракты для функции, особенно когда нарушение вызовет панику, должны быть объяснены в документации API функции.

В нагромождении большого количества проверок ошибок во всех ваших функциях ничего хорошего нет. К счастью, часть из них можно убрать, полагаясь на систему типов Rust (и, следовательно, проверку типов, выполняемую компилятором), которая может выполнить многие проверки за вас. Если ваша функция имеет определенный тип в качестве параметра, логика кода строится на гарантиях компилятора, что тип имеет допустимое значение. Иными словами, если есть тип, а не `Option`, ваша программа ожидает получить _что-то_, а не _ничего_. Не требуется обрабатывать два случая для вариантов `Some` и `None`: всегда есть только один случай определенного значения. Код, пытающийся ничего не передать вашей функции, даже не скомпилируется, поэтому на вашей стороне не нужно проверять этот случай во время выполнения. Другой пример — использование целочисленного типа без знака, такого как `u32`, гарантирует, что параметр никогда не будет отрицательным.

==== Создание пользовательских типов для проверки

Давайте рассмотрим идею использования системы типов Rust для гарантии, что у нас всегда действительное значение, как основы для создания собственного типа для проверки. Вспомните игру в угадайку в Главе 2, в которой пользователь должен угадать число от 1 до 100. Мы не проверяли соответствие введенного пользователем числа указанному диапазону, прежде чем сравнить его с нашим секретным числом; задание типа `u32` для метода `parse` было проверкой только на положительность. На правильную работу кода отсутствие проверки на соответствие диапазону никак не влияет. Но что было бы полезным улучшением, так это добавить информирование пользователя о диапазоне допустимых чисел в случае ввода числа, выходящего за пределы диапазона, помимо уже существующей реакции на ситуацию, когда пользователь вместо числа вводит, например, буквы.

Изменим тип вводимого числа с `u32` на `i32`, чтобы разрешить потенциально отрицательные числа, а затем добавить проверку, что число находится в нужном диапазоне, например так:

[source,rust]
----
    loop {
        // --snip--

        let guess: i32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        if guess < 1 || guess > 100 {
            println!("The secret number will be between 1 and 100.");
            continue;
        }

        match guess.cmp(&secret_number) {
            // --snip--
    }
----

Выражение `if` проверяет, не выходит ли наше значение за пределы диапазона, сообщает пользователю о проблеме, и вызывает `continue`, чтобы начать следующую итерацию цикла и запросить новое число. После выражения `if` мы можем продолжить сравнение между `guess` и секретным числом, зная, что `guess` находится в диапазоне от 1 до 100.

Однако это не идеальное решение: в случае критичности требования, чтобы программа работала только со значениями от 1 до 100, и у нее было бы много функций с таким контрактом, добавление в каждую функцию проверки на соответствие этому требованию было бы утомительным занятием (и к тому же потенциально влияющим на производительность).

Вместо этого мы можем создать новый тип и поместить нужные проверки в функцию создания экземпляра типа, вместо того, чтобы тиражировать их повсюду. Таким образом, функции могут безопасно использовать новый тип в своих сигнатурах, а в своем коде — значения нового типа, которые заведомо удовлетворяют всем проверкам. В листинге 9-13 показан один из способов определения типа `Guess`, который будет создавать свой экземпляр только в том случае, если функция `new` получает значение от 1 до 100.

--
.Листинг 9-13: Тип Guess, который будет работать только с числами от 1 до 100.

Файл: src/main.rs

[source,rust]
----
pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {}.", value);
        }

        Guess { value }
    }

    pub fn value(&self) -> i32 {
        self.value
    }
}
----
--

Сначала мы определяем (открытую) структуру с именем `Guess`, которая имеет (закрытое) поле с именем `value`, содержащее `i32`. Здесь будет храниться число, вводимое пользователем.

Затем реализуем ассоциированную с `Guess` функцию с именем `new`, которая создает экземпляры `Guess`. Новая функция определена так, чтобы иметь один параметр с именем `value` типа `i32` и возвращать `Guess`. Код в теле функции проверяет значение `value`, чтобы убедиться, что оно находится в диапазоне от 1 до 100. Если значение не проходит этот тест, мы вызываем `panic!` и сообщаем таким образом программисту, пишущему вызывающий код, что у него есть ошибка, которую нужно исправить; создание `Guess` со значением вне этого диапазона нарушило бы контракт, на котором основывается `Guess::new`. Условия, при которых `Guess::new` может паниковать, следует указывать в общедоступной документации на API нашей программы; мы поговорим об этом более подробно в Главе 14. Если `value` проходит тест, мы создаем и возвращаем новый `Guess` со значением поля `value`, установленным из параметра `value`.

Также у нас реализован метод с именем `value`, который заимствует `self`, не имеет других параметров и возвращает `i32`. <<_5_3_method_syntax,Напомним>>, что такие методы иногда называют _геттерами_, потому что его цель — получить некоторые данные из своих полей и вернуть их. Этот открытый метод необходим, поскольку поле `value` структуры `Guess` является закрытым. Важно, чтобы поле `value` было закрытым, поэтому код, использующий структуру `Guess`, не может устанавливать значение напрямую: код вне модуля _должен_ использовать функцию `Guess::new` для создания экземпляра `Guess`, тем самым гарантируя, что `Guess` не сможет иметь значение `value`, которое не было проверено условиями в `Guess::new`.

Функция, у которой параметр или возвращаемое значение — это число от 1 до 100, теперь может объявить в своей сигнатуре, что принимает или возвращает `Guess`, а не `i32`, и в ее коде не нужно выполнять никакие дополнительные проверки.
