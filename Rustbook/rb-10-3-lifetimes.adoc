[#_10_3_lifetimes]
=== 10.3. Валидация ссылок с помощью времен жизни

Времена жизни — это еще один вид дженерика, который мы уже использовали. Вместо гарантии заданного нами поведения обобщенного типа, время жизни гарантирует, что ссылки будут действительными, пока они нам нужны.

В <<_4_2_dangling_reference,разделе «Ссылки и заимствование»>> Главы 4 мы не сказали о важной детали: каждая ссылка в Rust имеет _время жизни_ (_lifetime_), то есть, область действия, в которой эта ссылка действительна. В большинстве случаев времена жизни неявны и выводятся, как и в большинстве случаев выводятся типы. Мы должны аннотировать тип явно только тогда, когда возможны несколько типов. Аналогичным образом требуется аннотировать время жизни, когда времена жизни ссылок могут быть связаны несколькими различными способами. В выражении таких отношений применяются обобщенные параметры времени жизни для гарантии, что фактические ссылки, используемые во время выполнения, определенно будут действительными.

Аннотации времен жизни нет в большинстве других языков программирования, так что с большой вероятностью эта концепция будет для вас малознакомой. Хотя в этой главе мы не будем рассматривать ее полностью, но обсудим распространенные способы работы с синтаксисом времени жизни, чтобы вы могли освоиться с этой концепцией.

==== Предотвращение висячих ссылок

Основная цель времени жизни — предотвратить _висячие ссылки_, когда программа ссылается на данные, отличные от тех данных, на которые она должна ссылаться. Рассмотрим программу в листинге 10-16, которая имеет внешнюю и внутреннюю области действия.

.Листинг 10-16: Попытка использовать ссылку, значение которой вышло из области действия
[source,rust]
----
fn main() {
    let r;

    {
        let x = 5;
        r = &x;
    }

    println!("r: {}", r);
}
----

[sidebar]
Примечание. Примеры в листингах 10-16, 10-17 и 10-23 объявляют переменные, не присваивая им начальное значение, при этом имя переменной существует во внешней области действия. На первый взгляд может показаться, что это противоречит тому, что в Rust нет значений null. Однако, если мы попытаемся использовать переменную до того, как присвоим ей значение, мы получим ошибку времени компиляции, которая показывает, что Rust действительно не допускает значений null.

Внешняя область объявляет переменную с именем `r` без начального значения, а внутренняя область — переменную с именем `x` с начальным значением 5. Во внутренней области мы пытаемся установить значение `r` как ссылку на `x`. Затем внутренняя область действия заканчивается, и выполняется попытка напечатать значение в `r`. Этот код не компилируется, потому что значение, на которое ссылается `r`, вышло за пределы области действия до того, как его попытались использовать. Вот сообщение об ошибке:

[example]
----
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
 --> src/main.rs:6:13
  |
6 |         r = &x;
  |             ^^ borrowed value does not live long enough
7 |     }
  |     - `x` dropped here while still borrowed
8 |
9 |     println!("r: {}", r);
  |                       - borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` due to previous error
----

Текст ошибки говорит нам, что переменная `x` "живет недостаточно долго". Причина в том, что `x` выйдет за пределы области действия, когда внутренняя область действия закончится на строке 7. Но ссылка `r` по-прежнему действительна для внешней области действия; поскольку ее масштаб больше, мы говорим, что она «живет дольше». Если бы Rust позволил этому коду работать, `r` ссылалась бы на память, которая была освобождена, когда переменная `x` вышла из области действия, и все, что мы пытались бы сделать с `r`, с этого момента работало бы неправильно. Так как же Rust определяет, что этот код нерабочий? Он использует систему проверки заимствования (borrow checker).

==== Система проверки заимствований

В компиляторе Rust реализована система проверки заимствований, которая сравнивает области действия, чтобы определить, все ли заимствования действительны. В листинге 10-17 показан тот же код, что и в листинге 10-16, но с аннотациями времен жизни переменных (в форме комментариев).

.Листинг 10-17: Аннотации времен жизни r и x, названные «a» и «b» соответственно
[source,rust]
----
fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {}", r); //          |
}                         // ---------+
----

Мы обозначили время жизни `r` как `'a`, а время жизни `x` — как `'b`. Как видите, внутренний блок `'b` намного меньше внешнего блока `'a`. Во время компиляции Rust сравнивает размер двух времен жизни и видит, что `r` имеет время жизни `'a`, но ссылается на память со временем жизни `'b`. Программа отклоняется, потому что `'b` короче', чем `'a`: референт не живет так же долго как ссылка на него.

В листинге 10-18 представлен исправленный код, в нем нет висячих ссылок и компиляция проходит без ошибок.

.Листинг 10-18: Действительная ссылка, так как данные имеют более длительное время службы, чем ссылка
[source,rust]
----
fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &x;           // --+-- 'a  |
                          //   |       |
    println!("r: {}", r); //   |       |
                          // --+       |
}                         // ----------+
----

В этом примере `x` имеет время жизни `'b`, которое в данном случае больше, чем `'a`. Это означает, что `r` может ссылаться на `x`, потому что Rust знает, что ссылка в `r` всегда будет действительна, пока `x` действителен.

Теперь, когда вы знаете, где находятся времена жизни ссылок и как Rust анализирует их для гарантии действительности ссылок, давайте рассмотрим обобщенные времена жизни параметров и возвращаемых значений в контексте функций.

==== Обобщенные времена жизни в функциях

Давайте напишем функцию, которая возвращает более длинный из двух строковых срезов; назовем ее `longest`. Функция принимает два таких среза и возвращает один строковый срез. После реализации `longest`, код в листинге 10-19 должен вывести "The longest string is abcd".

--
.Листинг 10-19: функция main, которая вызывает функцию longest для поиска более длинного из двух строковых срезов

Файл: src/main.rs

[source,rust]
----
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}
----
--

Заметим, что функция принимает срезы, которые являются ссылками, а не строками, так как нам не нужно, чтобы функция `longest` становилась владельцем своих параметров. Обратитесь к <<_4_3_slice_as_parameter,разделу «Строковые срезы в качестве параметров»>> Главы 4, чтобы узнать, почему параметры функции в листинге 10-19 именно такие, какие есть (_примечание переводчика: речь о неявном приведении deref, позволяющем работать со ссылками на String как со срезами и наоборот_).

Если написать функцию `longest`, как показано в листинге 10-20, она не скомпилируется.

--
.Листинг 10-20: Реализация функции longest, которая возвращает более длинный из двух срезов, но еще не компилируется

Файл: src/main.rs

[source,rust]
----
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
----
--

При компиляции получаем следующую ошибку, которая говорит о времени жизни:

[example]
----
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --> src/main.rs:9:33
  |
9 | fn longest(x: &str, y: &str) -> &str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature
does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
9 | fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
  |           ++++     ++          ++          ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10` due to previous error
----

В подсказке компилятор пишет, что возвращаемому типу нужно указать обобщенный параметр времени жизни, потому что не может определить, ссылается ли возвращаемая ссылка на `x` или `y`. На самом деле мы тоже этого не знаем, потому что блок `if` в теле функции возвращает ссылку на `x`, а блок `else` возвращает ссылку на `y`!

Когда мы определяем эту функцию, то не знаем конкретных значений, которые будут переданы в функцию, поэтому не знаем, будет ли выполняться случай `if` или `else`. Нам неизвестны времена жизни передаваемых ссылок, поэтому нет возможности посмотреть на их области действия, как это делалось в листингах 10-17 и 10-18 для определения, всегда ли будет действительной возвращаемая нами ссылка. Система проверки заимствований также не знает, как время жизни `x` и `y` соотносится со временем жизни возвращаемого значения. Для исправления ошибки мы добавим обобщенные параметры времени жизни, которые определяют взаимосвязь между ссылками, чтобы система проверки заимствований могла выполнять свой анализ.

==== Синтаксис аннотации времени жизни

Аннотации времени жизни не меняют срок жизни какой-либо из ссылок. Скорее, они описывают взаимные отношения времен жизни нескольких ссылок, не влияя на само время жизни. Точно так же, как функции могут принимать любой тип, если в сигнатуре указан параметр обобщенного типа, они могут принимать ссылки с любым временем жизни, если указан параметр обобщенного времени жизни.

Аннотации времени жизни имеют немного необычный синтаксис: имена параметров времени жизни должны начинаться с апострофа (`+'+`) и обычно в нижнем регистре и очень короткие, как обобщенный типы. Большинство разработчиков используют имя `'a` для первой аннотации времени жизни. Мы размещаем аннотации параметров времени жизни сразу после символа `&` ссылки, используя пробел, чтобы отделить аннотацию от типа ссылки.

Вот несколько примеров: ссылка на `i32` без параметра времени жизни, ссылка на `i32`, у которой есть параметр времени жизни с именем `'a`, и изменяемая ссылка на `i32`, у которой также есть время жизни `'a`.

[source,rust]
----
&i32        // ссылка
&'a i32     // ссылка с явным временем жизни
&'a mut i32 // изменяемая ссылка с явным временем жизни
----

Одна аннотация времени жизни сама по себе не имеет большого значения, потому что аннотации предназначены для того, чтобы сообщить Rust, как обобщенные параметры времени жизни нескольких ссылок связаны друг с другом. Давайте рассмотрим, как аннотации времени жизни соотносятся друг с другом в контексте функции `longest`.

==== Аннотации времени жизни в сигнатурах функций

Чтобы использовать аннотации времени жизни в сигнатурах функций, нам нужно объявить обобщенные параметры _времени жизни_ внутри угловых скобок между именем функции и списком параметров, как мы это делали с параметрами обобщенного _типа_.

Мы хотим, чтобы сигнатура выражала следующее ограничение: возвращаемая ссылка будет действительной до тех пор, пока действительны оба параметра. А это, как легко понять, уже некоторое заданное отношение между временами жизни параметров и возвращаемым значением. Назовем время жизни `'a`, а затем добавим его к каждой ссылке, как показано в листинге 10-21.

--
.Листинг 10-21: Определение функции longest, указывающее, что все ссылки в сигнатуре должны иметь одинаковое время жизни

Файл: src/main.rs

[source,rust]
----
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
----
--

Этот код уже будет успешно компилироваться и возвращать правильный результат в функцию `main` в листинге 10-19.

Сигнатура функции теперь сообщает Rust, что для некоторого времени жизни `'a` функция принимает два параметра, оба из которых являются строковыми срезами, живущими не меньше, чем время жизни `'a`. Сигнатура функции также сообщает Rust, что возвращаемый функцией строковый срез будет существовать как минимум столько, сколько длится время жизни `'a`. На практике это означает, что время жизни ссылки, возвращаемой функцией `longest`, равно меньшему из времен жизни референтов, на которые ссылаются аргументы функции. Мы хотим, чтобы именно эти отношения Rust использовал при анализе нашего кода.

Помните, когда мы указываем параметры времени жизни в этой сигнатуре функции, мы не меняем время жизни каких-либо передаваемых или возвращаемых значений. Скорее, указываем системе проверки заимствования отклонять любые значения, которые не соответствуют этим ограничениям. Обратите внимание, что функции `longest` не нужно точно знать, как долго будут жить `x` и `y`, достаточно только, чтобы некоторая область действия могла быть заменена на `'a` для соответствия этой сигнатуре.

Аннотации времени жизни в функциях помещаются в их сигнатурах, а не в телах и, как и типы параметров, являются частью контракта функции. Наличие сигнатур функций, содержащих контракт с временами жизни, означает, что упрощает анализ кода компилятор Rust. Если есть проблема с тем, как функция аннотируется или как она вызывается, ошибки компилятора могут более точно указать на часть нашего кода, в котором нарушены ограничения. В противном случае компилятору пришлось бы сделать больше заключений о том, какими должны быть отношения времен жизни, и указать на проблемную часть кода намного дальше от места источника ошибки.

Когда мы передаем конкретные ссылки на `longest`, то время жизни этих ссылок, которое заменяется на `'a`, является частью области действия `x`, которая пересекается с областью действия `y`. Другими словами, обобщенное время жизни `'a` получит конкретное время жизни, равное меньшему из значений времен жизни `x` и `y`. Поскольку мы аннотировали возвращаемую ссылку тем же параметром времени жизни `'a`, она будет также действительна в течение меньшего из значений времен жизни `x` и `y`.

Давайте посмотрим, как аннотации времени жизни работают в функции `longest` на ссылках с разными конкретными временами жизни. Листинг 10-22 является простым примером.

--
.Листинг 10-22: Использование функции longest со ссылками на строковые значения, которые имеют разное конкретное время жизни

Файл: src/main.rs

[source,rust]
----
fn main() {
    let string1 = String::from("long string is long");

    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {}", result);
    }
}
----
--

В этом примере переменная `string1` действительна до конца внешней области, переменная `string2` действительна до конца внутренней области, а `result` ссылается на то, что действительно до конца внутренней области. Запустите этот код, и увидите, что система проверки заимствования не находит в нем никаких ошибок и пропускает его; код скомпилируется и напечатает [.st]#"The longest string is long string is long"#.

Теперь попробуем пример, который показывает, что время жизни ссылки в `result` должно быть меньшим временем жизни двух аргументов. Мы переместим объявление результирующей переменной `result` за пределы внутренней области, но оставим присвоение ей значения внутри области действия с помощью `string2`. Также переместим `println!` с `result` во внешнюю область после завершения внутренней. Получившийся код в листинге 10-23 не будет компилироваться.

--
.Листинг 10-23: Попытка использовать result после того, как string2 вышла за пределы области действия

Файл: src/main.rs

[source,rust]
----
fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {}", result);
}
----
--

Ошибка компиляции:

[example]
----
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `string2` does not live long enough
 --> src/main.rs:6:44
  |
6 |         result = longest(string1.as_str(), string2.as_str());
  |                                            ^^^^^^^^^^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!("The longest string is {}", result);
  |                                          ------ borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` due to previous error
----

Чтобы `result` был действительным в инструкции `println!`, переменная `string2` должна быть действительной до конца внешней области. Rust знает об этом, потому что мы аннотировали времена жизни параметров функции и возвращаемых значений, используя один и тот же параметр времени жизни `'a`.

Как люди, мы можем посмотреть на этот код и увидеть, что `string1` длиннее, чем `string2`, и поэтому результат будет содержать ссылку на `string1`. Поскольку переменная `string1` еще не вышла из области действия, ссылка на `string1` по-прежнему будет действительна в инструкции `println!`. Однако компилятор не может увидеть, что в этом случае ссылка действительна. Мы указали Rust, что время жизни ссылки, возвращаемой функцией `longest`, равно меньшему времени жизни переданных ссылок. Поэтому система проверки заимствований запрещает код в листинге 10-23 как возможно имеющий недопустимую ссылку.

Попробуйте поэкспериментировать с разными значениями и временами жизни ссылок, передаваемыми в функцию `longest`, и тем, как используется возвращаемая ссылка. Делайте предположения, как в каждом случае на код будет реагировать система проверки заимствований, и проверяйте их компилятором Rust!

==== Как думать в терминах времен жизни

Способ задания параметров времени жизни, зависит от того, что делает ваша функция. Например, если бы мы изменили реализацию функции `longest`, чтобы она всегда возвращала первый параметр, а не самый длинный строковый срез, нам не нужно было бы указывать время жизни для параметра `y`. Следующий код успешно компилируется:

Файл: src/main.rs

[source,rust]
----
fn longest<'a>(x: &'a str, y: &str) -> &'a str {
    x
}
----

Параметр времени жизни `'a` указан для параметра `x` и возвращаемого типа, но не для параметра `y`, потому что время жизни `y` не имеет никакого отношения к времени жизни `x` или возвращаемому значению.

При возврате ссылки из функции параметр времени жизни возвращаемого типа должен совпадать с параметром времени жизни одного из параметров. Если возвращаемая ссылка не относится ни к одному из параметров, она должна ссылаться на значение, созданное в этой функции. Однако это будет висячая ссылка, потому что значение выйдет за пределы области действия в конце функции. Рассмотрим попытку такой реализации функции `longest`, которая не компилируется:

Файл: src/main.rs

[source,rust]
----
fn longest<'a>(x: &str, y: &str) -> &'a str {
    let result = String::from("really long string");
    result.as_str()
}
----

Здесь, несмотря на то, что мы указали параметр времени жизни `'a` для возвращаемого типа, этот код не компилируется, потому что время жизни возвращаемого значения вообще не связано со временем жизни параметров. Вот какое сообщение об ошибке мы получим:

[example]
----
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return reference to local variable `result`
  --> src/main.rs:11:5
   |
11 |     result.as_str()
   |     ^^^^^^^^^^^^^^^ returns a reference to data owned by the current function

For more information about this error, try `rustc --explain E0515`.
error: could not compile `chapter10` due to previous error
----

Суть ошибки в том, что `result` выходит из области действия и очищается в конце функции `largest`. Мы же пытаемся вернуть ссылку на `result` из функции. Нет никакой возможности указать параметры времени жизни, которые изменили бы висячую ссылку, и Rust не позволит нам ее создать. В этом случае лучшим решением будет возврат значения типа данных с передачей владения, а не ссылки, чтобы вызывающая функция отвечала за очистку этого значения.

В конечном счете, синтаксис времени жизни заключается в соединении времен жизни различных параметров и возвращаемых значений функций. Как только такое соединение произошло, Rust получает достаточно информации для разрешения безопасных операций и запрещения операций, которые могут создать висячие указатели или иным образом нарушить безопасность памяти.

==== Аннотации времени жизни в определениях структур

До сих пор все наши структуры содержали типы с владением. Мы можем определить структуры для хранения ссылок, но в этом случае нужно будет добавить аннотацию времени жизни для каждой ссылки в определении структуры. В листинге 10-24 задана структура с именем `ImportantExcerpt`, которая содержит строковый срез.

--
.Листинг 10-24: Структура со ссылкой, требующая аннотации времени жизни

Файл: src/main.rs

[source,rust]
----
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago..."); <1>
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
----
--
<1> _Примечание переводчика: так начинается роман "Моби Дик" Германа Мелвилла (опубликован в 1851 г.)_

В структуре есть единственное поле `part`, содержащее строковый срез, который является ссылкой. Как и в случае с обобщенными типами данных, мы объявляем имя обобщенного параметра времени жизни в угловых скобках после имени структуры, чтобы можно было использовать этот параметр в теле определения структуры. Эта аннотация означает, что экземпляр `ImportantExcerpt` не может пережить ссылку, которую он содержит в поле `part`.

Функция `main` создает экземпляр структуры `ImportantExcerpt`, которая содержит ссылку на первое предложение из значения `String`, принадлежащего переменной `novel`. Данные в `novel` существуют до создания экземпляра `ImportantExcerpt`. Кроме того, `novel` не выходит за область действия до тех пор, пока не выйдет из этой области экземпляр `ImportantExcerpt`, поэтому ссылка в `ImportantExcerpt` будет действительной.

==== Правила исключения времен жизни

Теперь вы знаете, что у каждой ссылки есть время жизни и что нужно указывать параметры времени жизни для функций или структур, использующих ссылки. Однако в Главе 4 у нас была функция в листинге 4-9, снова показанная в листинге 10-25, которая успешно компилировалась без аннотаций времени жизни.

--
.Листинг 10-25: Функция из листинга 4-9, скомпилированная без аннотаций времени жизни, несмотря на то, что параметр и возвращаемый тип являются ссылками

Файл: src/main.rs

[source,rust]
----
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
----
--

Причина, по которой эта функция компилируется без аннотаций времени жизни, историческая: в ранних версиях Rust (до 1.0) этот код бы не компилировался, так как для каждой ссылки требовалось явное указание времени жизни. Сигнатура функции должна была бы выглядеть так:

[source,rust]
----
fn first_word<'a>(s: &'a str) -> &'a str {
----

По результатам анализа большого количества кода команда Rust обнаружила, что программисты в определенных ситуациях раз за разом вводят одни и те же аннотации времени жизни. Эти ситуации понятны, предсказуемы и вполне укладываются в несколько детерминированных шаблонов. Эти шаблоны были запрограммированы в коде компилятора, чтобы система проверки заимствования могла сама определять время жизни в таких ситуациях и не нуждалась в явных аннотациях.

Эта часть истории Rust актуальна и сейчас, потому что вполне возможно, что появятся и будут добавлены в компилятор другие детерминированные шаблоны. Это позволит в будущем требовать от разработчиков еще меньше аннотаций времени жизни в их коде.

Такие запрограммированные в системе проверки заимствований шаблоны называются _правилами исключения времен жизни_ (_lifetime elision rules_). Эти правила — не для программистов; они описывают набор конкретных ситуаций, которые компилятор будет учитывать при анализе ссылок в вашем коде, и если код соответствует этим ситуациям, то не требовать от вас явного указания в нем времен жизни.

Правила исключения не обеспечивают полного вывода. Если после применения правил все еще остается неясность со временем жизни ссылок, компилятор не будем делать никаких предположений относительно времени жизни остальных ссылок, а просто выдаст вам ошибку, которую вы можете устранить, добавив соответствующие аннотации времени жизни.

Времена жизни для параметров функции или метода называются _входными временами жизни_, а времена жизни для возвращаемых значений называются _выходными временами жизни_.

Компилятор использует три правила для определения времени жизни ссылок при отсутствии явных аннотаций. Первое правило применяется к входным временам жизни, второе и третье — к выходным временам жизни. Если обработаны все три правила и все еще остаются ссылки, для которых компилятор не может вывести время жизни, то он остановится с ошибкой. Правила применяются к определениям `fn`, а также к блокам `impl`.

[.underline]#Первое правило#: компилятор присваивает параметр времени жизни каждому параметру, являющемуся ссылкой. Другими словами, функция с одним параметром получает один параметр времени жизни: f``n foo<'a>(x: &'a i32);`` функция с двумя параметрами получает два отдельных параметра времени жизни: `fn foo<'a, 'b>(x: &'a i32, y: &'b i32);` и так далее.

[.underline]#Второе правило#: если имеется ровно один входной параметр времени жизни, то это время жизни присваивается всем выходным параметрам времени жизни: `fn foo<'a>(x: &'a i32) -> &'a i32`.

[.underline]#Третье правило (для методов)#: если есть несколько входных параметров времени жизни, но один из них — `&self` или `&mut self`, то время жизни `self` назначается всем выходным параметрам времени жизни. Это правило делает методы более удобными для чтения и записи, поскольку требуется меньше символов.

Давайте представим, что мы компилятор. Давайте применим эти правила для определения времени жизни ссылок в сигнатуре функции `first_word` в листинге 10-25. Сигнатура начинается без каких-либо времен жизни, связанных со ссылками:

[source,rust]
----
fn first_word(s: &str) -> &str {
----

Затем компилятор применяет первое правило, которое указывает, что каждый параметр получает свое время жизни. Мы назовем его как обычно `'a`, так что теперь сигнатура выглядит так:

[source,rust]
----
fn first_word<'a>(s: &'a str) -> &str {
----

Второе правило применимо, потому что существует ровно одно входное время жизни. И оно указывает, что время жизни одного входного параметра присваивается выходному времени жизни, поэтому сигнатура теперь получается такой:

[source,rust]
----
fn first_word<'a>(s: &'a str) -> &'a str {
----

Теперь каждая ссылка в этой сигнатуре функции имеет время жизни, и компилятор может продолжить анализ, не требуя от программиста каких-либо аннотаций времен жизни в этой сигнатуре функции.

Давайте посмотрим на другой пример, на этот раз функцию `longest`, у которой не было параметров времени жизни, когда мы начали с ней работать в листинге 10-20:

[source,rust]
----
fn longest(x: &str, y: &str) -> &str {
----

Применим первое правило: каждый параметр получает свое время жизни. На этот раз у нас есть два параметра вместо одного, поэтому у нас есть два времени жизни:

[source,rust]
----
fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {
----

Очевидно, что второе правило не применимо, потому что существует более одного входного времени жизни. Не применимо и третье правило, так как `longest` — это функция, а не метод, ни один из параметров не является `self`. Проработав все три правила, мы так и не выяснили время жизни возвращаемого типа. Поэтому получили ошибку, пытаясь скомпилировать код в листинге 10-20: компилятор применил правила исключения времен жизни, но не смог до конца вычислить все времена жизни ссылок в сигнатуре функции.

Поскольку третье правило действительно применяется только к сигнатурам методов, мы рассмотрим времена жизни в этом контексте, чтобы понять, почему это правило позволяет нам редко аннотировать времена жизни в сигнатурах методов.

==== Аннотации времени жизни в определениях методов

Когда мы реализуем методы для структуры с временем жизни, то используем тот же синтаксис, что и для параметров обобщенного типа, показанных в листинге 10-11. Место объявления и использования параметров времени жизни зависит от того, связаны ли они с полями структуры или параметрами метода и возвращаемыми значениями.

Имена времен жизни для полей структуры всегда нужно объявлять после ключевого слова `impl`, а затем использовать после имени структуры, потому что эти времена жизни являются частью типа структуры.

В сигнатурах методов внутри блока `impl` ссылки могут быть привязаны к временам жизни ссылок в полях структуры или могут быть независимыми. Кроме того, правила исключения времени жизни часто делают так, что аннотации времени жизни не нужны в сигнатурах методов. Давайте рассмотрим несколько примеров использования структуры с именем `ImportantExcerpt`, которую мы определили в листинге 10-24.

Будем использовать метод с именем `level`, единственным параметром которого является ссылка `&self`, а возвращаемым значением — `i32`, который ни на что не ссылается:

[source,rust]
----
impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
}
----

Объявление параметра времени жизни после `impl` и его использование после имени типа являются обязательными, но по первому правилу исключения мы не обязаны аннотировать время жизни `&self`.

Вот пример, где применяется третье правило исключения времени жизни:

[source,rust]
----
impl<'a> ImportantExcerpt<'a> {
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {}", announcement);
        self.part
    }
}
----

Так как есть два входных времени жизни, то Rust применяет первое правило исключения и указывает для `&self` и `announcement` свои собственные времена жизни. Затем, поскольку одним из параметров является `&self`, возвращаемый тип получает его время жизни, и все времена жизни оказываются определенными.

==== Статическое время жизни

Есть особое время жизни, которое нам нужно обсудить — это `'static` и означает оно, что затронутая ссылка _может_ жить в течение всего времени работы программы. Все строковые литералы имеют время жизни `'static`, которое мы можем аннотировать следующим образом:

[source,rust]
----
let s: &'static str = "I have a static lifetime.";
----

Текст этой строки хранится непосредственно в исполняемом файле, который всегда доступен. Поэтому время жизни всех строковых литералов является `'static`.

Иногда вы можете увидеть в сообщениях об ошибках предложение использовать время жизни `'static`. Но прежде чем согласиться на него и указать `'static` в качестве времени жизни для ссылки, подумайте, действительно ли ссылка живет все время жизни вашей программы, и хотите ли вы этого. В большинстве случаев сообщение об ошибке с таким предложением возникает из-за попытки создать висячую ссылку или из-за несоответствия имеющихся времен жизни. В таких случаях решение заключается в устранении этих проблем, а не в ухудшении ситуации с применением времени жизни `'static`.

=== Параметры обобщенного типа, баунды и времена жизни в одном месте

Давайте кратко рассмотрим синтаксис указания параметров обобщенного типа, баундов и времени жизни в одной функции!

[source,rust]
----
use std::fmt::Display;

fn longest_with_an_announcement<'a, T>(
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
where
    T: Display,
{
    println!("Announcement! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
----

Это функция `longest` из листинга 10-21, которая возвращает более длинный из двух строковых срезов. Но теперь у нее есть дополнительный параметр с именем `ann` обобщенного типа `T`, который может быть заполнен любым типом, реализующим трейт `Display`, как указано в предложении `where`. Этот дополнительный параметр будет напечатан с использованием `{}`, поэтому требуется баунд `Display`. Поскольку время жизни является разновидностью обобщенного типа, объявления параметра времени жизни `'a` и параметра обобщенного типа `T` идут в одном списке внутри угловых скобок после имени функции.
