=== 3.2. Функции

Функции преобладают в коде Rust. Вы уже видели одну из самых важных функций языка: функцию `main`, которая является точкой входа во многие программы. Вы также видели ключевое слово `fn`, которое позволяет объявлять новые функции.

В Rust для наименования переменных и функций используется _"змеиный" стиль_ (_snake case_), в котором применяются только строчные буквы, а слова разделяются знаком подчеркивания. Пример определения функции:

Файл: src/main.rs

[source,rust]
----
fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("Another function.");
}
----

Мы определяем функцию в Rust, вводя `fn`, затем имя функции и набор скобок. Фигурные скобки сообщают компилятору, где начинается и заканчивается тело функции.

Мы можем вызвать любую определенную нами функцию, используя ее имя, за которым следует набор скобок. Поскольку в программе определена функция `another_function`, ее можно вызвать из функции `main`. Обратите внимание, что в коде функция `another_function` определена _после_ функции `main`, но никто не мешает определить ее и раньше. В Rust не важно, где вы определяете свои функции, главное, чтобы они были определены где-то в области действия вызывающего кода.

Для дальнейшего изучения функций давайте создадим новый бинарный проект с именем _functions_. Сохраните текст примера в файле `src/main.rs` и запустите его. Вы должны увидеть следующий вывод:

[example]
----
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.28s
     Running `target/debug/functions`
Hello, world!
Another function.
----

Строки выполняются в том порядке, в котором они появляются в функции `main`. Сначала печатается сообщение «Hello, world!», а затем вызывается функция `another_function` и печатается ее сообщение «Another function.».

==== Параметры

Можно определить функцию с _параметрами_, которые представляют собой специальные переменные, являющиеся частью сигнатуры функции. Когда у функции есть параметры, ей можно передавать конкретные значения этих параметров. Технически конкретные значения параметров называются _аргументами_, но обычно слова _параметр_ и _аргумент_ используются взаимозаменяемо как в случае переменных в определении функции, так и для конкретных значений, передаваемых при вызове функции.

В этой версии функции `another_function` мы добавляем ей параметр:

Файл: src/main.rs

[source,rust]
----
fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!("The value of x is: {x}");
}
----

Попробуйте запустить эту программу; вы должны получить следующий вывод:

[example]
----
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 1.21s
     Running `target/debug/functions`
The value of x is: 5
----

Объявление `another_function` имеет один параметр с именем `x`. Тип `x` указан как `i32`. Когда мы передаем `5` в `another_function`, макрос `println!` помещает 5 в строке формата внутри пары фигурных скобок, содержащих `x`.

В сигнатурах функций _необходимо_ объявлять тип каждого параметра. Это осознанное решение в дизайне Rust: требование аннотирования типов в определении функции означает, что компилятору почти никогда не нужно заниматься поиском их использования в коде, чтобы выяснить, какой тип имеется в виду. Компилятор также может выдавать более полезные сообщения об ошибках, если он знает, какие типы ожидает функция.

При определении нескольких параметров разделяйте объявления параметров запятыми, например:

Файл: src/main.rs

[source,rust]
----
fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("The measurement is: {value}{unit_label}");
}
----

В этом примере создается функция с именем `print_labeled_measurement` с двумя параметрами. Первый параметр называется `value` и представляет собой `i32`. Второй параметр называется `unit_label` и имеет тип `char`. Затем функция печатает текст, содержащий как `value`, так и `unit_label`.

Давайте попробуем запустить этот код. Замените текущую программу в файле _src/main.rs_ вашего проекта _functions_ на текст приведенного примера и запустите ее с помощью `cargo run`:

[example]
----
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/functions`
The measurement is: 5h
----

Поскольку мы вызвали функцию со значением `5` для `value` и `h` в качестве значения для `unit_label`, выходные данные программы содержат эти значения.

==== Выражения и инструкции

Тела функций состоят из серии инструкций (statements), которые могут заканчиваться выражением (expression). До сих пор в рассматриваемых нами функциях не было выражений в конце тела функции ("конечных выражений"), но выражение встречалось как часть инструкции. Поскольку Rust — это язык, основанный на выражениях, нужно хорошо усвоить различие между инструкцией и выражением. В большинстве других языков ничего подобного нет, поэтому давайте разберемся, что такое инструкции и выражения и как различие между ними влияет на тела функций.

_Инструкции_ — это действия в коде, не возвращающие никаких значений. _Выражения_ вычисляют и возвращают результирующее значение (иногда говорят, "вычисляются в значение"). Давайте посмотрим на некоторые примеры.

На самом деле мы уже использовали инструкции и выражения. Создание переменной и присвоение ей значения с помощью ключевого слова `let` является инструкцией. В листинге 3-1 `let y = 6;` является инструкцией.

--
.Листинг 3-1: Объявление функции main c одной инструкцией

Файл: src/main.rs

[source,rust]
----
fn main() {
    let y = 6;
}
----
--

Определения функций также являются инструкциями; весь предыдущий пример сам по себе также является инструкцией.

Так как инструкции ничего не возвращают, нельзя присвоить `let` другой переменной, как это пытается сделать следующий код:

Файл: src/main.rs

[source,rust]
----
fn main() {
    let x = (let y = 6);
}
----

При попытке его скомпилировать будет выдано сообщение об ошибке:

[example]
----
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found statement (`let`)
 --> src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^^^^^^^
  |
  = note: variable declaration using `let` is a statement

error[E0658]: `let` expressions in this position are unstable
 --> src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^^^^^^^
  |
  = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667>
   for more information

warning: unnecessary parentheses around assigned value
 --> src/main.rs:2:13
  |
2 |     let x = (let y = 6);
  |             ^         ^
  |
  = note: `#[warn(unused_parens)]` on by default
help: remove these parentheses
  |
2 -     let x = (let y = 6);
2 +     let x = let y = 6;
  |

For more information about this error, try `rustc --explain E0658`.
warning: `functions` (bin "functions") generated 1 warning
error: could not compile `functions` due to 2 previous errors; 1 warning emitted
----

Инструкция `let y = 6` ничего не возвращает, поэтому переменной `x` нечего присвоить. Это отличается от того, что происходит в других языках, таких как C и Ruby, где присваивание возвращает присвоенное значение. В этих языках вы можете написать `x = y = 6`, и оба значения `x` и `y` будут равны 6; в Rust такого нет.

Выражения возвращают значения и составляют большую часть кода, который пишется на Rust. Простейший пример: математическая операция, такая как `5 + 6`, представляет собой выражение с результирующим значением `11`. Выражения могут быть частью инструкций: в листинге 3-1 в инструкции `let y = 6;` выражение — это `6`, результатом которого является значение `6`. Вызов функции — это выражение. Вызов макроса — это выражение. Блок, заданный парой фигурных скобок, и определяющий новую область действия, представляет собой выражение, например:

Файл: src/main.rs

[source,rust]
----
fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {y}");
}
----

Выражение `+{ let x = 3; x + 1 }+` является блоком и вычисляется в значение 4. Это значение привязывается к `y` как часть инструкции `let`. Обратите внимание, что строка `x + 1` не имеет точки с запятой в конце, в отличие от большинства строк, которые вы видели до сих пор. [.underline]#В конце выражения точка с запятой не ставится#. Если поставить точку с запятой в конце выражения, оно станет инструкцией, и ничего возвращать не будет. Имейте это в виду при изучении функций, возвращающих значения.

==== Функции с возвратом значений

Функции могут возвращать значения коду, который их вызывает. У возвращаемых значений нет наименований, но требуется объявить их типы после стрелки (`+->+`). В Rust возвращаемое значение функции является синонимом значения последнего выражения в блоке тела функции. Можно вернуться из любого места функции, используя ключевое слово `return` и указав возвращаемое значение, но большинство функций неявно возвращает значение последнего выражения. Вот пример функции, которая возвращает значение:

Файл: src/main.rs

[source,rust]
----
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {x}");
}
----

В функции `five` нет вызовов функций, макросов и даже инструкций `let` — только цифра `5` сама по себе. Это вполне допустимая функция в Rust. Обратите внимание, что тип возвращаемого значения функции также указывается как `-> i32`. Попробуйте запустить этот код; вывод должен выглядеть так:

[example]
----
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/functions`
The value of x is: 5
----

5 в функции `five` — это возвращаемое значение функции, поэтому тип возвращаемого значения — `i32`. Давайте рассмотрим это более подробно. Есть два важных момента: во-первых, строка `let x = five();` показывает, что мы используем возвращаемое значение функции для инициализации переменной. Поскольку функция `five` возвращает 5, эта строка аналогична следующей:

[source,rust]
----
let x = 5;
----

Во-вторых, функция `five` не имеет параметров и возвращает значение определенного типа, однако тело функции представляет собой просто цифру 5 без точки с запятой, потому что это выражение, значение которого мы хотим вернуть.

Давайте посмотрим другой пример:

Файл: src/main.rs

[source,rust]
----
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {x}");
}

fn plus_one(x: i32) -> i32 {
    x + 1
}
----

Запуск этого кода напечатает "The value of x is: 6". Но если поставить точку с запятой в конце строки, содержащей x + 1, изменив ее с выражения на инструкцию, мы получим ошибку.

Файл: src/main.rs

[source,rust]
----
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {x}");
}

fn plus_one(x: i32) -> i32 {
    x + 1;
}
----

При компиляции этого кода возникает следующая ошибка:

[example]
----
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0308]: mismatched types
 --> src/main.rs:7:24
  |
7 | fn plus_one(x: i32) -> i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
8 |     x + 1;
  |          - help: consider removing this semicolon

For more information about this error, try `rustc --explain E0308`.
error: could not compile `functions` due to previous error
----

Основное сообщение об ошибке — "несоответствие типов" (mismatched types) — раскрывает основную проблему с этим кодом. В определении функции `plus_one` сказано, что она вернет `i32`, но инструкции не возвращают значение, что выражается с помощью `()`, типа `unit`. Так как ничего не возвращается, то это противоречит определению функции и приводит к ошибке. В этом выводе Rust выдает сообщение, которое может помочь исправить эту проблему: предлагает удалить точку с запятой, чтобы устранить ошибку.
