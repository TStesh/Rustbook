[#_9_2_result]
=== 9.2. Исправимые ошибки и Result

Большинство ошибок недостаточно серьезны, чтобы прибегать к полной остановке программы. Иногда функция дает сбой по понятной причине, которую легко интерпретировать и отреагировать на нее. Например, если вы пытаетесь открыть файл, и эта операция не выполнится, потому что этот файл не существует, вы можете например создать его вместо завершения кода.

Вспомним из <<_2_1_handling_potential_failure_with_result,раздела «Обработка потенциального сбоя с помощью типа Result»>> Главы 2, что перечисление `Result` определено с двумя вариантами, `Ok` и `Err`:

[source,rust]
----
enum Result<T, E> {
    Ok(T),
    Err(E),
}
----

`T` и `E` являются параметрами обобщенного типа: мы обсудим их более подробно в Главе 10. В данном случае `T` представляет тип значения, которое будет возвращено в варианте `Ok` в случае успешного выполнения операции, а `E` — тип ошибки, возвращаемый в варианте `Err` в случае сбоя. Применение параметров обобщенного типа позволяет использовать тип `Result` и определенные для него функции во многих ситуациях, когда значение в результате успешного выполнения отличается от возвращаемого значения (или его отсутствия) в случае сбоя.

Давайте вызовем функцию, которая возвращает значение `Result`, потому что ее выполнение может завершиться ошибкой. В листинге 9-3 мы пытаемся открыть файл.

--
.Листинг 9-3: Открытие файла

Файл: src/main.rs

[source,rust]
----
use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");
}
----
--

Функция `File::open` возвращает тип `Result<T, E>`. В случае успешного выполнения функция заполнит параметр `T` значением типа `std::fs::File`, которым является дескриптор файла; в случае ошибки параметр `E` — значением типа `std::io::Error`. Этот тип возвращаемого значения означает, что вызов `File::open` может завершиться успешно и вернуть дескриптор файла, из которого мы можем читать или записывать. Но может завершиться ошибкой: например, файл не существует или отсутствует разрешение на доступ к файлу. У функции `File::open` должна быть возможность сообщать нам об успешном или неудачном выполнении и в то же время предоставлять либо дескриптор файла, либо информацию об ошибке. Именно эту информацию передает перечисление `Result`.

В случае успешного выполнения функции `File::open` значением переменной `greeting_file_result` будет экземпляр варианта `Ok`, содержащий дескриптор файла; в ином случае значением `greeting_file_result` будет экземпляр варианта `Err`, содержащий дополнительную информацию о типе случившейся ошибки.

Нам нужно добавить к коду в листинге 9-3 обработчик вариантов `Result`, чтобы выполнять различные действия в зависимости от возвращаемого значения `File::open`. В листинге 9-4 показан один из способов обработки `Result` с помощью базового инструмента — выражения `match`, которое мы обсуждали в <<_6_2_match,Главе 6>>.

--
.Листинг 9-4: Использование выражения match для обработки возвращаемых вариантов Result

Файл: src/main.rs

[source,rust]
----
use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => panic!("Problem opening the file: {:?}", error),
    };
}
----
--

Заметим, что, как и перечисление `Option`, перечисление `Result` и его варианты включены в прелюдию, поэтому нам не нужно в ветках указывать `Result::` перед вариантами `Ok` и `Err`.

Когда результатом будет `Ok`, этот код вернет из него присоединенное значение `file`, а затем присвоит это значение (дескриптор файла) переменной `greeting_file`. После `match` мы можем использовать дескриптор файла для чтения или записи.

Другая ветка `match` обрабатывает случай, когда из `File::open` получаем значение `Err`. В этом примере мы решили вызвать макрос `panic!`. Если в нашем текущем каталоге нет файла с именем _hello.txt_ и мы запустим этот код, то увидим стандартный вывод макроса `panic!`:

[example]
----
$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/error-handling`
thread 'main' panicked at 'Problem opening the file: Os
{ code: 2, kind: NotFound, message: "No such file or directory" }', src/main.rs:8:23
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
----

Как обычно, этот вывод сообщает нам, что именно пошло не так.

==== Сопоставление с разными видами ошибок

Код в листинге 9-4 вызовет `panic!` независимо от того, почему выполнить `File::open` не удалось. Мы хотим это исправить и выполнять разные действия в зависимости от причины сбоя функции, например, вот так: если `File::open` не выполнилась, потому что файл не существует, создадим новый файл и вернем его дескриптор; в случае какой-либо другой причины — например, из-за того, что у нас нет разрешения на открытие файла — оставляем вызов `panic!` так же, как в листинге 9-4. Код приведен в листинге 9-5; добавлена конструкция `match` для анализа варианта сбоя.

--
.Листинг 9-5: Обработка разных видов ошибок

Файл: src/main.rs

[source,rust]
----
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {:?}", e),
            },
            other_error => {
                panic!("Problem opening the file: {:?}", other_error);
            }
        },
    };
}
----
--

Тип значения, который `File::open` возвращает внутри варианта `Err`, — это структура `io::Error`, которая предоставляется стандартной библиотекой. У этой структуры есть метод `kind`, который можно вызвать для получения значения `io::ErrorKind`. Перечисление `io::ErrorKind` также предоставляется стандартной библиотекой и имеет варианты, представляющие различные типы ошибок, которые могут возникнуть в результате операции ввода-вывода. Мы хотим использовать вариант `ErrorKind::NotFound`, который указывает, что открываемый файл не существует. Итак, у нас есть не только сопоставление по `greeting_file_result`, но и внутреннее сопоставление по `error.kind()`.

Условие, которое мы хотим проверить во внутреннем `match` — является ли результирующее значение метода `error.kind()` вариантом `NotFound` перечисления `ErrorKind`. Если это так, то пытаемся создать файл с помощью функции `File::create`. Однако, поскольку `File::create` также может завершиться ошибкой, необходимо еше одно сопоставление во внутреннем выражении `match` для анализа результата `File::create`. Если файл не может быть создан, выводится другое сообщение об ошибке. Вторая ветка внешнего `match` остается прежней: программа паникует при любой ошибке, кроме ошибки отсутствия файла.

.Альтернативы применения `match` к `Result<T, E>`
****
Выражение `match` очень полезно, но в то же время весьма примитивно и "шумно". В Главе 13 мы познакомимся с замыканиями (closures), которые используются с многими методами перечисления `Result<T, E>`. Эти методы могут быть более краткими, чем использование `match` при обработке значений `Result<T, E>` в вашем коде.

Например, вот еще один способ написать ту же логику, что и в листинге 9-5, на этот раз с использованием замыканий и метода `unwrap_or_else`:

[source,rust]
----
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {:?}", error);
            })
        } else {
            panic!("Problem opening the file: {:?}", error);
        }
    });
}
----

Хотя этот код ведет себя так же, как в листинге 9-5, он не содержит никаких выражений `match` и его легче читать. Вернитесь к этому примеру после изучения Главы 13 и еще раз перечитайте определение метода `unwrap_or_else` в документации стандартной библиотеки по ссылке _https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or_else_. В случае обработки ошибок подобные методы позволяют гораздо более чисто и кратко описывать логику реализации, заменяя тем самым длинные вложенные выражения `match`.
****

==== Сокращенные методы с паникой: unwrap и expect

Конструкция `match` хороша в обработке ошибок, но получающийся в итоге код тяжело читать; в большом количестве вложенных веток можно легко запутаться. Для типа `Result<T, E>` определено множество вспомогательных методов, выполняющих различные более специфические задачи, и позволяющих более чисто и кратко писать код с обработкой ошибок. Мы рассмотрим методы `unwrap` и `expect`.

Метод `unwrap` — это сокращенный (shortcut) метод, реализованный точно так же, как и выражение `match`, которое мы написали в листинге 9-4. Если значением `Result` является вариант `Ok`, `unwrap` вернет значение внутри `Ok`. Если результатом является вариант `Err`, `unwrap` вызовет макрос `panic!`. Вот пример метода в действии:

Файл: src/main.rs

[source,rust]
----
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap();
}
----

Если мы запустим этот код без файла _hello.txt_, то увидим сообщение об ошибке от макроса `panic!`, вызываемого методом `unwrap`:


[example]
----
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Os
{code: 2, kind: NotFound, message: "No such file or directory" }',
src/main.rs:4:49
----

Точно так же работает метод `expect`, только дополнительно позволяет передать макросу `panic!` сообщение об ошибке. Применяя `expect` вместо `unwrap`, да еще и с хорошими сообщениями об ошибках, можно сделать код более понятным и упростить отслеживание источника паники. Синтаксис `expect` выглядит следующим образом:

Файл: src/main.rs

[source,rust]
----
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")
        .expect("hello.txt should be included in this project");
}
----

Мы используем `expect` так же, как и `unwrap`: чтобы вернуть дескриптор файла или вызвать функцию макрос `panic!`. Сообщение об ошибке, используемое `expect` в своем вызове `panic!` будет параметром, который мы передаем в `expect`, в отличие от `unwrap`, который ничего не передает макросу `panic!`, а при панике используется стандартное сообщение об ошибке. Вот как это выглядит:

[example]
----
thread 'main' panicked at 'hello.txt should be included in this project: Os {
code: 2, kind: NotFound, message: "No such file or directory" }',
src/main.rs:5:10
----

В релизном коде большинство опытных разработчиков Rust предпочитают применять `expect`, а не `unwrap`, и дают больше контекста о том, что нужно для успешного выполнения операции. Таким образом, если ваши предположения окажутся ошибочными, благодаря более широкому контексту у вас будет больше информации для отладки.

==== Распространение ошибок

Когда реализация функции вызывает что-то, что может привести к сбою, вместо обработки ошибки внутри самой функции вы можете вернуть ошибку в вызывающий код, чтобы он мог решить, что делать. Такое поведение известно как _распространение_ (_propagating _) ошибки и дает больший контроль вызывающему коду, в котором может быть больше информации или логики, определяющих, как следует обрабатывать ошибку, чем то, что  есть у вас в контексте вашего кода.

Например, в листинге 9-6 показана функция, читающая имя пользователя из файла. Если файл не существует или не может быть прочитан, эта функция вернет эти ошибки коду, вызвавшему функцию.

--
.Листинг 9-6: Функция, возвращающая ошибки вызывающему коду с помощью match

Файл: src/main.rs

[source,rust]
----
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let username_file_result = File::open("hello.txt");

    let mut username_file = match username_file_result {
        Ok(file) => file,
        Err(e) => return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&mut username) {
        Ok(_) => Ok(username),
        Err(e) => Err(e),
    }
}
----
--

Эту функцию можно написать гораздо короче, но чтобы лучше разобраться с обработкой ошибок, мы начнем с максимально развернутого кода; в конце покажем самый короткий вариант функции. Давайте сначала посмотрим на возвращаемый тип функции: `Result<String, io::Error>`. Это значит, что функция возвращает значение типа `Result<T, E>`, где параметр `T`  заполнен конкретным типом `String`, а `E` — конкретным типом `io::Error`.

Если функция `read_username_from_file` завершится без сбоев, вызывающий ее код получит значение `Ok`, содержащее строку — имя пользователя, которая читается из файла. Если функция в процессе выполнения столкнется с какими-либо проблемами, вызывающий ее код получит значение `Err`, содержащее экземпляр структуры `io::Error`, который содержит дополнительную информацию о том, в чем заключалась проблема. Мы выбрали `io::Error` в качестве типа возвращаемого из функции `read_username_from_file` значения, потому что значение именно этого типа возвращается обеими вызываемыми в `read_username_from_file` — функцией `File::open` и методом `read_to_string` — в случае возникновения каких-либо сбоев в процессе их выполнении.

Тело `read_username_from_file` начинается с вызова функции `File::open`. Затем мы обрабатываем значение `Result` сопоставлением как в листинге 9-4. Если `File::open` завершается успешно, дескриптор файла в переменной `file` из варианта `Ok` становится значением изменяемой переменной `username_file`, и функция продолжает выполнение. В случае `Err`, вместо вызова `panic!`, мы используем ключевое слово `return`, чтобы полностью выйти из функции раньше и передать значение ошибки как экземпляр структуры `io::Error` в переменной `e` из варианта `Err`, обратно в вызывающий код.

Итак, когда мы получили дескриптор файла в `username_file`, функция `read_username_from_file` создает новую пустую строку в переменной `username` и вызывает для дексриптора файла метод `read_to_string`, который читает содержимое этого файла в `username`. Метод также возвращает `Result`, потому что он может завершиться ошибкой, даже если `File::open` завершился успешно. Поэтому нам нужен еще один `match`, чтобы обработать этот `Result`: если `read_to_string` завершается успешно, то это значит, что наша функция `read_username_from_file` выполнена успешно, и мы возвращаем имя пользователя из файла, которое теперь находится в переменной `username`, завернутой (wrapped) в `Ok`. Если в `read_to_string` случается сбой, мы возвращаем значение ошибки так же, как в выражении `match`, которое обрабатывало возвращаемое значение из функции `File::open`. Нам не нужно явно указывать `return`, потому что это последнее выражение в функции.

Затем код, вызывающий функцию `read_username_from_file`, будет обрабатывать либо значение из варианта `Ok`, содержащего имя пользователя, либо значение из варианта `Err`, содержащее экземпляр структуру `io::Error`. Вызывающий код должен решить, что делать с этими значениями. Если он получает `Err`, то может вызвать `panic!` и завершить работу программы, или использовать имя пользователя по умолчанию, или найти имя пользователя, например, не в файле. У нас недостаточно информации о том, что на самом деле пытается сделать вызывающий код, поэтому мы распространяем всю информацию об успехе или ошибке вверх, чтобы там она была обработана должным образом.

Такой сценарий распространения ошибок настолько распространен в Rust, что для его поддержки в язык был введен оператор `?`, который делает код с обработкой ошибок еще проще и чище.

===== Сокращение для распространения ошибок: оператор ?

В листинге 9-7 показана реализация `read_username_from_file` с той же функциональностью, что и в листинге 9-6, но в этой реализации используется оператор `?`.

--
.Листинг 9-7: Функция, возвращающая ошибки вызывающему коду с помощью оператора ?

Файл: src/main.rs

[source,rust]
----
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut username_file = File::open("hello.txt")?;
    let mut username = String::new();
    username_file.read_to_string(&mut username)?;
    Ok(username)
}
----
--

Размещенный после `Result` оператор `?` работает почти так же, как выражения `match`, которые мы определили для обработки значений `Result` в листинге 9-6. Если значение `Result` равно `Ok`, значение внутри `Ok` будет результатом этого выражения, и программа продолжит выполнение. Если значением является `Err`, то оно возвращается в виде результирующего значения всей функции, как если бы мы использовали ключевое слово `return`; таким образом значение ошибки передается вызывающему коду.

Разница между `match` из листинга 9.6 и оператором `?` заключается в следующем: значения ошибок, которые есть в операторе `?`, проходят через функцию `from`, определенную в трейте `From` из стандартной библиотеки и применяемую для преобразования значений из одного типа в другой. Когда оператор `?` вызывает функцию `from`, полученный тип ошибки преобразуется в тип ошибки, определенный в возвращаемом типе текущей функции. Это полезно, когда функция возвращает один тип ошибки, чтобы представить одним значением все возможные сбои функции, даже если компоненты могут выйти из строя по разным причинам.

Например, мы могли бы изменить функцию `read_username_from_file` в листинге 9-7, чтобы она возвращала определенный нами тип ошибки с именем `OurError`. Если написать свою реализацию трейта `From` в определении `impl From<io::Error> for OurError`, в которой создавать экземпляры `OurError` из экземпляров структуры `io::Error`, то операторы `?` в теле `read_username_from_file` будут вызывать нашу реализацию функции `from` и преобразовывать тип `io::Error` в `OurError` без добавления дополнительного кода в функцию `read_username_from_file`.

В листинге 9-7 в конце вызова `File::open` оператор `?` вернет значение внутри `Ok` в переменную `username_file`. Если возникнет ошибка, `?` выполнит выход из функции с передачей вызывающему коду всего значения `Err`. То же самое относится и к `?` в конце вызова `read_to_string`.

Оператор `?` устраняет много шаблонного ("пустого") кода и упрощает реализацию функции `read_username_from_file`. Мы могли бы еще больше сократить этот код, соединяя вызовы методов вместе сразу после `?`, как показано в листинге 9-8.

--
.Листинг 9-8: Цепочка вызовов методов после оператора ?

Файл: src/main.rs

[source,rust]
----
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut username = String::new();

    File::open("hello.txt")?.read_to_string(&mut username)?;

    Ok(username)
}
----
--

Мы перенесли создание новой строки `username` в начало функции; в остальном эта часть не изменилась. Вместо создания переменной `username_file` соединили вызов `read_to_string` непосредственно с результатом `+File::open("hello.txt")?+`. Есть еще `?` в конце вызова `read_to_string`, и мы по-прежнему возвращаем значение `Ok`, содержащее `username`, когда и `File::open`, и `read_to_string` завершаются успешно. Новой функциональности нет - делаем то же самое, что и в листингах 9-6 и 9-7 функциональность не поменялась; это просто другой, более эргономичный и чистый способ написать реализацию функции `read_username_from_file`.

В листинге 9-9 показан способ сделать это еще короче с помощью функции `fs::read_to_string`.

--
.Листинг 9-9: Использование fs::read_to_string вместо открытия и последующего чтения файла

Файл: src/main.rs

[source,rust]
----
use std::{fs, io};

fn read_username_from_file() -> Result<String, io::Error> {
    fs::read_to_string("hello.txt")
}
----
--

Вот так все свелось к одной функции! На самом деле, чтение файла в строку — довольно распространенная операция, поэтому стандартная библиотека предоставляет удобную функцию `fs::read_to_string`, которая открывает файл, создает новый экземпляр `String`, считывает содержимое файла, помещает содержимое в `String` и возвращает этот `String`. Конечно, если бы мы сразу применили функцию `fs::read_to_string`, то лишили бы себя возможности объяснить на этом примере всю обработку ошибок, поэтому и проделали такой длинный путь.

===== Где может использоваться оператор ?

Оператор `?` может использоваться только в функциях с типом возвращаемого значения, совместимого с типом значения, для которого применяется `?`. Это объясняется тем, что `?`  может выполнять возврат значений из функции так же, как и выражение `match`, которое мы определили в листинге 9-6. В листинге 9-6 в `match` использовалось значение `Result` и досрочно возвращалось значение `Err(e)`. Тип возвращаемого значения функции должен быть `Result`, чтобы он был совместим с этим возвращаемым значением.

В листинге 9-10 приведен пример не компилируемого кода с попыткой использовать оператор `?` в функции `main` с типом возвращаемого значения, несовместимым с типом, для которого применяется `?`:

--
.Листинг 9-10: Не компилируемая попытка использовать ? в функции main, которая ничего не возвращает

Файл: src/main.rs

[source,rust]
----
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")?;
}
----
--

В этом коде открывается файл, и в процессе может случиться сбой. Оператор `?` следует за значением `Result`, возвращаемым функцией `File::open`, но функция `main` имеет возвращаемый тип `()`, а не `Result`. Когда мы компилируем этот код, то получаем следующее сообщение об ошибке:

[example]
----
$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option`
(or another type that implements `FromResidual`)
 --> src/main.rs:4:48
  |
3 | / fn main() {
4 | |     let greeting_file = File::open("hello.txt")?;
  | |                                                ^ cannot use the `?` operator in a function that returns `()`
5 | | }
  | |_- this function should return `Result` or `Option` to accept `?`
  |
  = help: the trait `FromResidual<Result<Infallible, std::io::Error>>` is not implemented for `()`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `error-handling` due to previous error
----

Эта ошибка сообщает, что оператор `?` разрешено использовать только в функции, которая возвращает `Result`, `Option` или другой тип, реализующий трейт `FromResidual`.

Есть два варианта исправить ошибку. Первый — изменить возвращаемый тип вашей функции, чтобы он был совместим со значением, которое используется в операторе `?`, при отсутствии ограничений, препятствующих этому. Второй способ заключается в применении `match` или одного из методов `Result<T, E>` для обработки этого типа любым подходящим способом.

В сообщении об ошибке говорится, что оператор `?` может использоваться также со значениями `Option<T>`. Как и в случае `Result` оператор `?` можно применять к `Option` только в функции, которая возвращает `Option`. Поведение оператора на типе `Option<T>` аналогично его поведению на типе `Result<T, E>`: если значение равно `None`, оператор выполнит возврат из функции результирующего значения `None`. Если значение равно `Some`, значение внутри `Some` станет результирующим значением оператора, и функция продолжит выполнение. В листинге 9-11 приведен пример функции, которая находит последний символ первой строки заданного текста:

--
.Листинг 9-11: Применение оператора ? к значению Option<T>

Файл: src/main.rs

[source,rust]
----
fn last_char_of_first_line(text: &str) -> Option<char> {
    text.lines().next()?.chars().last()
}
----
--

Функция `last_char_of_first_line` возвращает `Option<char>`, так как символ может быть, но может и не быть. В качестве аргумента она строковый срез `text` и вызывает для него метод `lines`, который возвращает итератор для коллекции строк в `text`. Итераторы подробно рассматриваются в Главе 13, сейчас достаточно знать, что итератор реализует метод `next`, который для заданной коллекции (детали см. в <<_chapter_8,Главе 8>>) возвращает следующий элемент коллекции в обертке `Option` по очевидной причине - этого элемента может и не быть. В нашем случае требуется проверить первую строку, поэтому этот метод разово вызывается у итератора, чтобы получить первый элемент коллекции строк текста. Если `text` является пустой строкой, вызов `next` вернет `None`, и в этом случае мы используем `?` чтобы остановиться и вернуть `None` из функции `last_char_of_first_line`. Если `text` не является пустой строкой, то `next` вернет значение `Some`, содержащее строковый срез первой строки в `text`.

Оператор `?` извлекает этот строковый срез, у среза вызывается метод `chars`, чтобы получить итератор для коллекции его символов. Нас интересует последний символ в первой строке, поэтому мы вызываем метод итератора `last`, чтобы вернуть последний элемент из коллекции символов в обертке `Option` по той же причине, что и метод `next`: первая строка может быть пустой строкой, например, если текст начинается с пустой строки, но в других строках есть символы, как в `"\nhi"`. Однако, если в первой строке есть последний символ, он будет возвращен в варианте `Some`. Оператор `?` в середине позволяет нам кратким способом выразить эту логику, так что реализация функции умещается в одной строке. Если бы оператор `?` нельзя было применять к типу `Option`, то пришлось бы реализовать эту логику, используя больше вызовов методов или выражений `match`.

Заметим, что можно применять оператор `?` для `Result` в функции, которая возвращает `Result`, и для `Option` в функции, которая возвращает `Option`, но смешивать эти типы нельзя.  Оператор `?` не будет автоматически преобразовывать `Result` в `Option` и наоборот; в этих случаях придется выполнить преобразование явно, для чего следует использовать такие методы, как метод `ok` для `Result` (см. _https://doc.rust-lang.org/std/result/enum.Result.html#method.ok_) или метод `ok_or` для `Option` (см. _https://doc.rust-lang.org/std/option/enum.Option.html#method.ok_or_).

До сих пор все функции `main`, которые мы использовали, возвращали `()`. Как известно, функция `main` особенная, потому что это точка входа и выхода исполняемых программ, и существуют ограничения на тип возвращаемого значения, чтобы программы вели себя должным образом.

К счастью, `main` может возвращать значение типа `Result<(), E>`. В листинге 9-12 используется код из листинга 9-10, но в функции `main` мы изменили возвращаемый тип на `Result<(), Box<dyn Error>>` и добавили значение `Ok(())` как последнее выражение функции. Теперь этот код будет скомпилирован:

--
.Листинг 9-12: Изменение в main типа возвращаемого значения на Result<(), E> позволяет использовать оператор ? на значениях Result

Файл: src/main.rs

[source,rust]
----
use std::error::Error;
use std::fs::File;

fn main() -> Result<(), Box<dyn Error>> {
    let greeting_file = File::open("hello.txt")?;

    Ok(())
}
----
--

Тип `Box<dyn Error>` — это _трейт-объект_, о котором мы поговорим в разделе «Использование трейт-объектов, допускающих значения разных типов» Главы 17. Сейчас можно считать, что `Box<dyn Error>` выражает понятие «любая ошибка». Теперь в функции `main` с типом ошибки `Box<dyn Error>` в возвращаемом значении допускается применять оператор `?` для значения `Result` и возвращать любое значение варианта `Err`. Несмотря на то, что в данном случае `main` будет возвращать только ошибки типа `std::io::Error`, применение `Box<dyn Error>` в сигнатуре функции позволяет ей успешно компилироваться и работать, даже если в ее тело будет добавлен дополнительный код, возвращающий другие типы ошибок, а не только ошибки ввода-вывода.

Когда функция `main` возвращает `Result<(), E>`, исполняемый файл завершится со значением 0, если `main` вернет `Ok(())`, и — с ненулевым значением, если `main` вернет значение `Err`. Исполняемые файлы, написанные на языке C, возвращают при выходе целые числа: успешно завершающиеся программы — целое число 0, а программы, вызвавшие ошибку — целое число, отличное от 0. Чтобы соответствовать этому соглашению, Rust также возвращает целые числа из исполняемых файлов.

Если говорить в общем, то функция `main` может возвращать любые типы, реализующие трейт `std::process::Termination` (детали см. по ссылке _https://doc.rust-lang.org/std/process/trait.Termination.html_), который содержит функцию `report`, возвращающую  `ExitCode`. Обратитесь к документации стандартной библиотеки за дополнительной информацией о реализации трейта `Termination` для ваших собственных типов.

Теперь, когда мы обсудили детали вызова `painc!` ил возвращения `Result`, давайте вернемся к теме того, как решить, что и в каких случаях использовать при обработке ошибок.
