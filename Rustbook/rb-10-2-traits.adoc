[#_10_2_traits]
=== 10.2. Трейты: определение общего поведения

_Трейт_ (_trait_, иногда переводится как "типаж") определяет функциональность типа, которую он может разделять с другими типам. Мы можем применять трейты как абстракцию определения совместного поведения. Можем использовать _баунды_ (_trait bounds_) для указания, что обобщенный тип является не просто любым типом, но типом с определенным поведением (_примечание переводчика: дословные переводы trait как "признака" или "типажа", а trait bound как "типажа-границы" не вполне подходят для дальнейшего изложения, поэтому термины используются в транслитерированной форме_).

[sidebar]
Примечание: трейты похожи на концепт, который в других языках часто называют _интерфейсами_ (_interfaces_), хотя и с некоторыми отличиями.

==== Определение трейта

Поведение типа обычно задается методами, которые можно вызывать для этого типа. Различные типы имеют одинаковое поведение, если можно вызывать одинаковые методы для этих типов. Определения трейтов являются способом группировки сигнатур методов для задания набора поведений, необходимых для достижения нужной нам цели (_примечание переводчика: это очень похоже на определение структур, которые через группировку полей выражают сущности предметной области; трейты в этом смысле посредством группировки методов выражают общее поведение этих сущностей: к примеру, для абстрактной сущности "фигура" можно определить общее поведение "пересекаться"_).

Например, предположим, что у нас есть несколько структур, содержащих текст различного типа и объема: структура `NewsArticle` для хранения новостей, публикуемых в определенном месте, и структура `Tweet`, текст которой может содержать не более 280 символов вместе с метаданными, указывающими, был ли это новый твит, ретвит или ответ на другой твит.

Мы хотим разработать библиотечный крейт медиа-агрегатора с именем `aggregator` для отображения итоговых сведений о данных, которые могут храниться в экземпляре `NewsArticle` или `Tweet`. Для краткости будем называть эти краткие сведения "сводками". Сводка нужна по каждому типу, и для ее получения будем вызывать для экземпляра типа метод `summarize`. В листинге 10-12 определяется открытый трейт `Summary`, выражающий это поведение.

--
.Листинг 10-12: трейт Summary с определением поведения, обеспечиваемого методом summarize

Файл: src/lib.rs

[source,rust]
----
pub trait Summary {
    fn summarize(&self) -> String;
}
----
--

Мы объявляем трейт, используя ключевое слово `trait`, а затем его имя, в данном случае `Summary`. Аннотируем трейт как `pub`, чтобы зависящие от нашей библиотеки крейты тоже могли использовать этот трейт (увидим в нескольких примерах дальше). Внутри фигурных скобок объявляем сигнатуры методов, которые описывают поведения типов, реализующих этот трейт, в данном случае `+fn summarize(&self) -> String+`.

После сигнатуры метода вместо реализации в фигурных скобках ставится точка с запятой. Каждый тип, реализующий этот трейт, должен обеспечивать собственное поведение для тела метода, иными словами, собственную реализацию метода трейта. Компилятор со своей стороны будет контролировать, чтобы для любого типа с трейтом `Summary` метод `summarize` был определен в точном соответствии с указанной в трейте сигнатурой.

В теле трейта может быть несколько методов: сигнатуры методов перечисляются по одной в строке, и каждая строка заканчивается точкой с запятой.

==== Реализация трейта в типе

Теперь, когда у нас заданы сигнатуры методов трейта `Summary`, мы можем реализовать его для типов, используемых в нашем медиа-агрегаторе. В листинге 10-13 показан пример реализации `Summary` для типов `NewsArticle` и `Tweet`, при этом для создания значения `summarize` в `NewsArticle` используются данные заголовка, имени автора и места публикации, а в `Tweet` — имя пользователя, за которым следует весь текст твита (предполагаем, что содержание твита уже ограничено 280 символами).

--
.Листинг 10-13: Реализация трейта Summary для типов NewsArticle и Tweet

Файл: src/lib.rs

[source,rust]
----
pub struct NewsArticle {
    pub headline: String,   // заголовок
    pub location: String,   // место публикации
    pub author: String,     // автор
    pub content: String,    // текст новости
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,   // учетная запись
    pub content: String,    // текст твита
    pub reply: bool,        // признак твита-ответа
    pub retweet: bool,      // признак ретвита
}

impl Summary for Tweet {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
}
----
--

Реализация трейта для типа аналогична реализации обычных методов. Разница в том, что после ключевого слова `impl` мы помещаем имя реализуемого трейта, затем используем ключевое слово `for` и имя типа, для которого реализуем трейт. В блоке `impl` помещаем сигнатуры методов, заданных в определении трейта. Вместо точки с запятой после каждой сигнатуры в фигурных скобках пишем реализацию соответствующего метода для выражения требуемого поведения этого типа.

Теперь, когда в библиотеке реализован трейт `Summary` для `NewsArticle` и `Tweet`, пользователи крейта могут вызывать методы трейта для экземпляров `NewsArticle` и `Tweet` так же, как мы вызываем обычные методы. Единственная разница в том, что разработчик должен внести в область действия своего крейта как трейт, так и типы. Например, вот как бинарный крейт может использовать наш библиотечный крейт `aggregator`:

Файл: src/main.rs

[source,rust]
----
use aggregator::{Summary, Tweet};

fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
}
----

_Примечание переводчика: авторы отсылают к известной в свое время истории с твиттер-аккаунтом @Horse_ebook, о которой можно более детально прочитать в википедии по ссылке _https://en.wikipedia.org/wiki/Horse_ebooks_. _В одном из "странных" твитов этого аккаунта фигурировал текст "unfortunately, as you probably already know, people", который авторы книги слегка модифицировали, заменив "unfortunately" на "of course"_

Этот код печатает "1 new tweet: horse_ebooks: of course, as you probably already know, people".

Другие крейты, зависящие от крейта `aggregator`, также могут включать трейт `Summary` в свою область действия для его реализации в своих собственных типах. Следует отметить одно ограничение: [.underline]#мы можем реализовать трейт для типа только в том случае, если трейт или тип является локальным для нашего крейта#. Например, мы можем реализовать трейты стандартной библиотеки, такие как `Display`, для пользовательского типа, такого как `Tweet`, как часть функциональности нашего крейта `aggregator`, поскольку тип `Tweet` определен в `aggregator` и является для него локальным. По той же причине можно также реализовать трейт `Summary`, например, для типа `Vec<T>` из стандартной библиотеки.

Но мы не можем реализовать внешние трейты для внешних типов. Например, нельзя реализовать трейт `Display` для `Vec<T>` в нашем крейте `aggregator`, потому что `Display` и `Vec<T>` определены в стандартной библиотеке и не являются локальными для `aggregator`. Это ограничение является частью свойства, называемого _когерентностью_ (_coherence_), а точнее даже _сиротским правилом_ (_orphan rule_), названным так потому, что отсутствует родительский тип. Это правило гарантирует, что чужой код не сможет сломать ваш код, и наоборот. Без этого правила два крейта могли бы реализовать один и тот же трейт для одного и того же типа, и Rust не знал бы, какую реализацию использовать.

==== Реализация по умолчанию

Иногда полезно иметь поведение по умолчанию для некоторых или всех методов трейта вместо того, чтобы требовать их реализации для каждого типа. Когда мы реализуем трейт для определенного типа, мы можем сохранить или переопределить поведение каждого метода по умолчанию.

В листинге 10-14 для метода `summarize` трейта `Summary` указывается строка по умолчанию вместо определения только сигнатуры метода в листинге 10-12.

--
.Листинг 10-14: Определение трейта Summary с реализацией метода summarize по умолчанию

Файл: src/lib.rs

[source,rust]
----
pub trait Summary {
    fn summarize(&self) -> String {
        String::from("(Read more...)")
    }
}
----
--

Чтобы в экземплярах `NewsArticle` использовать для `summarize` реализацию по умолчанию, мы просто оставляем пустым блок `impl` в `impl Summary for NewsArticle {}`.

Несмотря на то, что метод `summarize` не определяется в `NewsArticle` напрямую, мы предоставили в определении трейта реализацию метода по умолчанию, а в строке `impl Summary for NewsArticle {}` указали, что `NewsArticle` реализует трейт `Summary`. В результате можем по-прежнему вызывать `summarize` для экземпляров `NewsArticle`:

[source,rust]
----
    let article = NewsArticle {
        headline: String::from("Penguins win the Stanley Cup Championship!"),
        location: String::from("Pittsburgh, PA, USA"),
        author: String::from("Iceburgh"),   // см. статью https://en.wikipedia.org/wiki/List_of_NHL_mascots#Iceburgh
        content: String::from(
            "The Pittsburgh Penguins once again are the best \
             hockey team in the NHL.",
        ),
    };

    println!("New article available! {}", article.summarize());
----

Этот код выведет "New article available! (Read more...)".

Наличие реализации по умолчанию не требует от нас каких-либо изменений в реализации `Summary` для типа `Tweet` в листинге 10-13: в этом коде мы по факту переопределяем указанное поведение по умолчанию для сообщений `Tweet`, при этом никакого отдельного синтаксиса для этого не требуется, как и в общем случае переопределения реализации метода трейта по умолчанию.

Реализации по умолчанию могут вызывать другие методы в том же трейте, даже если эти методы не имеют реализации по умолчанию. Таким образом, трейт может предоставлять много полезной функциональности, при этом позволяя разработчикам реализовать только небольшую ее часть. Например, мы можем определить трейт `Summary` так, чтобы у него был метод `summarize_author` с требуемой реализацией в структурах, а затем определить метод `summarize`, который имеет реализацию по умолчанию, вызывающую метод `summarize_author`:

[source,rust]
----
pub trait Summary {
    fn summarize_author(&self) -> String;

    fn summarize(&self) -> String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}
----

Чтобы использовать эту версию `Summary`, нам нужно только определить метод `summarize_author`, когда мы реализуем трейт для типа:

[source,rust]
----
impl Summary for Tweet {
    fn summarize_author(&self) -> String {
        format!("@{}", self.username)
    }
}
----

Теперь, после реализации `summarize_author`, можем вызвать `summarize` для экземпляров структуры `Tweet`, и `summarize` по умолчанию вызовет нашу реализацию `summarize_author`. Поскольку мы определили метод `summarize_author`, то трейт `Summary` дал нужное нам поведение метода `summarize`, не требуя от нас никакого дополнительного кода.

Пример использования:

[source,rust]
----
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
----

Этот код выведет строку "1 new tweet: (Read more from @horse_ebooks...)".

Заметим, что невозможно вызвать реализацию по умолчанию из переопределяющей реализации того же метода.

==== Трейты как параметры

Теперь, когда вы знаете, как определять и реализовывать трейты, мы можем изучить, как применять трейты для определения функций, которые принимают множество различных типов. Будем использовать трейт `Summary`, реализованный для типов `NewsArticle` и `Tweet` в листинге 10-13, чтобы определить функцию `notify`, которая вызывает метод `summarize` для своего параметра `item`, относящемуся к некоторому типу, реализующему трейт `Summary`. Для этого используем синтаксис `impl Trait`:

[source,rust]
----
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
----

Вместо конкретного типа для параметра `item` мы указываем ключевое слово `impl` и имя трейта. Этот параметр принимает любой тип, который реализует указанный трейт. В теле функции `notify` мы можем вызывать для `item` любые методы, которые приходят из трейта `Summary`, например, `summarize`. Функция `notify` принимает любой экземпляр `NewsArticle` или `Tweet`. При попытке передать в функцию значение любого другого типа, например `String` или `i32`, код не будет компилироваться, поскольку эти типы не реализуют наш трейт `Summary`.

===== Синтаксис баунда

Синтаксис `impl Trait` работает для простых случаев, но на самом деле является синтаксическим сахаром для более длинной формы, известной как _боунд_ (_trait bound_); выглядит она так:

[source,rust]
----
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
----

Эта форма эквивалентна примеру из предыдущей секции, но является более подробной. Мы размещаем баунды внутри угловых скобок после объявления параметра обобщенного типа и двоеточия.

Синтаксис `impl Trait` удобен и делает код более лаконичным в простых случаях, в то время как полный синтаксис баунда может выражать более сложные случаи. Например, у нас может быть два параметра, реализующих трейт `Summary`. С помощью синтаксиса `impl Trait` сигнатуру функции `notify` можно записать следующим образом:

[source,rust]
----
pub fn notify(item1: &impl Summary, item2: &impl Summary) {
----

Применение `impl Trait` уместно в случае, когда параметры `item1` и `item2` должны иметь разные типы (при условии, что оба типа реализуют трейт `Summary`). Однако, если у параметров один и тот же тип, нужно использовать синтаксис границ типа, например:

[source,rust]
----
pub fn notify<T: Summary>(item1: &T, item2: &T) {
----

Обобщенный тип `T`, указанный как тип параметров `item1` и `item2`, ограничивает функцию так, что конкретный тип значения, передаваемого в качестве аргумента для `item1` и `item2`, должен быть одним и тем же.

===== Синтаксис "+" в случае нескольких баундов

Мы можем указать более одного баунда. Допустим, что функция `notify` должна использовать для параметра `item` форматированный вывод также как в методе `summarize`, тогда мы указываем в определении `notify`, что `item` должен реализовывать как трейт `Display`, так и трейт `Summary`. Это можно сделать, используя синтаксис "плюс" (`+`):

[source,rust]
----
pub fn notify(item: &(impl Summary + Display)) {
----

Этот синтаксис также применим к баундам на обобщенном типе:

[source,rust]
----
pub fn notify<T: Summary + Display>(item: &T) {
----

Когда указаны эти два баунда, то в теле функции `notify` можно вызвать `summarize` и применить для `item` форматирование `{}` (ранее с трейтом `Display` в его производной форме мы уже встречались в секции <<_5_2_derive_traits,""Добавление полезной функциональности с помощью производных трейтов>> Главы 5).

===== Пишем баунды более чисто с синтаксисом where

Использование слишком большого количества баундов имеет свои недостатки. У каждого обобщенного типа могут быть свои собственные баунды, поэтому в функциях с несколькими параметрами обобщенного типа их аннотация со всеми трейтами между именем функции и списком ее параметров получается слишком длинной, что затрудняет чтение сигнатуры функции. Поэтому в Rust есть альтернативный синтаксис для указания баундов после сигнатуры функции внутри предложения `where`. Вместо того чтобы писать длинную строку:

[source,rust]
----
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {
----

можно воспользоваться синтаксисом `where`:

[source,rust]
----
fn some_function<T, U>(t: &T, u: &U) -> i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
----

Сигнатура этой функции менее загромождена: имя функции, список параметров и тип возвращаемого значения расположены близко друг к другу, как и у функции без большого количества баундов.

==== Возврат типов, реализующих трейты

Мы можем также использовать синтаксис `impl Trait` в аннотации возвращаемого значения функции для возврата значения некоторого типа, реализующего трейт, как показано в следующем примере:

[source,rust]
----
fn returns_summarizable() -> impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    }
}
----

Применяя `impl Summary` для возвращаемого типа, мы таким образом указываем, что функция `return_summarizable` возвращает некоторый тип, который реализует трейт `Summary`, не называя конкретный тип. В нашем случае `return_summarizable` возвращает тип `Tweet`, но коду, вызывающему эту функцию, об этом знать не нужно.

Возможность указывать тип возвращаемого значения только с помощью трейта, реализуемого этим типом, особенно полезна в контексте замыканий и итераторов, которые мы рассмотрим в Главе 13. Замыкания и итераторы создают типы, известные только компилятору, или типы с очень длинной и трудной аннотацией. С помощью синтаксиса `impl Trait` можно просто указать, что функция возвращает некоторый тип, реализующий трейт `Iterator`, без необходимости записывать его длинную аннотацию.

Однако `impl Trait` применяется только в случае возврата какого-то одного типа. Например, следующий код, который возвращает либо `NewsArticle`, либо `Tweet` с типом возврата, указанным как `impl Summary`, не будет работать:

[source,rust]
----
fn returns_summarizable(switch: bool) -> impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                "Penguins win the Stanley Cup Championship!",
            ),
            location: String::from("Pittsburgh, PA, USA"),
            author: String::from("Iceburgh"),
            content: String::from(
                "The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.",
            ),
        }
    } else {
        Tweet {
            username: String::from("horse_ebooks"),
            content: String::from(
                "of course, as you probably already know, people",
            ),
            reply: false,
            retweet: false,
        }
    }
}
----

Из-за ограничений, связанных с реализацией синтаксиса `impl Trait` в компиляторе, возврат разных типов — в нашем случае `NewsArticle` или `Tweet` — с применением этого синтаксиса не допускается. Мы расскажем, как писать функции с таким поведением, в разделе «Использование трейт-объектов, допускающих значения разных типов» Главы 17.

==== Применение баундов в условной реализации методов

Используя баунды в блоке `impl` с параметрами обобщенных типов, можно условно реализовать методы для типов, реализующих указанные баунды. Например, тип `Pair<T>` в листинге 10-15 всегда реализует функцию `new` для возврата нового экземпляра `Pair<T>` (напомним из <<_5_3_method_syntax,секции "Определение методов">> раздела 5.3 "Синтаксис методов" Главы 5, что `Self` — это псевдоним типа, указанного после ключевого слова `impl`, которым в данном случае является `Pair<T>`). Но в следующем блоке `impl` наш тип `Pair<T>` реализует метод `cmp_display` только в том случае, если его внутренний тип `T` реализует трейт `PartialOrd` (разрешает сравнение) и трейт `Display` (разрешает вывод на экран).

--
.Листинг 10-15: Условная реализация методов для обобщенного типа в зависимости от баундов

Файл: src/lib.rs

[source,rust]
----
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
----
--

Также можно условно реализовать трейт для любого типа, который реализует другой трейт. Реализации трейта для любого типа, удовлетворяющего заданным баундам, называются _покрывающими реализациями_ (_blanket implementations_) и широко используются в стандартной библиотеке Rust. Например, стандартная библиотека реализует трейт `ToString` для любого типа, который реализует трейт `Display`. Блок `impl` в стандартной библиотеке выглядит примерно так:

[source,rust]
----
impl<T: Display> ToString for T {
    // --snip--
}
----

Поскольку в стандартной библиотеке есть такая покрывающая реализация, мы можем вызвать определенный в трейте `ToString` метод `to_string` для любого типа, реализующего трейт `Display`. Например, так как целые числа реализуют `Display`, то их можно преобразовать в соответствующие значения `String`; вот пример кода:

[source,rust]
----
let s = 3.to_string();
----

Покрывающие реализации детально описываются в документации трейта в разделе «Implementors».

Трейты и баунды позволяют писать код, который использует параметры обобщенного типа для уменьшения его дублирования, а также указывает компилятору, чтобы обобщенный тип имел заданное нами поведение. Далее, компилятор может использовать информацию о баундах для проверки конкретных типов, используемых в нашем коде, на предмет их правильного поведения. В динамически типизированных языках в случае вызова метода для типа, в котором этот метод не определен, вы получите ошибку во время выполнения. Но Rust перемещает эти ошибки на этап компиляции, вынуждая нас исправлять их еще до того, как наш код сможет запуститься. Кроме того, нам не нужно писать код, проверяющий поведение во время выполнения, потому что это уже сделано во время компиляции: получаем повышение производительности без отказа от гибкости дженериков.
