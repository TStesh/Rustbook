[#_8_1_vectors]
=== 8.1. Хранение списков значений в векторах

Первый тип коллекции, который мы рассмотрим, — это `Vec<T>`, также известный как _вектор_. Векторы позволяют хранить более одного значения в одной структуре данных, которая размещает все значения в памяти последовательно друг за другом. Векторы могут хранить значения только одного типа. Они полезны, когда у вас есть список элементов, например строки текста в файле или цены товаров в корзине.

==== Создание нового вектора

Чтобы создать новый пустой вектор, мы вызываем функцию `Vec::new`, как показано в листинге 8-1.

.Листинг 8-1: Создание нового пустого вектора для хранения значений типа i32
[source,rust]
----
    let v: Vec<i32> = Vec::new();
----

Обратите внимание, что здесь добавлена аннотация типа. Поскольку мы не вставляем никаких значений в этот вектор, Rust не знает, какие элементы мы собираемся хранить. Это важный момент. Векторы реализованы с использованием обобщенных типов; в Главе 10 мы расскажем, как использовать обобщенные типы в ваших собственных типах. А пока достаточно знать, что тип `Vec<T>`, предоставляемый стандартной библиотекой, может содержать любой тип. Когда мы создаем вектор для хранения определенного типа, то можем указать тип в угловых скобках. В листинге 8-1 `Vec<T>` в переменной `v` будет содержать элементы типа `i32`.

Чаще всего `Vec<T>` будет создаваться с начальными значениями, и в этом случае будет работать автоматическое выведение типов Rust, поэтому явно аннотировать тип вектора приходится в редких случаях. Rust предоставляет удобный макрос `vec!`, который создает новый вектор, содержащий заданные вами значения. В листинге 8-2 приведен пример создания нового вектора `Vec<i32>`, который содержит значения 1, 2 и 3. У вектора автоматически выведен тип значений `i32`, потому что, как мы обсуждали xref:_3_2_data_types[в разделе «Типы данных»] Главы 3, этот тип является типом целых чисел по умолчанию.

.Листинг 8-2: Создание нового вектора, содержащего значения
[source,rust]
----
    let v = vec![1, 2, 3];
----

Поскольку даны начальные значения типа `i32`, Rust автоматически выводит тип переменной `v` — это `Vec<i32>`, и явная аннотация типа не требуется. Давайте теперь посмотрим, как добавлять элементы в вектор.

==== Добавление элементов в вектор

Чтобы добавить элементы в вектор, мы можем использовать метод `push`, как показано в листинге 8-3. Этот метод добавляет элемент в конец вектора.

.Листинг 8-3: Использование метода push для добавления значений в вектор
[source,rust]
----
    let mut v = Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
----

Чтобы получить возможность изменять значение переменной, нужно сделать ее изменяемой с помощью ключевого слова `mut`, как обсуждалось в Главе 3. Все числа, которые мы помещаем внутрь, имеют тип по умолчанию `i32`, и Rust автоматически выводит тип переменной `v`; как говорилось выше, в этом случае нет никакой необходимости явно указывать аннотацию типа вектора `Vec<i32>`.

==== Чтение элементов векторов

Есть два способа получить значение, хранящееся в векторе: индексирование `[]` и метод `get`. В листинге 8-4 показан пример с обоими методами; для большей ясности мы явно аннотировали типы возвращаемых функциями значений.

.Листинг 8-4: Использование синтаксиса индексации и метода get для доступа к элементу в векторе
[source,rust]
----
    let v = vec![1, 2, 3, 4, 5];

    let third: &i32 = &v[2];
    println!("The third element is {}", third);

    let third: Option<&i32> = v.get(2);
    match third {
        Some(third) => println!("The third element is {}", third),
        None => println!("There is no third element."),
    }
----

Отметим некоторые детали. Чтобы получить третий элемент, используется значение индекса 2, потому что векторы индексируются по номеру, начиная с нуля. Применяя `&` и `[]`  мы по значению индекса получаем ссылку на элемент. Метод `get` с индексом, переданным в качестве аргумента, возвращает перечисление `Option<&i32>`, варианты которого обрабатываются в конструкции `match`.

Причина, по которой Rust предоставляет эти два способа ссылки на элемент, заключается в разном поведении при попытке использовать значение индекса за пределами диапазона существующих элементов. В качестве примера давайте посмотрим, что произойдет, когда у нас есть вектор из пяти элементов, а мы пытаемся получить доступ к элементу с индексом 100 с помощью каждого метода, как показано в листинге 8-5.

.Листинг 8-5: Попытка доступа к элементу с индексом 100 в векторе, содержащем пять элементов
[source,rust]
----
    let v = vec![1, 2, 3, 4, 5];

    let does_not_exist = &v[100];
    let does_not_exist = v.get(100);
----

При запуске этого кода первый метод `[]` вызовет панику в программе, потому что он ссылается на несуществующий элемент. Этот метод лучше всего использовать в случае критической необходимости аварийно завершать работу программы при попытке доступа к элементу за границами вектора.

Когда методу `get` передается индекс, находящийся за пределами вектора, метод без паники возвращает `None`; вы принимаете решение как его обработать. Этот метод применяется в случае эпизодического доступа к элементу за границами вектора при нормальных обстоятельствах. Например, индекс вводится человеком; если он случайно задаст слишком большое число и программа получит значение `None`, можно сообщить пользователю, сколько элементов находится в текущем векторе, и дать ему еще одну возможность ввести допустимое значение. Это удобнее, чем аварийно завершать программу из-за опечатки!

Когда в программе есть действительная ссылка, система проверки заимствования (borrow checker) применяет правила владения и заимствования (описанные в Главе 4), чтобы гарантировать, что эта ссылка и любые другие ссылки на содержимое вектора остаются действительными. Вспомните правило, согласно которому в одной и той же области действия не может быть одновременно изменяемых и неизменяемых ссылок. Это правило применяется в листинге 8-6, где мы храним неизменяемую ссылку на первый элемент вектора и пытаемся добавить элемент в его конец. Программа не будет работать и позже при попытке передать этот элемент в функцию:

.Листинг 8-6: Попытка добавить элемент в вектор, с одновременным удержанием ссылки на его первый элемент
[source,rust]
----
    let mut v = vec![1, 2, 3, 4, 5];

    let first = &v[0];

    v.push(6);

    println!("The first element is: {}", first);
----

Компиляция этого кода приведет к этой ошибке:

[example]
----
$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --> src/main.rs:6:5
  |
4 |     let first = &v[0];
  |                  - immutable borrow occurs here
5 |
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 |
8 |     println!("The first element is: {}", first);
  |                                          ----- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `collections` due to previous error
----

Код в листинге 8-6 выглядит как рабочий — кажется, что изменение в конце вектора не должно никак влиять на ссылку на первый элемент. Но это не так. Ошибка является следствием внутреннего устройства векторов: поскольку векторы помещают значения в заранее выделенной области памяти (размером которой управляет параметр capacity) последовательно друг за другом  памяти, может случиться так, что для нового элемента свободного места в этой области уже не будет; в этом случае выделяется новая область памяти с копированием в нее текущих элементов вектора, и ссылка на первый элемент будет уже указывать на освобожденную память и, таким образом, становится недействительной. Правила заимствования Rust предотвращают попадание программ в такую ситуацию.

[sidebar]
Примечание. Дополнительные сведения о реализации типа `Vec<T>` см. в книге «Растономикон» по ссылке _https://doc.rust-lang.org/nomicon/vec/vec.html_.

==== Перебор и изменение значений в векторе

Для доступа к каждому элементу вектора по очереди принято использовать технику итерации (= перебора) его элементов, а не обращаться к каждому из них по индексам. Эта техника уже обсуждалась на примере массивов в xref:_3_5_for[разделе "Перебор коллекции с помощью for"] Главы 3. Для векторов она применима в равной мере: в листинге 8-7 показан пример цикла `for` для получения неизменяемых ссылок на каждый элемент в векторе значений `i32` и их вывода на печать.

.Листинг 8-7: Печать каждого элемента в векторе путем перебора элементов с использованием цикла for
[source,rust]
----
    let v = vec![100, 32, 57];
    for i in &v {  // i - это неизменяемая ссылка на очередной элемент вектора
        println!("{}", i);
    }
----

Можно таким же образом изменять все элементы вектора, для этого в цикле нужно использовать изменяемые ссылки на каждый элемент вектора. Например, код в листинге 8-8 добавит 50 к каждому элементу.

.Листинг 8-8: Перебор изменяемых ссылок на элементы в векторе
[source,rust]
----
    let mut v = vec![100, 32, 57];
    for i in &mut v { // i - это изменяемая ссылка на очередной элемент вектора
        *i += 50;
    }
----

Чтобы изменить значение, на которое указывает изменяемая ссылка, мы должны использовать оператор разыменования `*`: в нашем случае `*i` получает значение по ссылке в `i`, прежде чем применить оператор `+=`. Подробнее об операторе разыменования поговорим в разделе «Переход по указателю на значение с помощью оператора разыменования» Главы 15.

Правила проверки заимствования обеспечивают безопасность перебора элементов вектора по изменяемым или неизменяемым ссылкам. Если бы мы попытались вставить или удалить элементы в теле цикла `for` в листингах 8-7 и 8-8, то получили бы такую же ошибку компилятора, как и в случае кода в листинге 8-6. Ссылка на вектор в цикле `for`, предотвращает одновременную модификацию всего вектора.

==== Использование перечисления для хранения нескольких типов

Векторы могут хранить значения только одного типа. Это не всегда удобно: есть ситуации, когда нужно хранить списки элементов разных типов. Вспоминая свойства перечислений (xref:_6_1_enum_definition[см. раздел "Определение перечисления"] Главы 6), которые по сути являются типами-контейнерами элементов разных типов, мы приходим к выводу, что перечисления - это именно то, что нам нужно!

Пусть есть задача получить значения из электронной таблицы, в строках которой содержатся целые числа, числа с плавающей запятой и строки. Мы можем определить перечисление, варианты которого будут содержать разные типы значений, и все варианты перечисления будут одним и тем же типом: типом перечисления. После чего создадим вектор для хранения значений этого перечисления, то есть, строк электронной таблицы, и, в конечном счете, нужных нам различных типов. Пример приведен в листинге 8-9.

.Листинг 8-9: Определение перечисления для хранения значений разных типов в одном векторе
[source,rust]
----
    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from("blue")),
        SpreadsheetCell::Float(10.12),
    ];
----

Rust во время компиляции должен знать типы элементов вектора, а значит, сколько памяти в куче потребуется для хранения каждого элемента. Также необходимо четко указать, какие типы разрешены в этом векторе. Если бы в векторе можно было хранить любой тип, всегда существовал бы риск того, что один или несколько типов могут привести к ошибкам при выполнении операций над элементами вектора. Использование перечисления и `match` гарантирует уже на этапе компиляции, что все возможные случаи будут обработаны, как обсуждалось <<_6_2_match,в Главе 6>>.

Если вы не знаете всех типов, которые программа может получить для сохранения в векторе во время выполнения, техника перечислений не сработает. Вместо этого можно использовать трейт-объект, который мы рассмотрим в Главе 17.

Теперь, когда мы обсудили некоторые из наиболее распространенных способов использования векторов, настоятельно рекомендуем ознакомиться с документацией API на странице _https://doc.rust-lang.org/std/vec/struct.Vec.html_; здесь представлено большое количество полезных методов, определенных стандартной библиотекой в типе `Vec<T>`. Например, в дополнение к методу `push` метод `pop` удаляет и возвращает последний элемент вектора.

==== Удаление элементов вектора

Как и любая другая структура, вектор освобождает выделенную память, когда выходит за пределы области действия, как показано в листинге 8-10.

.Листинг 8-9: Удаление вектора и всех его элементов
[source,rust]
----
    {
        let v = vec![1, 2, 3, 4];

        // что-то делаем с v
    }   // <- здесь v выходит из области действия,
        // освобождает выделенную память и удаляется
----

Когда вектор удаляется, также удаляется и все его содержимое; в нашем случае это означает, что содержащиеся в `v` целые числа будут очищены. Система проверки заимствования гарантирует, что любые ссылки на содержимое вектора действительны и используются только тогда, когда сам вектор действителен.

Давайте перейдем к следующему типу коллекции: `String`!
