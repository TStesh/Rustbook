[#_6_1_enum_definition]
=== 6.1. Определение перечисления

В отличие от структур, которые дают вам возможность группировать связанные поля и данные, например `Rectangle` с его `width` и `height`, перечисления позволяют вам сказать, что есть множество возможных значений, и любое значение должно быть элементом этого множества. Например, можно считать, что `Rectangle` — это одна из множества возможных фигур, в которое также входят `Circle` (круг) и `Triangle` (треугольник). Rust позволяет нам упаковать (encode) это представление в виде перечисления.

Давайте рассмотрим более-менее реальный пример, и выясним, почему в этом примере перечисления полезны и более уместны, чем структуры. Допустим, нам нужно работать с IP-адресами. В настоящее время для IP-адресов используются два основных стандарта: версия четыре и версия шесть. Поскольку никаких других возможностей для реальных IP-адресов нет, мы можем просто _перечислить_ оба существующих варианта; использование термина "перечисление" здесь очевидно.

Любой IP-адрес может быть адресом четвертой или шестой версии, но не обоими одновременно. Благодаря этому свойству IP-адресов перечислительная структура данных оказывается наиболее подходящей, поскольку значение перечисления может быть только одним из его вариантов. Адреса как четвертой, так и шестой версии по-прежнему являются IP-адресами, поэтому в случае обработки в программе ситуаций, применимых к любому типу IP-адресов, их следует рассматривать как один и тот же тип.

Мы можем выразить эту концепцию в коде, определив перечисление `IpAddrKind` и перечислив в нем возможные типы IP-адресов, `V4` и `V6`:

[source,rust]
----
enum IpAddrKind {
    V4,
    V6,
}
----

`IpAddrKind` теперь является пользовательским типом данных, который можно использовать в любом месте нашего кода.

==== Значения перечисления

Мы можем создать экземпляры каждого из двух вариантов `IpAddrKind` следующим образом:

[source,rust]
----
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
----

Обратите внимание, что варианты перечисления располагаются в пространстве имен блока `enum` (как и ассоциированные функции в структурах), и для доступа к ним должен использоваться синтаксис `::`. Оба значения `IpAddrKind::V4` и `IpAddrKind::V6` имеют один и тот же тип: `IpAddrKind`. Давайте для примера определим функцию с параметром типа `IpAddrKind`:

[source,rust]
----
fn route(ip_kind: IpAddrKind) {}
----

Вызовем эту функцию с вариантами нашего перечисления:

[source,rust]
----
    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
----

Использование перечислений дает дополнительные преимущества. Покажем это на примере типа IP-адреса. На данный момент нам только известно, какого он _вида_, но фактические _данные_ IP-адреса пока нигде не хранятся. Для этого, учитывая, то, что мы узнали в предыдущей главе, можно попробовать определить этот тип как структуру; предлагаемый нами вариант такой структуры показан в листинге 6-1.

--
.Листинг 6-1. Хранение данных и варианта IpAddrKind для IP-адреса с помощью структуры

[source,rust]
----
    enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from("127.0.0.1"),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from("::1"),
    };
----
--

Что мы сделали: добавили структуру `IpAddr` с двумя полями: поле типа `IpAddrKind` (ранее определенное перечисление) для хранения версии IP-адреса и поле типа `String` для хранения самого IP-адреса. Дальше создали два экземпляра этой структуры. Первый — `home` со значением `IpAddrKind::V4` поля `kind` и связанным с ним адресом `127.0.0.1`. Второй экземпляр — `loopback` с другим вариантом `IpAddrKind::V6` значения поля `kind` и связанным с ним адресом `::1`. Таким образом, мы использовали структуру для группировки значений `kind` и `address`, и теперь у нас есть связь варианта версии IP-адреса со значением самого адреса.

Однако есть более лаконичный вариант представления той же концепции с использованием только перечисления: вместо размещения перечисления внутри структуры можно поместить данные непосредственно в каждый вариант перечисления! Вот так будет выглядеть новое определение перечисления `IpAddr`, в котором варианты `V4` и `V6` будут иметь связанные с ними значения IP-адреса типа `String`:

[source,rust]
----
    enum IpAddr {
        V4(String),
        V6(String),
    }

    let home = IpAddr::V4(String::from("127.0.0.1"));

    let loopback = IpAddr::V6(String::from("::1"));
----

Мы напрямую присоединяем (attached) данные к каждому варианту перечисления, поэтому нет необходимости в дополнительной структуре. В данном представлении также легче увидеть еще один аспект конструкции перечисления: [.underline]#имя каждого варианта становится функцией, которая создает экземпляр перечисления#. То есть `IpAddr::V4()` — это вызов функции, которая принимает аргумент типа `String` и возвращает экземпляр типа `IpAddr`. Мы получаем эту функцию-конструктор "бесплатно", просто как один из результатов определения перечисления.

Есть b еще одно преимущество использования перечисления, а не структуры: [.underline]#каждый вариант может иметь разные типы и количества (amounts) присоединенных данных#. IP-адреса версии `V4` всегда будут иметь четыре числовых компонента со значениями от 0 до 255. Если бы было нужно хранить адреса `V4` как четыре значения `u8`, но по-прежнему выражать адреса `V6` как одно значение `String`, сделать это с помощью структуры было бы весьма затруднительно. Перечисление легко с этим справляется:

[source,rust]
----
    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from("::1"));
----

Мы показали несколько различных способов определения структур данных для хранения IP-адресов четвертой и шестой версий. Работа с IP-адресами и их типами оказывается настолько распространенной, что разработчики Rust добавили в стандартную библиотеку соответствующее определение (детали см. по ссылке _https://doc.rust-lang.org/std/net/enum.IpAddr.html_), которое вы можете использовать в своих программах! Давайте посмотрим, как стандартная библиотека определяет `IpAddr`:

[source,rust]
----
struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
----

Как мы видим, это перечисление с теми же вариантами, что и у нас, только данные адреса встраиваются внутри вариантов в более сложном виде двух структур, которые определяются по-разному для каждого варианта. Этот код показывает, что [.underline]#можно поместить в вариант перечисления любые данные: например, строки, числовые типы или структуры. Даже другое перечисление#! Кроме того, как можно заметить, типы из стандартной библиотеки часто не намного сложнее того, что вы можете придумать сами.

Обратите внимание, что даже несмотря на то, что стандартная библиотека содержит определение для `IpAddr`, мы все равно можем бесконфликтно создать и использовать свое собственное определение, поскольку не включили определение из стандартной библиотеки в нашу область действия. Подробнее о добавлении типов в область действия поговорим в Главе 7.

Давайте посмотрим на другой пример перечисления в листинге 6-2: в его варианты встроено большое количество типов.

--
.Листинг 6-2. Перечисление Message, варианты которого хранят разные количества и типы значений.

[source,rust]
----
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
----
--

В этом перечислении четыре варианта с разными присоединенными типами:

* `Quit` вообще не имеет связанных с ним данных.
* `Move` содержит именованные поля, как и структура.
* `Write` включает одну строку.
* `ChangeColor` присоединяет три значения `i32` в виде кортежной структуры.

Определение перечисления с такими вариантами, как в листинге 6-2, похоже на определение структур различных видов, за исключением того, что в перечислении не используется ключевое слово `struct`, а все варианты сгруппированы вместе под типом `Message` (_Примечание переводчика: то есть перечисление выступает в роли "типа-контейнера структур"_). Ниже приведены определения структур с теми же данными, что и в вариантах перечисления `Message`:

[source,rust]
----
struct QuitMessage; // пустая структура
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // кортежная структура
struct ChangeColorMessage(i32, i32, i32); // кортежная структура
----

При использовании таких разнотипных структур довольно затруднительно определить функцию с одним параметром для работы с произвольным типом сообщений, в отличие от перечисления `Message`, представляющего собой один тип.

Перечисления и структуры сходны в том, что для перечислений можно определять методы, точно так же как и для структур, используя блоки `impl`. Ниже приведен пример метода с именем `call` для нашего перечисления `Message`:

[source,rust]
----
    impl Message {
        fn call(&self) {
            // здесь тело метода
        }
    }

    let m = Message::Write(String::from("hello"));
    m.call();
----

В этом примере создается переменная `m` со значением `Message::Write(String::from("hello"))`, псевдонимом которой будет `self` в теле метода `call` при выполнении вызова `m.call()`. Далее метод использует `self` в виде заимствованного значения `m`.

Давайте рассмотрим другое, очень распространенное и полезное, перечисление из стандартной библиотеки: `Option`.

[#_6_1_option]
==== Перечисление Option и его преимущества перед null

В этой секции рассматривается пример использования `Option`, еще одного перечисления, определенного в стандартной библиотеке. Тип `Option` применяется в очень распространенном сценарии, когда значение либо существует, либо нет.

Например, при запросе первого элемента из непустого списка будет получено значение — это вариант с существованием значения. Аналогичный запрос для пустого списка ничего не вернет — это противоположный вариант, в котором значение не существует. Выражение этой концепции в терминах статической системы типов означает, что еще на этапе компиляции можно проверить, обработаны ли все случаи, которые должны быть обработать; такая функциональность позволяет предотвратить чрезвычайно распространенные ошибки времени исполнения в других языках программирования.

Дизайн языка программирования часто рассматривают с точки зрения того, какие функции (features) в него включены, но не менее важны и функции, которые в него не входят. Например, в Rust нет null, который есть во многих других языках. _Null_ — это пустое значение, означающее, что нет никакого значения. В языках с null переменные всегда находятся в одном из двух состояний: null или не null.

****
Тони Хоар (Tony Hoare), изобретатель null, в своей презентации 2009 года «Нулевые ссылки: ошибка на миллиард долларов» (_"Null References: The Billion Dollar Mistake", 2009) сказал следующее:

"Я называю это своей ошибкой на миллиард долларов. В то время я разрабатывал первую всеобъемлющую систему типов для ссылок в объектно-ориентированном языке. Моя цель состояла в том, чтобы гарантировать, что любое использование ссылок должно быть абсолютно безопасным, с автоматической проверкой компилятором. Но я не мог устоять перед искушением добавить пустую ссылку просто потому, что это было так легко реализовать. Это привело к бесчисленным ошибкам, уязвимостям и системным сбоям, которые, вероятно, причинили миллиарды долларов боли и ущерба за последние сорок лет."
****

Суть проблемы с null заключается в том, что если мы попытаемся использовать переменную в состоянии null как имеющую значение (то есть, как не null), то получим ошибку во время выполнения (какую конкретно, зависит от контекста); в случае, если такая ошибка не перехватывается и не обрабатывается, программа аварийно завершится. Поскольку переменные оказываются в состоянии null довольно часто, получить такую ошибку очень легко.

Однако стоящая за всем этим концепция по-прежнему актуальна и выражает простую идею: null — это недействительное или отсутствующее по какой-то причине значение на данный момент времени. И проблема на самом деле не в самой концепции, а в конкретной реализации. Поэтому в Rust нет null, но есть перечисление, которое должным образом представляет концепцию наличия или отсутствия значения. Речь идет о перечислении `Option<T>`; вот его определение в стандартной библиотеке (детали см. по ссылке _https://doc.rust-lang.org/std/option/enum.Option.html_):

[source,rust]
----
enum Option<T> {
    None,
    Some(T),
}
----

Перечисление `Option<T>` настолько полезно, что даже включено в прелюдию; вам не нужно явно включать его в область действия. Его варианты также включены в прелюдию: можно использовать `Some` и `None` напрямую без префикса `Option::`. Перечисление `Option<T>` по-прежнему является обычным перечислением, а `Some(T)` и `None` все также являются вариантами типа `Option<T>`.

Синтаксис `<T>` — это особенность Rust, о которой мы еще не говорили; этот синтаксис задает параметр обобщенного типа, о чем подробно говорится в Главе 10. На данный момент достаточно знать следующее: `<T>` означает, что вариант `Some` перечисления `Option` может содержать некоторые данные любого типа, и что каждый конкретный тип, который используется вместо `T`, приводит обобщенный тип `Option<T>` к другому типу. Вот несколько примеров использования значений `Option` для хранения числовых и строковых типов:

[source,rust]
----
    let some_number = Some(5);
    let some_char = Some('e');

    let absent_number: Option<i32> = None;
----

Тип `some_number` — `Option<i32>`. Тип `some_char` — `Option<char>`, который является другим типом. Rust может вывести эти типы, потому что мы указали значение внутри варианта `Some`. Для `Absent_number` Rust требует аннотировать тип `Option`: компилятор, имея только `None`, не может вывести тип, значение которого будет содержать пока отсутствующий вариант `Some`. Поэтому мы явно указываем, что тип `Absent_number` должен быть `Option<i32>`.

Когда у нас есть вариант `Some`, то это значит, что значение _есть_ и оно хранится внутри `Some`. Вариант `None` в некотором смысле означает то же самое, что и null: валидное значение отсутствует. Так почему же `Option<T>` лучше, чем null?

Поскольку `Option<T>` и `T` (где `T` может быть любым типом) являются разными типами, компилятор не позволит нам использовать значение `Option<T>` как обычное допустимое значение типа `Т`. Например, этот код не скомпилируется, так как в нем делается попытка добавить `i8` к `Option<i8>`:

[source,rust]
----
    let x: i8 = 5;
    let y: Option<i8> = Some(5);

    let sum = x + y;
----

Если мы запустим этот код, мы получим сообщение об ошибке:

[example]
----
$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option<i8>` to `i8`
 --> src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option<i8>`
  |
  = help: the trait `Add<Option<i8>>` is not implemented for `i8`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` due to previous error
----

По сути, это сообщение об ошибке означает, что Rust не понимает, как сложить `i8` и `Option<i8>`, потому что это разные типы. При использовании типа `i8` компилятор гарантирует, что значение этого типа всегда будет допустимым. Мы можем продолжить работу, не проверяя значение null перед использованием значения `i8`. Но в случае `Option<i8>` (или любого другого типа, указанного в обобщенном параметре `Option`) придется проверить тип на отсутствие значения, и тут уже сам компилятор позаботится о том, чтобы мы обработали этот случай, прежде чем использовать значение.

Иными словами, прежде чем продолжить работу со значением типа `Т`, нужно преобразовать `Option<T>` в `T`. Как правило, именно это действие позволяет решить одну из самых распространенных проблем с null: когда что-то используется как не null, хотя на самом деле является null.

Устранение риска ошибиться и использовать null как не null, повышает уверенность в правильности кода. Для работы со значением типа `T`, которое может быть null, нужно разместить сам тип `T` в `Option<T>`; затем явно проверять значение на существование при каждом его использовании. В случае типа, отличного от `Option<T>`, считается, что значение этого типа всегда существует. Именно такой подход был принят разработчиками языка Rust для ограничения "вездесущности" (pervasiveness) null и повышения безопасности кода.

Теперь перед нами встал вопрос - как получить значение `T` из варианта `Some`, чтобы использовать его дальше в коде, когда у нас есть значение типа `Option<T>`? Перечисление `Option<T>` имеет большое количество методов, полезных в различных ситуациях; наиболее полно они описаны в документации по ссылке _https://doc.rust-lang.org/std/option/enum.Option.html_. Для более глубокого изучения Rust чрезвычайно полезно познакомиться со всеми методами `Option<T>`.

В общем, чтобы использовать значение `Option<T>`, нужен код, который будет обрабатывать каждый вариант. Также нужен код, который будет выполняться только тогда, когда есть `Some(T)`, и этому коду разрешено использовать внутреннее значение `T`. С другой стороны, должен быть код, который выполняется в случае `None`, и в этом коде значение `Т` уже недоступно. Выражение `match` — это конструкция управления потоком выполнения, которая ведет себя при применении к перечислениям именно так: будет запускаться различный код в зависимости от варианта перечисления, и этот код может использовать данные внутри совпадающего значения.
