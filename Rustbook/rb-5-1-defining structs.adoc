[#_5_1_defining_struct]
=== 5.1. Определение и создание экземпляров структур

Структуры похожи на кортежи (см. секцию xref:_3_2_2_1_tuples[«Кортеж»] раздела "Составные типы" Главы 3) в том смысле, что и те и другие содержат несколько связанных значений. Как и кортежи, части структуры могут быть разных типов. В отличие от кортежей, в структуре каждая часть данных имеет собственное имя для указания на их семантику. Возможность использовать имена повышает гибкость структуры по сравнению с кортежами: для доступа к значениям экземпляра не требуется знать расположение данных.

Структура определяется ключевым словом `struct`, далее следует её имя и пара фигурных скобок `{}`. Имя структуры должно соотноситься с предметной областью кода и отражать семантику данных, размещаемых в этой структуре. Внутри фигурных скобок задаются имена и типы частей сгруппированных данных, называемых _полями_. Например, в листинге 5-1 показана структура, в которой хранится информация об учетной записи пользователя.

--
.Листинг 5-1: Определение структуры User

[source,rust]
----
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
----
--

Чтобы использовать структуру после ее определения, нужно создать _экземпляр_ этой структуры, указав конкретные значения каждого из ее полей. Для создания экземпляра мы должны написать имя структуры, затем добавить фигурные скобки, внутри которых перечислить пары `ключ: значение`, где ключи — это имена полей, а значения — это данные, которые хранятся в этих полях. Нам не нужно указывать поля в том же порядке, в каком мы объявили их в структуре. Можно сказать, что определение структуры похоже на общий шаблон (general template) типа, для создания значений которого в каждом экземпляре шаблона нужно заполнять его конкретными данными. Например, мы можем объявить конкретного пользователя, как показано в листинге 5-2.

--
.Листинг 5-2: Создание экземпляра структуры User

[source,rust]
----
fn main() {
    let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };
}
----
--

Чтобы получить значение поля, используется точечная нотация. Например, для доступа к адресу электронной почты пользователя `user1` пишем `user1.email`. Если экземпляр структуры является изменяемым, то применяя точечную нотацию, можно присвоить значение заданному полю. В листинге 5-3 показано, как изменить значение поля `email` изменяемого экземпляра `User`.

--
.Листинг 5-3: Изменение значения поля email экземпляра User

[source,rust]
----
fn main() {
    let mut user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };

    user1.email = String::from("anotheremail@example.com");
}
----
--

Обратите внимание, что изменяемым является экземпляр целиком; Rust не позволяет помечать как изменяемые отдельные поля структуры. Как и любое значение, экземпляр структуры является выражением. Ничто не мешает нам создать новый экземпляр структуры в качестве последнего выражения в теле функции, чтобы неявно вернуть его как результирующее значение.

В листинге 5-4 показана функция `build_user`, которая возвращает экземпляр `User` с заданными адресом электронной почты и именем пользователя. Поле `active` получает заданное в коде значение `true`, а `sign_in_count` — заданное в коде значение 1.

--
.Листинг 5-4. Функция build_user принимает email и username и возвращает экземпляр User

[source,rust]
----
fn build_user(email: String, username: String) -> User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
----
--

Параметры функции можно называть теми же именами, что и поля структуры, но в этом случае, как видно из листинга 5-4, возникают повторы в наименованиях полей (`email` и `username`), и это выглядит как шаблонный (boilerplate) код. Если в структуре было бы больше полей, повторение каждого имени привело бы к большому количеству такого "пустого" кода и увеличило трудозатраты по его разработке и сопровождению. К счастью, есть удобное сокращение!

==== Использование сокращенной формы инициализации поля

Поскольку имена параметров и имена полей структуры в листинге 5-4 одинаковые, можно использовать синтаксис _сокращенной инициализации поля_ (_field init shortland_) и переписать функцию `build_user` так, чтобы она делала то же самое, но уже без повторения имен полей `email` и `username`, как показано в листинге 5-5.

--
.Листинг 5-5. Функция build_user с сокращенной инициализацией полей

[source,rust]
----
fn build_user(email: String, username: String) -> User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
----
--

Здесь мы создаем новый экземпляр структуры `User`, в которой есть поле с именем `email`, и хотим установить значение поля `email` в значение параметра `email` функции `build_user`. Поскольку поле и параметр имеют одно и то же имя, нам достаточно написать только `email`, а не `email: email`.

==== Создание экземпляров из других экземпляров с синтаксисом обновления структуры

Часто требуется создать новый экземпляр структуры, который включает в себя большую часть значений из другого экземпляра, но некоторые из них изменяются. В этом случае можно использовать _синтаксис обновления структуры_ (_struct update syntax_).

Сначала в листинге 5-6 покажем обычный способ создания нового экземпляра `user2` структуры `User` без применения синтаксиса обновления. В примере только поле `email` принимает новое значение, в остальных полях используются значения из `user1`, которые были созданы в листинге 5-2.

--
.Листинг 5-6: Создание нового экземпляра User с использованием значений полей user1

[source,rust]
----
fn main() {
    // --snip--

    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,
    };
}
----
--

Применяя синтаксис обновления структуры, мы можем получить тот же результат меньшим количеством кода, как показано в листинге 5-7. Синтаксис `..` означает, что остальные, не заданные явно, поля этого экземпляра должны иметь те же значения, что и одноименные поля в указанном после `..` экземпляре.

--
.Листинг 5-7: Применение синтаксиса обновления структуры для установки нового значения email для User

[source,rust]
----
fn main() {
    // --snip--

    let user2 = User {
        email: String::from("another@example.com"),
        ..user1
    };
}
----
--

Код в листинге 5-7 создает экземпляр `user2` структуры `User` с другим значением поля `email`, но теми же значениями для полей `username`, `active` и `sign_in_count`, что и в экземпляре `user1`. Можно указывать значения для любых полей в произвольном порядке, независимо от их порядка в определении структуры. Выражение `..user1` должно указываться в последнюю очередь, чтобы оставшиеся неявными поля получили свои значения из соответствующих полей `user1`.

Обратите внимание, синтаксис обновления структуры использует `=` как присваивание, в процессе которого происходит перемещение данных с передачей владения как описано в xref:_4_1_ownership_moving[разделе «Способы взаимодействия переменных и данных: перемещение»] Главы 4. В этом примере мы больше не можем использовать `user1` после создания `user2`, поскольку значение `String` поля `username` было перемещено из `user1` в `user2`. Если бы в `user2` мы задали новые значения `String` как для `email`, так и для `username` и, таким образом, использовали только значения `active` и `sign_in_count` из `user1`, тогда `user1` все еще был бы действительным после создания `user2`. Типы `active` и `sign_in_count` — это типы, которые реализуют трейт `Copy`, поэтому ведут себя как описано в xref:_4_1_ownership_coping[разделе «Данные только в стеке: копирование»] Главы 4.

==== Использование кортежных структур без именованных полей для создания разных типов

Rust также поддерживает структуры, похожие на кортежи, которые так и называются — _кортежные структуры_ (_tuple structs_). Кортежные структуры имеют преимущество, которое дает им наименование структуры, но не содержат имен полей; в них есть просто типы полей. Такие структуры полезны, когда вы хотите дать наименование кортежу и сделать его другим типом, и при этом обойтись без именования каждого поля, как в обычной структуре.

Определение кортежной структуры начинается с ключевого слова `struct`, за которым следуют имя структуры и кортеж с типами полей структуры. Например, здесь определяются и используются две кортежные структуры с именами `Color` и `Point`:

[source,rust]
----
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
----

Обратите внимание, что значения `black` и `origin` — это разные типы, потому что они являются экземплярами разных кортежных структур. Каждая определяемая вами структура имеет собственный тип, даже если поля внутри структуры могут иметь одинаковые типы. Например, функция, принимающая параметр типа `Color`, не может принимать `Point` в качестве аргумента, даже если оба типа состоят из трех значений `i32`. В остальном экземпляры кортежной структуры похожи на кортежи в том смысле, что для доступа к отдельному ее значению вы можете деструктурировать экземпляр на отдельные части или использовать оператор "точка" (`.`), за которым следует индекс нужного значения.

==== Структуры без полей

Также можно определять структуры без полей! Они называются _пустыми структурами_ (_unit-like structs_), потому что ведут себя аналогично `()`, пустому типу `unit`, который упоминался в xref:_3_2_2_1_tuples[секции «Кортеж»] раздела "Составные типы" Главы 3. Пустые структуры могут быть полезны, когда нужно реализовать трейт для типа без данных (трейты обсуждаются в Главе 10). В качестве примера объявим и создадим экземпляр пустой структуры с именем `AlwaysEqual`:

[source,rust]
----
struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}
----

Для определения `AlwaysEqual` используем ключевое слово `struct`, желаемое имя и точку с запятой. Не нужно фигурных или круглых скобок! Для получения экземпляра `AlwaysEqual` в переменной `subject` поступаем аналогичным образом: используем заданное нами имя без каких-либо фигурных или круглых скобок. Давайте представим, что этот тип должен вести себя так: экземпляр `AlwaysEqual` всегда равен экземпляру любого другого типа. Такое поведение может пригодиться в качестве "заглушки" при выполнении тестирования, чтобы в любой ситуации иметь заранее известный результат. Как мы видим, для этого никакие данные в нашем типе не нужны! Поведение типов задается трейтами, и об этом мы подробно поговорим в Главе 10, где покажем как определять трейты и реализовывать их в любом типе, включая пустые структуры.

.Владение данными структур
****
В определении структуры `User` в листинге 5-1 мы использовали тип `String`, тип с владением, вместо среза `&str`. Это преднамеренный выбор, потому что мы хотим, чтобы каждый экземпляр этой структуры владел всеми своими данными и чтобы эти данные были действительными до тех пор, пока действительна вся структура.

Структуры также могут хранить ссылки на данные, принадлежащие кому-то другому, но для этого необходимо использовать _времена жизни_ (_lifetimes_), особую функциональность Rust, которая обсуждается в <<_10_3_lifetimes,Главе 10>>. Времена жизни гарантируют, что данные, на которые ссылается структура, будут действительны в течение всего времени ее жизни. Допустим, вы пытаетесь сохранить ссылку в структуре без указания времени жизни, как показано в примере ниже:

Файл: src/main.rs

[source,rust]
----
struct User {
    active: bool,
    username: &str,
    email: &str,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        email: "someone@example.com",
        username: "someusername123",
        active: true,
        sign_in_count: 1,
    };
}
----

Компилятор выдаст ошибку "missing lifetime specifier" — нужны спецификаторы времени жизни:

[example]
----
$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
error[E0106]: missing lifetime specifier
 --> src/main.rs:3:15
  |
3 |     username: &str,
  |               ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User<'a> {
2 |     active: bool,
3 ~     username: &'a str,
  |

error[E0106]: missing lifetime specifier
 --> src/main.rs:4:12
  |
4 |     email: &str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User<'a> {
2 |     active: bool,
3 |     username: &str,
4 ~     email: &'a str,
  |

For more information about this error, try `rustc --explain E0106`.
error: could not compile `structs` due to 2 previous errors
----

В <<_10_3_lifetimes,Главе 10>> мы обсудим, как исправлять такие ошибки, чтобы можно было хранить ссылки в структурах, но на данном этапе просто обходим проблему, используя типы с владением, такие как `String`, вместо ссылок, таких как `&str`.
****
