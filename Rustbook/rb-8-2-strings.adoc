[#_8_2_strings]
=== 8.2. Хранение текста в кодировке UTF-8 с помощью String

Мы говорили о строках в xref:_4_1_string_type[Главе 4], но теперь рассмотрим их более подробно. Начинающие разработчики Rust "застревают" на строках обычно по трем причинам: 1) пристрастность Rust к всевозможным ошибкам, 2) строки представляют собой более сложную структуру данных, чем ожидают многие программисты, и 3) UTF-8. Если вы пришли в Rust из таких языков как Python или JavaScript, эти факторы по началу могут показаться излишне сложными. Наша задача — изложить материал так, чтобы к концу раздела вы хорошо понимали что такое "строка"!

Строки обсуждаются в контексте коллекций потому, что реализованы как коллекция байтов, плюс есть ряд методов с полезной функциональностью, интерпретирующих эти байты как текст. В этом разделе мы поговорим об операциях над `String`, которые есть у каждого типа коллекции — создание, изменение и чтение. Также обсудим, чем `String` отличается от других коллекций, а именно, сложностями с индексацией в `String` из-за различий в интерпретации данных `String` между разработчиками и компилятором.

==== Что такое String?

Сначала мы определим, что подразумеваем под термином _строка_. В ядре языка Rust есть только один тип строки — строковый срез `str`, который обычно встречается в заимствованной форме `&str`. В xref:_4_3_slices[Главе 4] мы говорили о _строковых срезах_, которые являются ссылками на некоторые строковые данные в кодировке UTF-8, хранящиеся в другом месте. Например, строковые литералы хранятся в исполняемом файле программы и, следовательно, являются строковыми срезами.

Предоставляемый стандартной библиотекой тип `String` представляет собой расширяемый, изменяемый, владеющий (owned) строковый тип в кодировке UTF-8. Когда опытные разработчики Rust говорят о «строках», они могут иметь в виду как `String`, так и срез `&str`, а не только один из этих типов. Хотя этот раздел в основном посвящен `String`, оба типа широко используются в стандартной библиотеке Rust; также оба типа кодируются UTF-8.

==== Создание значений String

Большинство операций, которые можно выполнять с типом `Vec<T>`, можно выполнять и с типом `String`, потому что `String` фактически реализован как обертка (wrapper) вектора байтов с некоторыми дополнительными гарантиями, ограничениями и возможностями. Примером функции, которая работает одинаково с `Vec<T>` и `String`, является функция `new` для создания экземпляра типа, показанная в листинге 8-11.

.Листинг 8-11: Создание нового, пустого String
[source,rust]
----
    let mut s = String::new();
----

Этот код создает новую пустую (изменяемую) строку с именем `s`, в которую можно будет загрузить данные. Часто у нас уже есть исходные данные, которые нужно записать в строку при ее создании. Для этого используется метод `to_string`, применимый к экземпляру любого типа, реализующего трейт `Display`; для строковых литералов этот трейт реализован по умолчанию. В листинге 8-12 показаны два примера.

.Листинг 8-12: Использование метода to_string для создания String из строкового литерала
[source,rust]
----
    let data = "initial contents";

    let s = data.to_string();

    // метод работает прямо на строковых литералах:
    let s = "initial contents".to_string();
----

Этот код создает строку, содержащую "initial contents".

Для создания строки из строкового литерала также можно использовать (ассоциированную) функцию `String::from`. Код в листинге 8-13 делает то же самое, что и код из листинга 8-12.

.Листинг 8-13: Использование функции String::from для создания строки из строкового литерала
[source,rust]
----
    let s = String::from("initial contents");
----

Поскольку строки очень часто встречаются в программах Rust, к ним применимо множество различных универсальных API, что приводит к большому разнообразию вариантов использования типа `String`. Некоторые из них могут показаться излишними, но они все работают! В нашем примере `String::from` и `to_string` делают одно и то же, так что выбор зависит от стиля и удобочитаемости.

В строках используется кодировка UTF-8, поэтому можно включать в них любые правильно закодированные данные, как показано в листинге 8-14.

.Листинг 8-14: Хранение в строках приветствий на разных языках
[source,rust]
----
    let hello = String::from("السلام عليكم");
    let hello = String::from("Dobrý den");
    let hello = String::from("Hello");
    let hello = String::from("שָׁלוֹם");
    let hello = String::from("नमस्ते");
    let hello = String::from("こんにちは");
    let hello = String::from("안녕하세요");
    let hello = String::from("你好");
    let hello = String::from("Olá");
    let hello = String::from("Здравствуйте");
    let hello = String::from("Hola");
----

Все они являются допустимыми значениями `String`.

==== Изменение значений String

При вставке в строку каких-либо данных, она может увеличиваться в размере, а ее содержимое — изменяться, как, например, содержимое `Vec<T>`. Кроме того, значения `String` можно объединять, используя для этого оператор `+` или макрос `format!`. Объединение строк называется _конкатенацией_.

===== Добавление в String с помощью push_str и push

Мы можем увеличить `String`, используя метод `push_str` для добавления строкового среза, как показано в листинге 8-15.

.Листинг 8-15: Добавление строкового среза к String с использованием метода push_str
[source,rust]
----
    let mut s = String::from("foo");
    s.push_str("bar");
----

После этих двух строк `s` будет содержать "foobar". Метод `push_str` принимает строковый срез, потому нет никакой необходимости забирать владение параметром. Например, в коде листинга 8-16 мы хотим использовать `s2` после добавления его содержимого к `s1`.

.Листинг 8-16: Использование строкового среза после добавления его содержимого в String
[source,rust]
----
    let mut s1 = String::from("foo");
    let s2 = "bar";
    s1.push_str(s2);
    println!("s2 is {}", s2);
----

Если бы метод `push_str` стал владельцем `s2`, мы не смогли бы напечатать его значение в последней строке. Однако этот код работает так, как мы и ожидали!

Метод `push` принимает один символ в качестве параметра и добавляет его в `String`. В листинге 8-17 буква «l» добавляется в `String` с использованием метода push.

.Листинг 8-17: Добавление одного символа в значение String с помощью push
[source,rust]
----
    let mut s = String::from("lo");
    s.push('l');
----

В результате `s` будет содержать "lol".

===== Конкатенация с помощью оператора + и макроса format!

Часто нужно объединить две существующие строки. Один из способов сделать это — использовать оператор `+`, как показано в листинге 8.18.

.Листинг 8-18: Использование оператора + для объединения двух строковых значений в новое строковое значение
[source,rust]
----
    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = s1 + &s2; // строка s1 перемещена и больше не может использоваться
----

Строка `s3` будет содержать "Hello, world!". Причины, по которым после добавления строка `s1` больше недействительна и применена ссылка на строку `s2`, связаны с сигнатурой метода, который вызывается при использовании оператора `+`. Это метод `add`, сигнатура которого выглядит примерно так:

[source,rust]
----
fn add(self, s: &str) -> String {
----

Как мы увидим, в стандартной библиотеке `add` определен с использованием обобщенных и ассоциированных типов. В данном случае мы заменили их на конкретные типы, что делает и сам компилятор, когда видит вызов этого метода со значениями `String`. Обобщенные типы обсуждаются в Главе 10. Сигнатура метода дает нам подсказки, необходимые для понимания нюансов оператора `+`.

Во-первых, `s2` имеет префикс `&`, означающий, что мы добавляем _ссылку_ на вторую строки к первой строке. Так задан параметр `s` в функции `add`: к String можно добавить только `&str`; два значения String сложить вместе нельзя. Но подождите — тип `&s2` — это `&String`, а не `&str`, как аннотировано во втором параметре метода. Так почему листинг 8-18 компилируется?

Причина, по которой можно использовать `&s2` в вызове `add`, и о чем уже говорилось в xref:_4_3_slice_as_parameter[секции "Строковые срезы как параметры"] раздела 4.3 "Срезы" Главы 4, заключается в том, что компилятор может автоматически преобразовать аргумент `&String` в `&str`. Когда мы вызываем метод `add`, Rust использует _преобразование deref_, которое в данном случае заменяет `&s2` на `&s2[..]`. Мы обсудим это преобразование более подробно в Главе 15. Поскольку `add` не принимает владение параметром `s`, после этой операции `s2` по-прежнему будет действительным (valid) значением `String`.

Во-вторых, как видно по сигнатуре, `add` становится владельцем `self`, так как `self` _не использует_ префикс `&`. Это означает, что `s1` в листинге 8-18 будет перемещен в `add` и после этого больше не будет действительным. Итак, хотя `let s3 = s1 + &s2;` выглядит так, что он скопирует обе строки и создаст новую, на самом деле, этот оператор фактически становится владельцем `s1`, добавляет копию содержимого `s2`, а затем возвращает владение результирующим значением. Другими словами, кажется, что оператор `+` делает несколько копий, но это не так; его реализация более эффективна по сравнению с копированием.

Если нам нужно объединить несколько строк, поведение оператора + становится громоздким:

[source,rust]
----
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = s1 + "-" + &s2 + "-" + &s3;
----

в результате значение `s` будет "tic-tac-toe" (крестики-нолики). За кучей символов `+` и `+"+` трудно понять, что происходит. Для более сложного комбинирования строк вместо оператора `+` лучше использовать макрос `format!`:

[source,rust]
----
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = format!("{}-{}-{}", s1, s2, s3);
----

Этот код также устанавливает `s` в "tic-tac-toe". Макрос `format!` работает как `println!`, но вместо вывода на экран он возвращает `String` с содержимым. Версию кода, использующую `format!` читать намного легче, а код, который генерируется макросом `format!`, использует ссылки, поэтому не становится владельцем ни одного из его параметров.

==== Индексы в String

В большинстве языков программирования доступ к отдельным символам в строке путем ссылки на них по индексу является допустимой и распространенной операцией. Однако в Rust, если вы попытаетесь получить доступ к части `String`, используя синтаксис индексации, то получите сообщение об ошибке. Рассмотрим неверный код в листинге 8-19.

.Листинг 8-19: Попытка применить синтаксис индексации к String
[source,rust]
----
    let s1 = String::from("hello");
    let h = s1[0];
----

Сообщение об ошибке:

[example]
----
$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `String` cannot be indexed by `{integer}`
 --> src/main.rs:3:13
  |
3 |     let h = s1[0];
  |             ^^^^^ `String` cannot be indexed by `{integer}`
  |
  = help: the trait `Index<{integer}>` is not implemented for `String`
  = help: the following other types implement trait `Index<Idx>`:
            <String as Index<RangeFrom<usize>>>
            <String as Index<RangeFull>>
            <String as Index<RangeInclusive<usize>>>
            <String as Index<RangeTo<usize>>>
            <String as Index<RangeToInclusive<usize>>>
            <String as Index<std::ops::Range<usize>>>
            <str as Index<I>>

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections` due to previous error
----

Текст ошибка красноречиво говорит нам, что строки Rust не поддерживают индексацию. Но почему? Чтобы ответить на этот вопрос, нам нужно обсудить, как Rust хранит строки в памяти.

===== Внутреннее представление String

`String` является оберткой над `Vec<u8>`. Давайте посмотрим на некоторые из наших примеров в кодировке UTF-8 из листинга 8-14. Во-первых, этот:

[source,rust]
----
    let hello = String::from("Hola");
----

В этом случае `len` будет равно 4; это означает, что вектор, хранящий строку «Hola», имеет длину 4 байта. Каждая из этих букв занимает 1 байт в кодировке UTF-8. Однако следующая строка может вас удивить. (Обратите внимание, что эта строка начинается с буквы, а не с арабской цифры 3.)

[source,rust]
----
    let hello = String::from("Здравствуйте");
----

На вопрос, какой длины строка, вы можете сказать 12. На самом деле, правильный ответ 24: это количество байтов, необходимое для кодирования «Здравствуйте» в UTF-8, потому что каждое скалярное значение Unicode в этой строке занимает 2 байта памяти. Следовательно, индекс в байтах строки не всегда будет соответствовать действительному скалярному значению Unicode. Давайте рассмотрим вот такой недопустимый код Rust:

[source,rust]
----
let hello = "Здравствуйте";
let answer = &hello[0];
----

Мы уже знаем, что в `answer` не будет первой буквы `З`. При кодировании в UTF-8 первый байт `З` равен `208`, а второй — `151`, поэтому может показаться, что ответ на самом деле должен быть `208`, но `208` сам по себе недопустимый символ. Возврат значения `208`, скорее всего, не то, что хотел бы получить пользователь, запрашивая первую букву этой строки; однако это единственно возможное значение для байта с индексом 0. Пользователи обычно не хотят, чтобы возвращалось значение байта, даже если строка содержит только латинские буквы: если бы `&"hello"[0]` был допустимым кодом, он возвращал бы `104`, а не `h`.

Чтобы избежать возврата неожиданного значения и возникновения ошибок, которые могут быть обнаружены не сразу, Rust просто не компилирует этот код и предотвращает недопонимание на ранних этапах процесса разработки.

===== Байты, скалярные значения и кластеры графем

Еще один момент, касающийся UTF-8, заключается в том, что на самом деле с точки зрения Rust существуют три подходящих способа рассмотрения строк: как байты, как скалярные значения и как кластеры графем (наиболее близкие к тому, что мы называем _буквами_).

Слово «नमस्ते» на языке хинди, написанное письмом деванагари, хранится в виде вектора значений u8, который выглядит следующим образом:

[source,rust]
----
[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164, 224, 165, 135]
----

Это 18 байт, и именно так компьютеры в конечном итоге хранят эти данные. Если мы посмотрим на них как на скалярные значения Unicode, которые представляют собой тип `char` в Rust, эти байты будут выглядеть так:

[source,rust]
----
['न', 'म', 'स', '्', 'त', 'े']
----

Здесь шесть значений `char`, но четвертое и шестое не являются буквами: это диакритические знаки, которые сами по себе не имеют смысла. Наконец, если мы посмотрим на них как на кластеры графем, мы получим то, что человек назвал бы четырьмя буквами, составляющими слово на хинди:

[source,rust]
----
["न", "म", "स्", "ते"]
----

Rust предоставляет различные способы интерпретации необработанных строковых данных, которые хранятся в компьютерах, так что каждая программа может выбрать подходящую интерпретацию, независимо от того, что это будет значить на человеческом языке.

Последняя причина, по которой Rust не позволяет индексировать `String` для получения отдельного символа, заключается в том, что операции индексации всегда занимают постоянное время (O(1)). Но гарантировать такую производительность для значения `String` невозможно, потому что Rust пришлось бы пройтись по его содержимому от начала до нужного значения индекса, чтобы определить, сколько там допустимых символов.

==== Нарезка значений String

Как мы уже поняли, индексация строки в стиле массивов и векторов является плохой идеей, поскольку неясно, каким должен быть тип возвращаемого значения операции индексации строки: байтовое значение, символ, кластер графемы или строковый срез. Поэтому, если вам действительно нужно использовать индексы для создания строковых срезов строк, то требуется больше конкретики.

Для создания строкового среза, содержащего определенные байты, вместо индексирования с помощью оператора `[]` с одним заданным числом можно использовать оператор `[]` с заданным диапазоном:

[source,rust]
----
let hello = "Здравствуйте";

let s = &hello[0..4];
----

Здесь значением `s` будет `&str`, который содержит первые 4 байта строки. Ранее мы упоминали, что каждый из этих символов занимает 2 байта, а значит, в `s` будет строка "Зд".

Если бы мы попытались вырезать подстроку с границей, проходящей внутри символа, что-то вроде `&hello[0..1]`, код аварийно завершился бы во время выполнения так же, как если бы в векторе была выполнена попытка доступа к недопустимому индексу:

[example]
----
$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/collections`
thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`',
library/core/src/str/mod.rs:127:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
----

Диапазоны для создания строковых срезов нужно использовать с большой осторожностью, потому что это может привести к сбою вашей программы.

==== Методы перебора элементов String

Лучший способ работать с фрагментами строк — это четко указать, нужны ли вам символы или байты. Для отдельных скалярных значений Unicode следует использовать метод `chars`. Вызов `chars` для строки "Зд" выполняет ее разделение на символы и возвращает два значения типа `char`, которые уже можно перебрать в цикле `for`, чтобы получить доступ к каждому символу строки:

[source,rust]
----
for c in "Зд".chars() { // посимвольный перебор строки
    println!("{}", c);
}
----

Этот код выведет следующее:

[example]
----
З
д
----

В качестве альтернативы метод `bytes` разбивает строку на последовательность необработанных байтов; этот метод может больше соответствовать вашей прикладной области:

[source,rust]
----
for b in "Зд".bytes() { // побайтовый перебор строки
    println!("{}", b);
}
----

Этот код выведет четыре байта, составляющие эту строку:

[example]
----
208
151
208
180
----

Но обязательно помните, что действительные скалярные значения Unicode могут состоять из более чем одного байта.

Получение кластеров графем из строк, как в сценарии деванагари, является сложной задачей, поэтому эта функциональность не предоставляется стандартной библиотекой. Для этого рекомендуем попробовать найти подходящие крейты на сайте _https://crates.io/_.

==== Строки не так просты

Подводя итог, скажем — да, строки сложны. Разные языки программирования делают разные способы представить эту сложность программисту. В дизайне Rust было принято решение сделать правильную обработку данных типа `String` поведением по умолчанию, а это означает, что программисты должны заранее, еще на начальном этапе разработки, подумать об обработке данных UTF-8. Этот компромисс приводит к большей сложности работы со строками в Rust, чем в других языках программирования, но избавляет от необходимости обрабатывать ошибки, связанные с символами, отличными от ASCII, на более поздних этапах жизненного цикла разработки.

Стандартная библиотека предлагает множество функций, созданных на основе типов `String` и `&str`, которые помогают справляться с разными сложными ситуациями, возникающими при обработке строк в Rust. Обязательно ознакомьтесь в документации стандартной библиотеки с полезными методами, такими как `contains` для поиска в строке и `replace` для замены частей строки другой строкой.

Давайте переключимся на что-то менее сложное: хэшированные отображения!
