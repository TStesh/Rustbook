[#_2_2_generate_secret]
=== 2.2. Создание секретного числа

Далее нужно сгенерировать секретное число, которое пользователь попытается угадать. Чтобы в игру интересно было играть более одного раза, секретное число должно быть разным. Мы будем использовать случайное число от 1 до 100, чтобы игра не была слишком сложной. Rust не содержит (пока) в стандартной библиотеке методов для работы со случайными числами; тем не менее команда Rust предоставляет для этого крейт `rand`, доступный по адресу _https://crates.io/crates/rand_.

==== Применение крейтов для получения большей функциональности

Напомним, что крейт — это набор файлов с исходным кодом Rust. Наш проект, например, представляет собой _бинарный крейт_, который является исполняемым файлом. Крейт `rand` — это _библиотечный крейт_, который содержит код, предназначенный для использования в других программах, и не может выполняться сам по себе.

Координация внешних крейтов — это то, где Cargo действительно проявляет себя в полной мере. Прежде чем мы напишем код, использующий `rand`, нужно изменить файл _Cargo.toml_, чтобы включить крейт `rand` в качестве зависимости. Откройте этот файл и добавьте следующую строку ниже под заголовком раздела `[dependencies]`:

[example]
----
rand = "0.8.3"
----

Укажите версию `rand` в точности как в приведенной строке, иначе примеры кода в этом руководстве могут не работать или работать неправильно.

В файле _Cargo.toml_ все, что следует за заголовком раздела, является частью этого раздела, который продолжается до тех пор, пока не начнется другой раздел. В `[dependencies]` мы сообщаем Cargo, от каких внешних крейтов зависит наш проект и какие версии этих крейтов нам нужны. Мы используем крейт `rand` с семантическим спецификатором версии 0.8.3. Cargo понимает семантику управления версиями (иногда называемую _SemVer_, детально см. _http://semver.org/_), которая является стандартом нумерации версий ПО. Число `0.8.3` на самом деле является сокращением от `^0.8.3`, что означает любую версию не ниже `0.8.3`, но ниже `0.9.0`.

Cargo считает, что эти версии имеют общедоступные API, совместимые с версией `0.8.3`, и эта спецификация гарантирует, что вы получите последнюю версию исправления, которая по-прежнему будет компилироваться с кодом из этой главы. Не гарантируется, что версия `0.9.0` или любая более поздняя будет иметь тот же API, который используется в коде нашего проекта примерах.

Теперь, ничего не меняя в коде, давайте соберем проект, как показано в листинге 2-2.

--
.Листинг 2-2: Результат выполнения cargo build после добавления крейта rand в качестве зависимости

[example]
----
$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.3
  Downloaded libc v0.2.86
  Downloaded getrandom v0.2.2
  Downloaded cfg-if v1.0.0
  Downloaded ppv-lite86 v0.2.10
  Downloaded rand_chacha v0.3.0
  Downloaded rand_core v0.6.2
   Compiling rand_core v0.6.2
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.3
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
----
--

У вас могут быть другие номера версий (однако все они будут совместимы с приведенным кодом, благодаря SemVer!), другие строки (в зависимости от операционной системы) и порядок строк может отличаться от приведенного. Это нормально.

Когда мы включаем внешнюю зависимость, Cargo получает последние версии всего, что нужно для обеспечения зависимости, из _реестра_, который является копией данных с Crates.io (детально см. по адресу _https://crates.io/_). Crates.io — это онлайн-хранилище пакетов в экосистеме Rust, куда разработчики со всего мира публикуют свои проекты с открытым исходным кодом для их совместного использования.

После обновления реестра Cargo проверяет раздел `[dependencies]` и загружает все крейты из списка, если они еще не загружены. В нашем случае, хотя мы указали в зависимостях только `rand`, Cargo также загрузил другие крейты, от которых зависит работа `rand`. После загрузки крейтов Rust их компилирует, после чего компилирует проект со всеми доступными зависимостями.

Если прямо сейчас снова запустить `cargo build` без внесения каких-либо изменений, не будет никаких результатов, кроме строки `Finished`. Cargo знает, что все зависимости уже загружены и скомпилированы, в файл _Cargo.toml_ не вносилось никаких изменений. Cargo также знает, что ничего не менялось и в нашем коде, поэтому не перекомпилирует его. Так как ему просто нечего делать, он завершает свою работу.

Если открыть файл _src/main.rs_, внести тривиальное изменение, а затем сохранить его и снова собрать, то получим только две строки вывода:

[example]
----
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
----

Эти строки показывают, что Cargo обновил сборку из-за изменения файла с исходным кодом _src/main.rs_. Так как зависимости не изменились, Cargo знает, что может повторно использовать то, что для них уже скачано и скомпилировано.

===== Обеспечение воспроизводимых сборок с помощью файла Cargo.lock

У Cargo есть механизм, который гарантирует, что при пересборке одного и того же артефакта Cargo будет использовать только указанные вами версии зависимостей, пока вы не укажете иное. Например, допустим, что на следующей неделе выходит версия 0.8.4 пакета `rand`, и эта версия содержит важное исправление ошибки, но включает изменения, которые ломают ваш текущий код. Для исключения обратной несовместимости, при первом запуске `cargo build` Rust создает в каталоге _guessing_game_ файл _Cargo.lock_.

Cargo определяет при первой сборке подходящие версии всех зависимостей и затем записывает их в файл _Cargo.lock_. Когда мы будем собирать проект в следующий раз, Cargo увидит, что файл _Cargo.lock_ существует, и использует указанные там версии вместо того, чтобы заново их определять. Это позволяет получать воспроизводимую сборку (reproducible build) автоматически. Другими словами, благодаря файлу _Cargo.lock_ ваш проект останется на уровне версии `0.8.3` до тех пор, пока вы явно не измените ее. Поскольку файл _Cargo.lock_ важен для поддержки воспроизводимых сборок, его часто регистрируют в системе управления версиями вместе с остальным кодом проекта.

===== Обновление версии крейта

В случае _необходимости_ обновления крейта, можно воспользоваться командой `cargo update`, которая проигнорирует файл _Cargo.lock_ и определит последние версии зависимостей с учетом спецификации, заданной в _Cargo.toml_. Затем Cargo запишет новые номера версий в файл _Cargo.lock_. Важный нюанс - номера новых версий будут полностью удовлетворять спецификации зависимости! Покажем это на примере. В нашем проекте Cargo при выполнении `cargo update` будет искать для крейта `rand` только версии выше `0.8.3` и ниже `0.9.0`, потому что именно такую спецификацию для этого крейта мы указали в файле _Cargo.toml_. Если для `rand` выпустили две новые версии `0.8.4` и `0.9.0`, то при выполнении команды `cargo update` увидим следующее:

[example]
----
$ cargo update
    Updating crates.io index
    Updating rand v0.8.3 -> v0.8.4
----

Также будет изменен файл _Cargo.lock_, в нем будет записано, что текущая версия крейта `rand` — это `0.8.4`. Как видим, Cargo игнорирует версию `0.9.0`. Чтобы использовать `rand` версии `0.9.0` или любой версии из серии `0.9.x`, нужно обновить файл _Cargo.toml_ следующим образом:

[example]
----
[dependencies]
rand = "0.9.0"
----

При следующем выполнении команды `cargo build` Cargo обновит реестр доступных крейтов и переопределит наши требования к `rand` в соответствии с новой версией, которую мы указали.

О Cargo и его экосистеме, которую мы детальнее поговорим в Главе 14, можно сказать еще много чего интересного, но на данном этапе достаточно того, о чем мы рассказали. Cargo упрощает повторное использование библиотек, поэтому разработчики Rust могут писать небольшие проекты, собранные из нескольких пакетов. Документацию Cargo см. по ссылкам _http://doc.crates.io/_ и _http://doc.crates.io/crates-io.html_.

==== Генерация секретного числа

Давайте используем `rand` для генерации числа, которое нужно угадать. Для этого поправим код в _src/main.rs_, как показано в листинге 2-3.

--
.Листинг 2-3: Добавление кода для генерации случайного числа

Файл: src/main.rs

[source,rust]
----
use std::io;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    println!("The secret number is: {secret_number}");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {guess}");
}
----
--

Мы добавили строку `use rand::Rng`. Трейт `Rng` определяет методы с реализацией генераторов случайных чисел (ГСЧ), и его нужно включить в область действия, чтобы использовать эти методы. Трейты будут подробно рассмотрены в Главе 10.

Затем добавили в середину две строки кода. В первой строке вызываем функцию `rand::thread_rng`, которая возвращает конкретный ГСЧ; этот генератор является локальным по отношению к текущему потоку выполнения и "засевается" операционной системой. Далее у ГСЧ вызываем метод `gen_range`, который определен в добавленном в область действия трейте `Rng`. Метод принимает в качестве аргумента выражение диапазона (range) и генерирует случайное число в указанном диапазоне. Используемый здесь способ выражения диапазона имеет форму `start..=end` и включает нижнюю и верхнюю границы, поэтому нам нужно указать `1..=100` для получения случайного числа в нужном нам интервале.

[sidebar]
Заранее неизвестно, какие крейты нужно применять и какие методы и функции вызывать из крейта, поэтому каждый крейт имеет документацию с инструкциями по его использованию. Еще одна полезная функция Cargo заключается в том, что запуск команды `cargo doc --open` создаст локальную копию документации, предоставленной всеми вашими зависимостями, и откроет ее в вашем браузере. Например, если вас интересуют другие функции в контейнере `rand`, выполните `cargo doc --open` и кликните `rand` на боковой панели слева.

Вторая добавленная строка печатает секретное число. Это полезно в целях тестирования на стадии разработки программы, но, разумеется, мы удалим ее из финальной версии. Это уже не игра, если программа печатает ответ, как только запускается!

Попробуем запустить программу несколько раз:

[example]
----
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4

$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
----

Мы должны получать разные случайные числа, и все они должны быть числами от 1 до 100. Отличная работа!