=== 7.1. Пакеты и крейты

Первые компоненты модульной системы, которые мы рассмотрим, — это пакеты и крейты.

Крейт — это наименьший объем кода, который компилятор Rust рассматривает за раз. Даже если вы запустите `rustc` вместо `cargo` и передадите ему один единственный файл с исходным кодом (как мы уже делали в <<_1_2_hello_world,разделе «Написание и запуск программы на Rust»>> Главы 1), компилятор считает этот файл крейтом. Как мы увидим в следующих разделах, крейты могут содержать модули, а модули могут быть определены в разных файлах, которые компилируются вместе с крейтом.

Крейт может иметь одну из двух форм: бинарный (исполняемый) крейт или библиотечный крейт. _Бинарные крейты_ — это программы, которые можно скомпилировать в исполняемый файл и запустить, например, утилиты командной строки или сервер. В любом таком крейте должна быть функция с именем `main`, которая определяет, что происходит при запуске исполняемого файла. Все крейты, которые мы создали в предыдущих главах, были бинарными крейтами.

_Библиотечные крейты_ не имеют функции `main` и не компилируются в исполняемый файл. Вместо этого они определяют функциональность, предназначенную для совместного использования в различных проектах. Например, крейт `rand`, который применялся в xref:_2_2_generate_secret[Главе 2], обеспечивает генерацию случайных чисел. В большинстве случаев, когда опытные разработчики Rust говорят «крейт», они имеют в виду библиотечный крейт, и используют этот термин взаимозаменяемо с такой общей концепцией разработки как «библиотека».

_Корень крейта_ (crate root) — это исходный файл, являющийся [.underline]#корневым модулем вашего крейта# и с которого начинается процедура компиляция (мы подробно расскажем про модули в разделе «Определение модулей для управления областью действия и конфиденциальностью»).

_Пакет_ — это группа из одного или нескольких связанных крейтов, которая предоставляет определенную функциональность для внешнего использования. Пакет содержит файл _Cargo.toml_, в котором описывается, как собирать эти крейты. Например, Cargo — это такой же пакет с бинарным крейтом утилиты командной строки, которую вы применяете для сборки кода. Пакет Cargo также содержит библиотечный крейт, от которого зависит бинарный крейт. Другие проекты могут добавлять этот библиотечный крейт в качестве зависимости, чтобы использовать ту же самую  функциональность, что и утилита командной строки Cargo.

Пакет может содержать сколько угодно бинарных крейтов, но не более одного библиотечного крейта. Пакет должен содержать хотя бы один крейт, неважно какой — библиотечный или бинарный.

Давайте кратко пройдемся по артефактам нового пакета. Сначала вводим команду `cargo new` с именем пакета `my-project`:

[example]
----
$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
----

После выполнения `cargo new` с помощью команды `ls` смотрим, что создал Cargo. В каталоге проекта есть файл _Cargo.toml_ со спецификацией пакета. Также есть каталог _src_, который содержит _main.rs_. Откройте _Cargo.toml_ в текстовом редакторе и обратите внимание, что файл _src/main.rs_ там не упоминается. Cargo следует соглашению о том, что _src/main.rs_ — это корень бинарного крейта с тем же именем, как и у пакета. Точно так же Cargo знает, что если каталог пакета содержит файл _src/lib.rs_, то, значит, пакет содержит библиотечный крейт с тем же именем, что и пакет, а _src/lib.rs_ является корнем этого крейта. Cargo передает корневые файлы крейтов в `rustc` для сборки библиотеки или исполняемого файла.

В нашем пакете есть только файл _src/main.rs_, то есть, только один бинарный крейт с именем `my-project`. Если бы пакет содержал два файла — _src/main.rs_ и _src/lib.rs_ — то у него были бы два крейта: исполняемый файл и библиотека, оба с тем же именем, что и имя пакета. Пакет может иметь несколько бинарных крейтов с их исходными файлами в каталоге _src/bin_: каждый такой файл будет отдельным бинарным крейтом.
