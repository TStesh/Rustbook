[#_6_2_match]
=== 6.2. Конструкция match

В Rust есть очень мощная конструкция управления потоком выполнения (control flow construct) под названием `match`, которая позволяет сравнивать значение с набором образцов, а затем выполнять код на основе соответствия образцу. Образцы могут состоять из литералов, имен переменных, подстановочных знаков (wildcards) и многого другого; в Главе 18 мы рассмотрим все их разновидности и способы действия. Мощь `match` обусловлена выразительностью образцов и гарантией со стороны компилятора, что всегда обрабатываются все возможные случаи.

Выражение `match` похоже на машину для сортировки монет: монеты скользят по дорожке с отверстиями разного размера по всей ее длине, и каждая монета падает в первое подходящее по размеру отверстие. Точно так же значения проходят через каждый образец в `match`, и на первом подходящем значение попадает в связанный блок кода, который и будет далее выполняться для этого значения.

Раз уж мы упомянули монеты, давайте используем их в качестве примера применения `match`! Напишем функцию, которая берет неизвестную монету Соединенных Штатов, определяет по аналогии со счетной машиной какая это монета, и возвращает ее значение в центах, как показано в листинге 6-3.

--
.Листинг 6-3. Выражение match с вариантами перечисления в качестве образцов

[source,rust]
----
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
----
--

Давайте детально разберем, что происходит в функции `value_in_cents`. Сначала идет ключевое слово `match`, за которым следует выражение — значение `coin`. Это очень похоже на синтаксис `if`, но есть большая разница: выражение в `if` должно возвращать логическое значение, а в `match` может вычисляться в любой тип. Например, наш тип `coin` является перечислением `Coin`, определение которого приведено в первой строке.

Далее идут ветки (arms) `match`. Ветка состоит из двух частей: образца и кода. Образец в первой ветке — это значение `Coin::Penny`, затем следует оператор `+=>+`, который отделяет образец от кода. В данном случае код — это просто значение `1`. Ветка заканчивается запятой; в последней ветке запятая является опциональной.

Когда выполняется выражение `match`, происходит последовательное сравнение значения выражения с образцом в каждой ветке. Если значение соответствует образцу, выполняется код, связанный с этим образцом. В противном случае выполнение переходит к следующей ветке, как в машине для сортировки монет. Количество веток может быть любым: например, в листинге 6.3 у `match` четыре ветки.

Связанный с веткой код — это выражение, а результат этого выражения в соответствующей ветке — это значение, которое возвращается для всего выражения `match`.

Если код в ветке короткий, фигурные скобки обычно не используются, как в листинге 6-3, где каждая ветка просто возвращает значение. Если же в коде несколько строк, то фигурные скобки являются обязательными, при этом запятую в конце ветки ставить уже не нужно. Например, следующий код печатает «Lucky penny!» всякий раз, когда вызывается из ветки с образцом `Coin::Penny`, но, по-прежнему, возвращает (из блока) значение `1`:

[source,rust]
----
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
----

==== Образцы с привязкой к значениям

Еще одна полезная особенность веток `match` заключается в том, что они могут привязываться (bind) к частям значений, которые соответствуют образцу. Это позволяет извлекать значения из вариантов перечисления.

В качестве примера давайте изменим один из вариантов нашего перечисления, чтобы внутри него хранились данные. С 1999 по 2008 год в Соединенных Штатах чеканились квотеры (quarters) с разным дизайном для каждого из 50 штатов. У других монет такой особенности в дизайне не было, поэтому квотеры приобрели дополнительную стоимость. Мы можем добавить эту информацию в вариант `Quarter` нашего `enum`, включив внутрь него значение `UsState`, как показано в листинге 6-4.

--
.Листинг 6-4. Перечисление Coin, в котором вариант Quarter также содержит значение UsState.

[source,rust]
----
#[derive(Debug)] // планируем в моменте выводить штат
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
----
--

Давайте представим, что какой-то коллекционер хочет собрать все 50 квотеров каждого штата. Пока мы сортируем мелочь по типу монеты, то можем также вытаскивать название штата, связанного с каждым квотером, чтобы в случая отсутствия монеты такого штата у нашего коллекционера, он мог бы добавить ее в свою коллекцию.

Чтобы эта логика заработала, в выражении `match` нужно добавить к образцу переменную с именем `state`, который соответствует значениям варианта `Coin::Quarter`. Когда произойдет совпадение с `Coin::Quarter`, переменная `state` будет привязана к значению штата этого квотера. Далее можно использовать `state` в коде ветки совпадения, например:

[source,rust]
----
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}
----

Если вызвать `value_in_cents(Coin::Quarter(UsState::Alaska))`, то `coin` будет иметь значение `Coin::Quarter(UsState::Alaska)`. При сравнении этого значения с образцом каждой ветки совпадений не будет, пока мы не достигнем `Coin::Quarter(state)`. В этот момент к переменной `state` будет привязано значение `UsState::Alaska`. Затем можно использовать эту привязку в макросе `println!`, таким образом получая значение штата из варианта для `Quarter` перечисления `Coin` .

==== Применение match к Option<T>

В предыдущем разделе мы хотели получить внутреннее значение типа `T` из варианта `Some` при использовании `Option<T>`; `Option<T>` можно также обрабатывать с помощью `match` как и перечисление `Coin`! Вместо монет сравниваются варианты `Option<T>`, но принцип работы выражения `match` остается прежним.

Допустим, требуется написать функцию, которая принимает `Option<i32>` и, если внутри есть значение, добавляет 1 к этому значению. Если значения нет, функция должна вернуть значение `None` и не пытаться выполнять какие-либо операции.

Эту функцию очень легко написать благодаря `match`, и она будет выглядеть так, как показано в листинге 6-5.

--
.Листинг 6-5: Функция, использующая выражение match для Option<i32>

[source,rust]
----
    fn plus_one(x: Option<i32>) -> Option<i32> {
        match x {
            None => None,
            Some(i) => Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
----
--

Рассмотрим более подробное выполнение `plus_one`. Когда происходит вызов `plus_one(five)`, переменная `x` в теле `plus_one` будет иметь значение `Some(5)`. Затем выполняется последовательное сравнение этого значения с каждым образцом:

[source,rust]
----
            None => None,
----

`Some(5)` не соответствует образцу `None`, поэтому переходим к следующей ветке:

[source,rust]
----
            Some(i) => Some(i + 1),
----

Соответствует ли `Some(5)` образцу `Some(i)`? Да, у нас такой же вариант! Переменная `i` привязывается к значению, содержащемуся в `Some`, поэтому принимает значение 5. Далее выполняется код в ветке совпадения, в котором к значению `i` добавляется 1 и создается новое значение `Some` с суммой 6 внутри.

Теперь давайте рассмотрим второй вызов `plus_one`, где `x` равно `None`. Сначала происходит сравнение в первой ветке:

[source,rust]
----
            None => None,
----

Совпадение! Код останавливается и возвращает значение `None` справа от `=>`. Поскольку сработала первая ветка, остальные ветки не рассматриваются.

Сочетание `match` и перечислений полезно во многих ситуациях. В большинстве программ Rust часто применяется следующий прием: сопоставить `match` с перечислением, привязать переменную к данным внутри, а затем выполнить код с ее значением, полученным при совпадении того или иного варианта перечисления. Поначалу это кажется сложным, но как только вы к этому привыкнете, непременно захочется, чтобы такое можно было делать и во всех других языках. Этот прием является фактически стандартом в разработке Rust.

==== Полнота конструкции match

Есть еще один аспект `match`, который нам нужно обсудить: образцы во всех ветках должны охватывать все возможные варианты. Рассмотрим версию нашей функции `plus_one`, которая содержит ошибку и не компилируется:

[source,rust]
----
    fn plus_one(x: Option<i32>) -> Option<i32> {
        match x {
            Some(i) => Some(i + 1),
        }
    }
----

Ошибка заключается в том, что отсутствует обработка случая `None`. К счастью, Rust знает, как выявлять эту ошибку. Если мы попытаемся скомпилировать этот код, то получим вот такую ошибку:

[example]
----
$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
   --> src/main.rs:3:15
    |
3   |         match x {
    |               ^ pattern `None` not covered
    |
note: `Option<i32>` defined here
    = note: the matched value is of type `Option<i32>`
help: ensure that all possible cases are being handled by adding a match arm with a wildcard
 pattern or an explicit pattern as shown
    |
4   ~             Some(i) => Some(i + 1),
5   ~             None => todo!(),
    |

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` due to previous error
----

Rust знает, что мы не рассмотрели все возможные случаи, и даже знает, какой образец забыли! Конструкция `match` обладает свойством так называемой _полноты_ (_exhaustive_): чтобы код сопоставления был правильным, необходимо явным образом рассмотреть все возможные варианты сравнений. Особенно это касается перечисления `Option<T>`, в котором отсутствует обработка случая `None`; компилятор защищает нас от ситуации, когда мы можем попытаться использовать null как не null, или другими словами, от описанной ранее ошибки на миллиард долларов.

==== Всеохватные образцы и заполнитель _

При использовании перечислений есть возможность обрабатывать в ветках `match` только некоторые конкретные варианты, а для всех остальных — задавать действие по умолчанию. Представьте, что мы реализуем игру с бросанием костей (dice roll). При выпадении 3 игрок получает новую модную шляпу (fancy hat). Если выпадает 7, то теряет эту шляпу. Для всех остальных выпадений игрок перемещается на указанное количество клеток по игровому полю. Ниже приведен код `match`, который реализует эту логику, при этом результат броска костей является не случайным, жестко закодированным значением, а вся остальная логика представлена функциями без тел, так как фактическая их реализация выходит за рамки этого примера:

[source,rust]
----
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        other => move_player(other),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn move_player(num_spaces: u8) {}
----

Для первых двух веток образцы — это литералы 3 и 7. Для последней ветки, которая охватывает все остальные возможные значения, образец — это переменная с именем `other`. Код, который выполняется для ветки `other`, использует эту переменную, передавая ее в функцию `move_player`.

Этот код успешно компилируется, даже несмотря на то, что мы не перечислили все возможные значения `u8`, потому что последний образец будет соответствовать любому допустимому значению типа, не указанному явно в других ветках. Такой _всеохватный_ (_catch-all_) образец обеспечивает выполнение требования полноты `match`. Обратите внимание, ветка с этим образцом должна быть последней: образцы сопоставляются последовательно друг за другом и, если мы поместим ее раньше, до следующих после нее веток выполнение никогда не дойдет; поэтому Rust предупредит нас, если в коде ветка с всеохватным образцом не является последней!

В Rust есть возможность задать всеохватный образец без привязки к каким-либо значениям, такой образец называется _неиспользуемой переменной_. Для этого применяется синтаксис `+_+`, который является заполнителем (placeholder), соответствующим любому значению и не привязанным к этому значению. Когда Rust видит `+_+`, то знает, что текущее значение этого заполнителя нужно игнорировать, и не будет выдавать предупреждение о неиспользуемой переменной.

Применим это на практике. Для этого изменим правила игры следующим образом: теперь, если выпадает число, кроме 3 или 7, бросаем кости еще раз. Нам больше не нужно использовать значение `other` в всеохватным образце, поэтому можем заменить его на `+_+`:

[source,rust]
----
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        _ => reroll(),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn reroll() {}
----

В этом примере требование полноты сопоставления также выполнено, поскольку в последней ветке мы явно игнорируем все остальные значения; таким образом не пропущено ни одно возможное значение `dice_roll`.

Для демонстрации еще одного момента, связанного с образцом `+_+`, упростим правила игры: теперь код ничего не должен делать при выпадении любого числа, кроме 3 или 7. Для выражения этой логики в выражении `match`, используем в ветке `+_+` в качестве кода пустой кортеж `unit` (см. секцию xref:_3_2_2_1_tuples[«Кортеж»] Главы 3):

[source,rust]
----
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        _ => (),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
----

В этом коде любые значения, отличные от 3 и 7, не используются, и для таких значений отсутствует какие-либо действия в ветке неиспользуемой переменной.

Подробнее об образцах и процедуре сопоставления мы поговорим в Главе 18. А теперь давайте рассмотрим синтаксис `if let`, который полезен в ситуациях, когда выражение `match` можно записать более лаконично.
