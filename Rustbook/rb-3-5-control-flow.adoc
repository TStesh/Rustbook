=== 3.5. Управление потоком выполнения

Выполнение того или иного кода в зависимости от значения условия, или многократное выполнение одного и того же кода, пока условие истинно, являются основными конструкционными блоками в большинстве языков программирования. Наиболее распространенными конструкциями, позволяющими управлять потоком выполнения кода Rust, являются выражения `if` и циклы.

==== Выражение if

Выражение `if` позволяет разветвлять код в зависимости от заданных условий. Вы задаете условие, после чего работает следующая логика: если это условие выполнено, будет выполнен определенный блок кода; если условие не выполнено, этот блок кода не будет выполнен.

Давайте создадим в каталоге _projects_ новый проект с именем _branches_, для изучения выражения `if`. В файле _src/main.rs_ напишем следующий код:

Файл: src/main.rs

[source,rust]
----
fn main() {
    let number = 3;

    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
----

Все выражения `if` начинаются с ключевого слова `if`, за которым следует условие. В нашем случае условие проверяет, имеет ли переменная `number` значение меньше 5. Блок кода для выполнения в случае истинности условия размещается сразу после условия внутри фигурных скобок. Блоки кода, связанные с условиями в выражениях `if`, иногда называют _ветками_ (_arms_), аналогично веткам в выражениях `match`, которые мы обсуждали xref:_2_3_comparing[в разделе «Сравнение числа игрока с секретным числом»] Главы 2.

При желании также можно добавить выражение `else`, которое есть в нашем примере, чтобы дать программе альтернативный блок кода для выполнения в случае ложности условия. Если выражение `else` отсутствует и условие будет ложным, программа просто пропустит блок `if` и перейдет к следующему фрагменту кода.

Попробуем запустить этот код; должен получиться следующий вывод:

[example]
----
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was true
----

Давайте попробуем изменить значение `number` на значение, которое делает условие ложным, чтобы посмотреть, что произойдет:

[source,rust]
----
    let number = 7;
----

Запустите программу еще раз и посмотрите на вывод:

[example]
----
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was false
----

Также стоит отметить, что условие в этом коде _должно_ вычисляться в `bool`. Если условие не вычисляется в `bool`, мы получим ошибку. Например, попробуйте запустить следующий код:

Файл: src/main.rs

[source,rust]
----
fn main() {
    let number = 3;

    if number {
        println!("number was three");
    }
}
----

Теперь условие в `if` вычисляется в 3, и Rust выдает ошибку:

[example]
----
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 --> src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected `bool`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` due to previous error
----

Ошибка указывает на то, что Rust ожидал значение `bool`, но получил целое число. В отличие от таких языков, как Ruby и JavaScript, Rust не будет выполнять автоматическое преобразование не-логического типа в логический. Вы должны всегда указывать `if` с логическим значением в качестве условия. Если нужно, чтобы блок кода `if` запускался, например, только тогда, когда число не равно 0, нужно написать выражение `if` так:

Файл: src/main.rs

[source,rust]
----
fn main() {
    let number = 3;

    if number != 0 {
        println!("number was something other than zero");
    }
}
----

Запуск этого кода напечатает "number was something other than zero".

===== Обработка нескольких условий с помощью else if

Можно использовать несколько условий, комбинируя `if` и `else` в выражении `else if`. Например:

Файл: src/main.rs

[source,rust]
----
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
----

У этой программы есть четыре возможных пути. После ее запуска вы должны увидеть следующий вывод:

[example]
----
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
number is divisible by 3
----

Код по очереди проверит каждое выражение `if` и выполнит тот блок кода, для которого условие окажется верным. Обратите внимание, что хотя 6 делится на 2, мы не видим вывод "number is divisible by 2", и не видим вывод "number is not divisible by 4, 3, or 2" из блока `else`. Так происходит потому, что Rust выполнит первый же блок кода, для которого условие оказалось верным, и не станет проверять остальные ветки.

Когда выражений `else if` слишком много, они загромождают ваш код, поэтому может потребоваться его рефакторинг. В xref:_6_2_match[Главе 6] описывается используемая в таких случаях мощная конструкция ветвления `match`.

===== Использование if в инструкции let

Поскольку `if` является выражением, мы можем использовать его в правой части `let`, чтобы присвоить результат переменной, как в листинге 3-2.

--
.Листинг 3-2. Присвоение переменной результата выражения if

Файл: src/main.rs

[source,rust]
----
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {number}");
}
----
--

К переменной `number` будет привязано результирующее значение выражения `if`. Запустите этот код и посмотрите, что происходит:

[example]
----
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
The value of number is: 5
----

Напомним, что блоки кода вычисляются до последнего выражения в них, и числа сами по себе тоже являются выражениями. Значение выражения `if` зависит от того, какой блок кода в нем выполнится. Поэтому значения, которые потенциально являются результатом каждой ветки условного выражения, должны быть одного типа. Так, в листинге 3-2 результат как ветки `if`, так и результат ветки `else` являются целыми числами `i32`. Если типы не совпадают, как в следующем примере, получим ошибку компиляции:

Файл: src/main.rs

[source,rust]
----
fn main() {
    let condition = true;

    let number = if condition { 5 } else { "six" };

    println!("The value of number is: {number}");
}
----

При попытке компиляции этого кода получим ошибку. Ветки `if` и `else` имеют несовместимые типы значений, и Rust точно указывает, где в программе искать проблему:

[example]
----
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: `if` and `else` have incompatible types
 --> src/main.rs:4:44
  |
4 |     let number = if condition { 5 } else { "six" };
  |                                 -          ^^^^^ expected integer, found `&str`
  |                                 |
  |                                 expected because of this

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` due to previous error
----

Выражение в блоке `if` вычисляется в целое число, а выражение в блоке `else` вычисляется в строку. Так работать не будет, потому что переменные должны быть одного типа, и время компиляции нужно точно знать, к какому типу относится переменная `number`. Знание типа `number` позволяет компилятору проверить корректность использования `number` в любом месте программы. Rust не смог бы этого сделать, если бы тип `number` определялся только во время выполнения; если же пытаться отслеживать несколько возможных типов для любой переменной, это увеличит сложность компилятора и снизит гарантии безопасности кода.

==== Циклы

Часто бывает полезно выполнить один и тот же блок кода более одного раза. Для этого Rust предоставляет несколько вариантов _циклов_ (_loops_), которые будут выполнять код внутри своего тела нужное вам количество раз. Давайте создадим новый проект под названием _loops_ для экспериментов с циклами.

В Rust есть три вида циклов: `loop`, `while` и `for`. Давайте познакомимся с каждым.

[#_3_5_loop]
===== Повторение кода с помощью loop

Ключевое слово `loop` вынуждает Rust выполнять блок кода снова и снова до бесконечности или до тех пор, пока вы явно не скажете ему остановиться. Измените файл _src/main.rs_ в каталоге _loops_ следующим образом:

Файл: src/main.rs

[source,rust]
----
fn main() {
    loop {
        println!("again!");
    }
}
----

Когда мы запустим эту программу, то увидим, что слово `again!` печатается снова и снова, пока не остановим программу вручную. Большинство консолей поддерживают сочетание клавиш kbd:[Ctrl] и kbd:[C] для прерывания программы, застрявшей в вечном цикле. Попробуем еще раз, но сразу остановим выполнение, нажав kbd:[Ctrl+C]:

[example]
----
$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29s
     Running `target/debug/loops`
again!
again!
again!
again!
^Cagain!
----

Символ `^C` показывает, где вы нажали kbd:[Ctrl+C]. В зависимости от того, в какой точке цикла находился код при получении сигнала прерывания, вы либо увидите, либо нет, слово `again!` после `^C`.

К счастью, Rust предоставляет способ с помощью кода выйти из такого цикла. Вы можете поместить ключевое слово `break` в цикл, чтобы указать программе, когда прекратить выполнение цикла. Вспомните, что мы использовали этот способ в игре в угадайку в xref:_2_4_looping[разделе «Выход после правильного предположения»] Главы 2, чтобы выйти из программы, когда пользователь вводит правильное число.

В программе игры также использовалось ключевое слово `continue`, которое вынуждает Rust пропустить весь оставшийся код в текущей итерации цикла и немедленно перейти к следующей итерации.

===== Возврат значений из циклов

Одним из применений `loop` является повторение операции с проверкой успешности ее завершения, например, завершил ли поток (thread) свою работу (job). Также может потребоваться передать результат этой операции из цикла в остальную часть вашего кода. Для этого достаточно добавить возвращаемое значение после ключевого слова `break`, которое используется для выхода из цикла, как, например, показано здесь:

Файл: src/main.rs

[source,rust]
----
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {result}");
}
----

Перед циклом мы объявляем переменную с именем `counter` и инициализируем ее значением 0. Затем объявляем переменную с именем `result` для хранения значения, возвращаемого из цикла. На каждой итерации цикла добавляем 1 к `counter`, а затем проверяем, равен ли `counter` значению 10. Как только это происходит, используем ключевое слово `break` со значением `counter * 2`. После цикла используем точку с запятой, чтобы закончить инструкцию, который присваивает значение `result`. Наконец, печатаем значение `result`, которое в данном случае равно 20.

===== Метки циклов для устранения неоднозначности между несколькими циклами

В случае вложенных циклов выражения `break` и `continue` применяются к самому внутреннему циклу во вложении. При желании можно использовать _метку цикла_ и задавать ее в выражениях `break` и `continue` для указания на помеченный цикл, к которому их нужно применять вместо самого внутреннего цикла. Метки цикла должны начинаться с одинарной кавычки. Вот пример с двумя вложенными циклами:

[source,rust]
----
fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {count}");
        let mut remaining = 10;

        loop {
            println!("remaining = {remaining}");
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {count}");
}
----

Переменная `count` пробегает значения от 0 до 2 во внешнем цикле с меткой `counting_up`. Во внутреннем цикле (без метки) переменная `remaining` пробегает значения от 10 до 9. Первый `break` без метки будет прерывать внутренний цикл. Второй `break` с меткой `'counting_up` будет прерывать внешний цикл. Этот код выведет:

[example]
----
$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.58s
     Running `target/debug/loops`
count = 0
remaining = 10
remaining = 9
count = 1
remaining = 10
remaining = 9
count = 2
remaining = 10
End count = 2
----

[#_3_5_while]
===== Условные циклы while

Программе часто требуется следующее поведение: в цикл добавляется условие; пока условие истинно, цикл выполняется, в противном случае, когда условие перестает быть истинным, программа вызывает `break`, который прерывает цикл. Подобное поведение можно реализовать, комбинируя `loop`, `if`, `else` и `break`; можете попробовать сами, если хотите. Однако это поведение настолько распространено, что в Rust для него есть встроенная языковая конструкция, называемая циклом `while`. В листинге 3-3 мы используем `while`, чтобы запустить программу три раза, каждый раз считая в обратном порядке, а затем, после цикла, вывести сообщение и выйти.

--
Файл: src/main.rs

.Листинг 3-3: Использование цикла while для выполнения кода, пока верно условие его выполнения

[source,rust]
----
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{number}!");

        number -= 1;
    }

    println!("LIFTOFF!!!");
}
----
--

Эта конструкция устраняет большое количество вложений, необходимых при использовании `loop`, `if`, `else` и `break`, и делает код более чистым (clearer). Пока условие выполняется, код работает; в противном случае цикл прекращается.

[#_3_5_for]
===== Перебор коллекции с помощью for

Можно использовать конструкцию `while` для циклического перебора элементов коллекции, к примеру массива. Например, цикл в листинге 3-4 выводит каждый элемент массива `a`.

--
.Листинг 3-4: Перебор элементов коллекции с использованием цикла while

Файл: src/main.rs

[source,rust]
----
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}
----
--

Этот код последовательно перебирает элементы массива от первого до последнего. Он начинает с индекса 0, а затем в цикле, увеличивает индекс на 1, пока не достигнет последнего индекса в массиве, то есть, когда условие `index < 5` становится ложным. При выполнении кода будет напечатан каждый элемент массива:

[example]
----
$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/loops`
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
----

Как и ожидалось, все пять значений массива появляются в консоли. Несмотря на то, что в какой-то момент `index` достигнет значения 5, выполнение цикла прекращается до того, как он попытается получить шестое значение из массива.

Однако этот подход подвержен ошибкам; мы можем вызвать панику в программе, если значение индекса или проверяемое условие неверны. Например, если изменить определение массива на четыре элемента, но забыть изменить условие на `while index < 4`, то это гарантированно приведет к панике. Помимо этого, такой код еще и медленный, потому что Rust, как уже говорилось, добавляет дополнительный код (runtime code) для выражения `[index]`, который на этапе выполнения программы будет проверять на каждой итерации цикла, находится ли индекс в границах массива.

В качестве более краткой и быстрой альтернативы вы можете использовать цикл `for`, внутри которого выполнять нужный код для каждого элемента в коллекции. Пример цикла `for` показан в листинге 3-5.

--
.Листинг 3-5: Перебор элементов коллекции с помощью цикла for

Файл: src/main.rs

[source,rust]
----
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {element}");
    }
}
----
--

При запуске этого кода увидим тот же вывод, что и в листинге 3-4. Что еще более важно, теперь мы повысили безопасность кода и устранили вероятность ошибок, которые могут возникнуть в результате выхода за пределы массива или некорректного перехода и пропуска некоторых элементов.

При использовании цикла `for` не нужно будет помнить об изменении какого-либо другого кода, если вы поменяете количество значений в массиве, как в случае с кодом в листинге 3-4.

Безопасность и лаконичность циклов `for` делают их наиболее часто используемой конструкцией цикла в Rust. Даже в ситуациях, когда нужно запустить некоторый код определенное количество раз, как в примере с обратным отсчетом, в котором использовался цикл `while` в листинге 3-3, большинство опытных разработчиков Rust применили бы цикл `for`. В этом случае требуется тип `Range` (диапазон), предоставляемый стандартной библиотекой, который генерирует коллекцию с последовательностью чисел, начиная с одного заданного числа и заканчивая другим заданным числом.

Вот как будет выглядеть обратный отсчет с использованием цикла `for` и метода `rev` (сокращение от reverse), используемого для получения элементов коллекции в обратном порядке ("обращения" коллекции):

Файл: src/main.rs

[source,rust]
----
fn main() {
    for number in (1..4).rev() {
        println!("{number}!");
    }
    println!("LIFTOFF!!!");
}
----

Этот код немного лучше, не так ли?
