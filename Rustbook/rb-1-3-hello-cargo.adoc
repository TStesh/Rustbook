=== 1.3. Hello, Cargo!

Cargo — это система сборки Rust и пакетный менеджер. Большинство разработчиков Rust использует Cargo для управления своими проектами на Rust, потому что Cargo берет на себя выполнение многих рутинных задач, таких как сборка кода, загрузка и сборка зависимостей. _Зависимостями_ называются библиотеки, которые необходимы для корректной работы кода.

Самые простые программы на Rust, типа «Hello, world!», не имеют никаких зависимостей. При применении Cargo в проекте без зависимостей используется только та часть Cargo, которая занимается сборкой вашего кода. При написании более сложных программ на Rust без зависимостей не обойтись, и лучше сразу начинать использовать Cargo, чтобы упростить их добавление по мере работы над проектом.

Поскольку подавляющее большинство реальных проектов на Rust используют Cargo, в оставшейся части книги предполагается, что вы тоже применяете Cargo. Если установка Rust была выполнена в соответствии с xref:_1_1_installation[разделом 1.1] этой главы, то Cargo инсталлирован в вашей системе вместе с Rust. В случае иных вариантов установки Rust, для проверки наличия Cargo введите в консоли следующую команду:

 $ cargo --version

Если будет выведен номер версии, то Cargo установлен! Если же вы получите ошибку, например, "command not found", обратитесь к документации по установке, чтобы узнать, как отдельно инсталлировать Cargo.

==== Создание проекта с Cargo

Давайте создадим новый проект с помощью Cargo и посмотрим, чем он отличается от нашего исходного проекта "Hello, world!". Вернитесь в каталог _projects_ (или туда, где вы решили сохранить свой код). Затем в любой ОС выполните команды:

[example]
----
$ cargo new hello_cargo
$ cd hello_cargo
----

Первая команда создает новый каталог и проект с именем _hello_cargo_. Мы назвали наш проект `hello_cargo`, и Cargo создает свои файлы в каталоге с тем же именем.

Перейдите в каталог _hello_cargo_ и посмотрите какие там есть файлы. Вы увидите, что Cargo создал два файла и один каталог: файл _Cargo.toml_ и каталог _src_ с файлом _main.rs_ внутри.

Помимо этого Cargo также инициализировал новый репозиторий Git вместе с файлом _.gitignore_. Если запустить `cargo new` с уже существующим репозиторием Git, файлы Git создаваться не будут; это поведение можно переопределить, используя команду `cargo new --vcs=git`.

[sidebar]
Git — это распространенная система контроля версий. В команде `cargo new` можно или вообще не использовать или, применяя флаг `--vcs`, использовать нужную вам систему контроля версий. Для просмотра доступных опций выполните команду `cargo new --help`

Откройте _Cargo.toml_ в любом текстовом редакторе. Он должен выглядеть аналогично коду в листинге 1-2.

--
.Листинг 1-2: Содержимое файла _Сargo.toml_, созданного командой cargo new

Filename: Cargo.toml

[source,toml]
----
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

[dependencies]
----
--

Этот файл имеет формат TOML (_Tom’s Obvious, Minimal Language_, детальное описание см. по ссылке _https://toml.io_), и в нем задается конфигурация Cargo.

Первая строка `[package]` — это заголовок раздела; после этого заголовка следуют операторы конфигурации пакета. Следующие три строки задают информацию о конфигурации, необходимую Cargo для компиляции вашей программы: наименование, версию и используемую редакцию Rust. Мы поговорим о ключевом слове `edition` в Приложении E.

Последняя строка, `[dependencies]`, — это начало раздела, в котором вы можете перечислить любые зависимости вашего проекта. В Rust пакеты кода называются крейтами (crates). Сейчас в нашем проекте дополнительные крейты не нужны, но они понадобятся в первом проекте в xref:_chapter_2[Главе 2], вот тогда мы и используем эту секцию.

При необходимости в этот файл будут добавляться и другие разделы.

Теперь откройте _src/main.rs_, вы увидите следующий текст:

Файл: src/main.rs

[source,rust]
----
fn main() {
    println!("Hello, world!");
}
----

Как видим, Cargo автоматически сгенерировал программу «Hello, world!», текстуально идентичную нашей программе в листинге 1-1! Кроме генерации программы «Hello, world!», Cargo создал файл main.rs с кодом этой программы в каталоге _src_, и добавил в корневой каталог проекта конфигурационный файл _Cargo.toml_.

Cargo ожидает, что ваши исходные файлы будут находиться в каталоге _src_. Корневой каталог проекта предназначен только для файлов README, информации о лицензии, конфигурационных файлов и всего, что не связано с вашим кодом напрямую. Cargo помогает вам правильно организовать ваш проект. Для всего есть место, и все на своих местах.

Если вы создали проект без Cargo, то можете преобразовать его в проект с Cargo. Для этого переместите код проекта в каталог _src_ и создайте в корневом каталоге проекта соответствующий файл _Cargo.toml_.

==== Создание и запуск проекта с Cargo

Теперь давайте посмотрим что происходит, когда мы создаем и запускаем программу «Hello, world!» с применением Cargo. Перейдите в каталог _hello_cargo_ и запустите сборку проекта с помощью следующей команды:

[example]
----
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
----

Эта команда компилирует исходный код проекта и создает исполняемый файл _target/debug/hello_cargo_ (или _target\debug\hello_cargo.exe_ в ОС Windows) в каталоге _target/debug/_ (_target\debug\_ в ОС Windows), а не в вашем текущем каталоге. Запуск исполняемого файла выполняется стандартным для ОС способом:

В ОС Linux или MacOS

[example]
----
$ ./target/debug/hello_cargo
Hello, world!
----

В ОС Windows

[example]
----
> .\target\debug\hello_cargo.exe
Hello, world!
----

Если все сделано правильно, в консоль должен быть выведен текст «Hello, world!». При первом выполнении команды `cargo build` Cargo создает в корневом каталоге проекта новый файл: _Cargo.lock_. Этот файл отслеживает точные версии зависимостей вашего проекта. В нашем проекте пока нет никаких зависимостей, поэтому файл пустой. Изменять содержимое _Cargo.lock_ вручную нет никакой необходимости; это делает в автоматическом режиме сам Cargo.

Итак, с помощью `cargo build` мы собрали проект и запустили исполняемый файл _./target/debug/hello_cargo_. Однако, есть возможность сделать это одним действием, используя команду `cargo run`, которая позволяет собрать проект и сразу запустить полученный исполняемый файл из каталога _./target/debug/_:

[example]
----
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
----

Команда `cargo run` удобнее, чем `cargo build`, так как во втором случае для запуска исполняемого файла нужно вводить отдельную команду с указанием полного пути до этого файла, что не всегда удобно и поэтому большинство разработчиков Rust предпочитают использовать `cargo run`, а не `cargo build`.

Обратите внимание, что на этот раз не было сообщения о компиляции `hello_cargo`. Cargo выяснил, что файлы не изменились, поэтому не стал пересобирать проект, а просто запустил исполняемый файл. Если бы исходный код изменился (вы можете это сделать прямо сейчас), Cargo пересобрал бы проект перед его запуском, и тогда мы получили бы следующий вывод:

[example]
----
$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
----

У Cargo есть еще полезная команда `cargo check`, которая делает сборку проекта без создания исполняемого файла:

[example]
----
$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
----

Почему может быть не нужен исполняемый файл? Часто команда `cargo check` выполняется намного быстрее, чем `cargo build`, потому что она пропускает этап создания исполняемого файла. Если в процессе разработки вам нужно часто проверять код на отсутствие ошибок компиляции, с помощью `cargo check` это можно делать быстрее всего. Большинство разработчиков Rust использует `cargo check` для оперативной проверки работоспособность кода; и только когда нужен исполняемый файл, тогда применяет `cargo build`.

Давайте подытожим, что на текущий момент узнали о возможностях Cargo:

* `cargo new` создает новый проект.
* `cargo build` выполняет сборку проекта.
* `cargo run` выполняет сборку проекта с запуском исполняемого файла.
* `cargo check` выполняет сборку проекта без создания исполняемого файла.
* Cargo сохраняет результат сборки в каталоге _target/debug_, а не в каталоге, где находится исходный код.

Дополнительным преимуществом Cargo является то, что его команды одинаковы независимо от того, в какой ОС вы работаете. С данного момента мы больше не будем предоставлять инструкции для Linux, macOS и отдельно Windows, а работать только с командами Cargo.

==== Релизная сборка

Когда ваш проект будет готов к выпуску чистовой версии программы, вы можете использовать команду `cargo build --release` для его сборки с включением всех возможных оптимизаций в компиляторе Rust (такая сборка называется "релизной"). Команда создаст исполняемый файл в каталоге _target/release_ вместо каталога _target/debug_. Оптимизации ускоряют работу кода, но их включение увеличивает время, необходимое для компиляции кода.

Релизная сборка выделена в отдельную опцию Cargo, потому что есть два профильных режима работы в Rust: один — это разработка проекта, когда требуются быстрые и частые повторные сборки, другой — это завершение проекта, когда нужно собрать окончательную программу, которая должна работать настолько быстро, насколько это возможно. Если нужно измерить производительность вашего кода, обязательно соберите его командой `cargo build --release` и выполните все необходимые тесты, запуская исполняемый файл из каталога _target/release_, а не _target/debug_.

==== Cargo как конвенция

В простых проектах Cargo не дает большей пользы по сравнению с `rustc`, но его ценность возрастает по мере увеличения сложности вашей программы. В реальных проектах, состоящих из нескольких крейтов, гораздо проще координировать сборку с помощью Cargo, чем делать это вручную с `rustc`.

Несмотря на то, что проект `hello_cargo` прост, теперь он использует большую часть реальных инструментов, которые вы будете применять в профессиональной разработке на Rust. На самом деле, в большинстве случаев работа по сборке реальных проектов Rust сводится к трем действиям: скопировать код проекта из репозитория Git в локальный каталог проекта, перейти в этот каталог и выполнить сборку проекта. Пример выполняемых команд:

[example]
----
$ git clone example.org/someproject
$ cd someproject
$ cargo build
----

Для получения дополнительной информации о Cargo ознакомьтесь с его документацией по ссылке _https://doc.rust-lang.org/cargo/_.
