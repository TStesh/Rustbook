[#_6_3_if_let]
=== 6.3. Упрощение управления потоком выполнения с помощью if let

Синтаксис `if let` позволяет комбинировать `if` и `let` в тех случаях, когда выражение `match` содержит два образца, причем последний является универсальным без привязки к значению; то есть, фактически, сопоставление сводится к проверке одного образца. Рассмотрим программу в листинге 6-6, которая проверяет значение `Option<u8>` в переменной `config_max`, но выполняет код только в том случае, если значение является вариантом `Some`.

--
.Листинг 6-6. Выражение match, которое выполняет код только в случае Some

[source,rust]
----
    let config_max = Some(3u8);
    match config_max {
        Some(max) => println!("The maximum is configured to be {}", max),
        _ => (),
    }
----
--

Если значение перечисления `Option` равно `Some`, мы печатаем присоединенное к варианту `Some` значение, привязывая его к переменной `max` в образце. При этом мы не хотим ничего делать со значением `None`. Чтобы удовлетворить всем требованиям выражения `match`, нам нужно добавить ветку с всеохватным образцом `+_ => ()+` после обработки только одного варианта; такой код является шаблонным и его нужно убирать.

Используя `if let`, код можно написать короче. Следующий код ведет себя так же, как `match` в листинге 6-6:

[source,rust]
----
    let config_max = Some(3u8);
    if let Some(max) = config_max {
        println!("The maximum is configured to be {}", max);
    }
----

Синтаксис `if let` состоит из образца и выражения, разделенных знаком равенства. Он работает так же, как `match`, где выражение указывается сразу после `match`, а образец является первой веткой. В нашем случае образцом является `Some(max)`, а `max` привязывается к значению внутри `Some`. Далее можно использовать `max` в теле блока `if let` так же, как и `max` в соответствующей ветке выражения `match`. Код в блоке `if let` не запускается, если значение не соответствует образцу.

Другими словами, можно рассматривать `if let` как "синтаксический сахар" для выражения `match`, которая выполняет код, когда значение соответствует одному образцу, и игнорирует все остальные значения.

Использование `if let` означает меньше ввода, меньше отступов и меньше "пустого" кода. Однако при этом теряется возможность явного использования произвольных веток сопоставления, которую предоставляет `match`. Выбор между `match` и `if let` зависит от конкретной ситуации, и от того, является ли краткость кода подходящим компромиссом для отказа от функциональности `match`.

Можно добавить `else` к `if let`. Блок кода, который идет с `else`, эквивалентен блоку кода в ветке отсутствующего значения `+_+` выражения `match`. Вспомним определение перечисления `Coin` в листинге 6-4, где вариант `Quarter` также содержит значение `UsState`. Если бы нам было нужно посчитать количество наличных монет, не являющихся квотерами, а также печатать штат каждого квотера, то это можно было бы сделать с помощью выражения `match`:

[source,rust]
----
    let mut count = 0;
    match coin {
        Coin::Quarter(state) => println!("State quarter from {:?}!", state),
        _ => count += 1,
    }
----

Или использовать выражение `if let` и `else`:

[source,rust]
----
    let mut count = 0;
    if let Coin::Quarter(state) = coin {
        println!("State quarter from {:?}!", state);
    } else {
        count += 1;
    }
----
