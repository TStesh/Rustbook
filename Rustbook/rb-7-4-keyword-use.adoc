[#_7_4_keyword_use]
=== 7.4. Введение путей в область действия с помощью ключевого слова use

Необходимость постоянно указывать полные пути к вызываемым функциям, особенно когда таких вызовов много, может сильно раздражать. В листинге 7-7 независимо от того, какой указывался путь к функции `add_to_waitlist` — абсолютный или относительный — каждый раз, когда нужно было вызвать эту функцию, приходилось также указывать модули `front_of_house` и `hosting`. К счастью, есть способ упростить этот процесс: мы можем один раз с помощью ключевого слова `use` создать ярлык (shortcut) пути, а затем использовать этот ярлык везде в области действия.

В листинге 7-11 модуль `crate::front_of_house::hosting` размещается в области действия функции `eat_at_restaurant`, поэтому для вызова функции `add_to_waitlist` в функции `eat_at_restaurant` достаточно только указать ярлык `hosting::add_to_waitlist`.

--
.Листинг 7-11: Введение модуля в область действия посредством use

Файл: src/lib.rs

[source,rust]
----
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
----
--

Добавление `use` и пути в область действия аналогично созданию символической ссылки в файловой системе. После добавления инструкции `use crate::front_of_house::hosting` в корень крейта имя `hosting` можно использовать в корневой области действия, как если бы модуль `hosting` был там и определен. Пути, вводимые в область действия инструкцией `use`, точно также проверяются на соблюдение правил доступа, как и любые другие пути.

Обратите внимание, что `use` создает ярлык только для той области действия, в которой указан. В листинге 7.12 функция `eat_at_restaurant` перемещена в новый дочерний модуль с именем `customer`, область действия которого отличается от области действия инструкции `use`, поэтому код компилироваться не будет:

--
.Листинг 7-12: Инструкция use применяется только в той области действия, в которой он находится

Файл: src/lib.rs

[source,rust]
----
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

mod customer {
    pub fn eat_at_restaurant() {
        hosting::add_to_waitlist();
    }
}
----
--

Ошибка компилятора показывает, что ярлык нельзя использовать в модуле `customer`:

[example]
----
$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0433]: failed to resolve: use of undeclared crate or module `hosting`
  --> src/lib.rs:11:9
   |
11 |         hosting::add_to_waitlist();
   |         ^^^^^^^ use of undeclared crate or module `hosting`

warning: unused import: `crate::front_of_house::hosting`
 --> src/lib.rs:7:5
  |
7 | use crate::front_of_house::hosting;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

For more information about this error, try `rustc --explain E0433`.
warning: `restaurant` (lib) generated 1 warning
error: could not compile `restaurant` due to previous error; 1 warning emitted
----

Обратите внимание на предупреждение о том, что `use` не используется в своей области действия (`warning: unused import: `crate::front_of_house::hosting``)! Для решения этой проблемы переместите `use` в модуль `customer` или сошлитесь в этом модуле на ярлык в родительском модуле с помощью `super::hosting`.

==== Создание идиоматических путей с помощью use

В листинге 7-11 вы могли задаться вопросом, почему мы указали `use crate::front_of_house::hosting`, а затем в функции `eat_at_restaurant` вызвали `hosting::add_to_waitlist`  вместо того, чтобы в `use` указать полный путь к функции `add_to_waitlist` для получения того же результата; этот вариант показан в листинге 7-13.

--
.Листинг 7-13: Добавление функции add_to_waitlist в область видимости с помощью инструкции use

Файл: src/lib.rs

[source,rust]
----
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
}
----
--

Хотя и в листинге 7-11, и в листинге 7-13 выполняется одна и та же задача, листинг 7-11 представляет собой идиоматический способ ввести функцию в область действия. Использование родительского модуля функции в области действия означает, что мы должны указать родительский модуль при вызове функции. Указание родительского модуля при вызове функции дает понять, что функция не определена локально, и при этом сводит к минимуму повторение полного пути. В листинге 7-13 неясно, где определяется функция `add_to_waitlist`.

С другой стороны, при вводе в область действия структур, перечислений и других элементов идиоматично указывать в `use` полный путь. В листинге 7-14 показан идиоматический способ переноса структуры `HashMap` из стандартной библиотеки в область действия бинарного крейта.

--
.Листинг 7-14. Включение HashMap в область действия идиоматическим способом

Файл: src/lib.rs

[source,rust]
----
use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
----
--

Для этой идиомы нет серьезной причины: это просто сложившееся соглашение, и разработчики привыкли именно таким образом читать и писать код на Rust.

Исключением из этой идиомы является ситуация, когда с помощью инструкций `use` мы попытаемся поместить в область действия два элемента с одинаковыми именами — Rust просто не позволит этого сделать. В листинге 7-15 показано, как включить в область действия два типа `Result` с одинаковыми именами, но разными родительскими модулями, и как на них ссылаться.

--
.Листинг 7-15. Для того чтобы два типа с одинаковыми именами попали в одну область действия, необходимо использовать их родительские модули

Файл: src/lib.rs

[source,rust]
----
use std::fmt;
use std::io;

fn function1() -> fmt::Result {
    // --snip--
    Ok(())
}

fn function2() -> io::Result<()> {
    // --snip--
    Ok(())
}
----
--

Такое использование родительских модулей позволяет различить два типа `Result`. Если вместо этого мы укажем `use std::fmt::Result` и `use std::io::Result`, то в одной области действия окажутся два типа с одинаковым именем `Result`, и Rust не будет знать, какой из них имеется в виду при использовании конкретного экземпляра `Result`.

==== Создание новых имен в области действия с помощью ключевого слова as

У проблемы переноса двух типов с одинаковыми именами в одну и ту же область действия с помощью инструкции `use` есть и еще одно решение: после пути мы можем указать `as` и новое локальное имя или _псевдоним_ (_alias_) для типа. В листинге 7-16 показан другой способ переписать код из листинга 7-15 с помощью переименования одного из двух типов `Result` посредством `as`.

--
.Листинг 7-16. Переименование типа с помощью ключевого слова as при его переносе в область действия

Файл: src/lib.rs

[source,rust]
----
use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -> Result {
    // --snip--
    Ok(())
}

fn function2() -> IoResult<()> {
    // --snip--
    Ok(())
}
----
--

Во второй инструкции `use` мы задали новое имя `IoResult` для типа `std::io::Result`, которое не будет конфликтовать с типом `Result` из `std::fmt`, который мы также включили в область действия. Листинги 7-15 и 7-16 считаются идиоматическими, так что выбор за вами!

==== Реэкспорт имен с помощью pub use

Когда имя размещается в области действия с помощью ключевого слова `use`, оно по умолчанию является закрытым. Чтобы позволить коду, который вызывает наш код, ссылаться на это имя, как если бы оно было определено в области действия нашего кода, мы можем объединить `pub` и `use`. Эта техника называется _реэкспортом_ (_re-exporting_), потому что мы не только вносим элемент в область действия, но и делаем этот элемент доступным для размещения в других областях действия.

В листинге 7-17 показан код из листинга 7-11, где `use` в корневом модуле изменен на `pub use`.

--
.Листинг 7-17. Предоставление имени для использования в новой области действия с помощью pub use

Файл: src/lib.rs

[source,rust]
----
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
----
--

До этого изменения внешний код должен был вызывать функцию `add_to_waitlist`, используя полный путь `restaurant::front_of_house::hosting::add_to_waitlist()`. Теперь после реэкспорта `hosting` из корневого модуля с помощью `pub use`, внешний код может вместо полного пути использовать более короткий путь `restaurant::hosting::add_to_waitlist()`.

Реэкспорт полезен, когда внутренняя структура вашего кода отличается от внешнего представления программистами-пользователями кода его предметной области. Например, в нашей метафоре ресторана его работники знают о существовании фронт- и бэк-хауса. Но посетителям ресторана, вероятно, об этом ничего неизвестно и они не могут думать о его работе в таких терминах. Благодаря `pub use` мы можем разрабатывать наш код с одной структурой, но показывать внешним пользователям другую структуру (_Примечание переводчика: то есть `pub use` позволяет скрыть детали реализации предметной области программы_). Благодаря этому наша библиотека будет хорошо организована как для программистов, работающих над библиотекой, так и для программистов, использующих библиотеку в своих программах. В разделе «Экспорт удобного открытого API с помощью pub use» Главы 14 мы рассмотрим еще один пример использования `pub use` и обсудим его влияние на документацию вашего крейта.

==== Использование внешних пакетов

В Главе 2 мы запрограммировали игру в угадайку, в которой для получения случайных чисел использовался внешний пакет `rand`. Чтобы применить `rand` в нашем проекте, мы добавили эту строку в _Cargo.toml_:

Файл: Cargo.toml

[source,toml]
----
rand = "0.8.3"
----

После добавления `rand` как зависимости в _Cargo.toml_ Cargo загрузит пакет `rand` и все его зависимости с сайта _https://crates.io/_ и обеспечит возможность использования `rand` в нашем проекте.

Чтобы внести определения пакета `rand` в область действия нашего кода, мы добавили строку с `use`, в которой указали имя `rand` и перечислили элементы, которые хотели бы перенести в область действия. Напомним, что в xref:_2_2_generate_secret[разделе «Генерация случайного числа»] Главы 2 в область действия были перенесены трейт `Rng` и функция `rand::thread_rng`:

[source,rust]
----
use rand::Rng;

fn main() {
    let secret_number = rand::thread_rng().gen_range(1..=100);
}
----

Благодаря усилиям сообщества Rust на сайте _https://crates.io/_ размещено большое количество пакетов для внешнего использования, и добавление любого из них в ваш пакет включает в себя те же самые шаги: добавление как зависимости в файл _Cargo.toml_ проекта и применение `use` для переноса элементов из внешнего крейта в область действия нашего кода.

Обратите внимание, что стандартная библиотека `std` также является крейтом, внешним по отношению к нашему пакету. Поскольку стандартная библиотека поставляется с языком Rust, для включения `std` изменять _Cargo.toml_ не нужно. Но для внесения элементов стандартной библиотеки в область действия нашего пакета использовать инструкцию `use` с указанием имени `std` и списком необходимых элементов необходимо. Например, для коллекции `HashMap` мы бы написали такую строку:

[source, rust]
----
use std::collections::HashMap; <1>
----

<1> Это абсолютный путь, так как начинается с `std`, имени крейта стандартной библиотеки.

==== Использование вложенных путей в инструкции use для сокращения длинных списков элементов

Если мы используем несколько элементов, определенных в одном крейте или в одном модуле, перечисление каждого элемента в отдельной строке может занять много вертикального пространства в наших файлах. Например, две инструкции `use`, которые мы использовали в листинге 2-4, переносят элементы из std в область действия:

Файл: src/main.rs

[source,rust]
----
// --snip--
use std::cmp::Ordering;
use std::io;
// --snip--
----

Вместо этого можно использовать вложенные пути, чтобы объединить одни и те же элементы в одну строку. Это делается следующим образом: указывается общая часть пути, затем следуют двойное двоеточие, далее фигурные скобки, внутри которых приводится список различающихся частей путей, как показано в листинге 7-18:

--
.Листинг 7-18. Указание вложенного пути для переноса нескольких элементов с одинаковым префиксом в область действия

Файл: src/main.rs

[source,rust]
----
// --snip--
use std::{cmp::Ordering, io};
// --snip--
----
--

В более крупных программах перенос множества элементов в область действия из одного и того же крейта или модуля с использованием вложенных путей может значительно сократить количество необходимых инструкций `use`!

Разрешается применять вложенный путь на любом уровне префикса, что полезно при объединении двух инструкций `use`, имеющих общую часть пути. Например, в листинге 7-19 показаны две инструкции `use`: одна вводит в область действия `std::io`, другая — `std::io::Write`:

--
.Листинг 7-19. Две инструкции use, где один является частью пути другого

Файл: src/lib.rs

[source,rust]
----
use std::io;
use std::io::Write;
----
--

Общая часть этих двух путей — `std::io`, и в то же время это — полный первый путь. Чтобы объединить эти два пути в одну инструкцию `use`, можно использовать `self` во вложенном пути, как показано в листинге 7-20:

--
.Листинг 7-20. Объединение путей в листинге 7-19 в одну инструкцию use

Файл: src/lib.rs

[source,rust]
----
use std::io::{self, Write}; <1>
----
<1> Эта строка добавляет `std::io` и `std::io::Write` в область действия.
--

==== Оператор Glob

Если мы хотим включить в область действия _все_ открытые элементы, определенные в пути, то можем указать этот путь, за которым следует символ `*` оператора glob :

[source,rust]
----
use std::collections::*; <1>
----

<1> Инструкция `use` переносит все открытые элементы, определенные в `std::collections`, в текущую область действия.

Будьте осторожны при использовании оператора glob: он может существенно затруднить определение того, какие имена находятся в области действия и где было определено имя, используемое в вашей программе!

Оператор glob часто используется при тестировании, чтобы перенести подлежащие тестированию элементы в тестовый модуль; мы поговорим об этом в разделе «Как писать тесты» Главы 11. Также иногда он применяется как часть шаблона прелюдии: дополнительную информацию об этом шаблоне см. в документации стандартной библиотеки по ссылке _https://doc.rust-lang.org/std/prelude/index.html#other-preludes_.
