[#_3_1_variables]
=== 3.1. Переменные и изменчивость

Как упоминалось в разделе «Сохранение значений с помощью переменных», по умолчанию переменные являются неизменяемыми. Это позволяет писать код таким образом, чтобы использовать все преимущества безопасности и простого параллелизма в Rust. Тем не менее есть возможность сделать переменные изменяемыми. Давайте рассмотрим, как и почему Rust поощряет неизменяемость и почему иногда мы вынуждены от нее отказываться.

Когда переменная неизменяема, то после привязки значения к ее имени нельзя больше изменить это значение. Чтобы это проиллюстрировать, давайте создадим новый проект с именем _variables_ в каталоге _projects_, используя команду `cargo new variables`.

Затем в новом каталоге _variables_ откройте файл _src/main.rs_ и замените его содержимое кодом из следующего примера. Этот код не будет компилироваться из-за ошибки неизменяемости, которую мы и рассмотрим.

--
Файл: src/main.rs

[source,rust]
----
fn main() {
    let x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}
----
--

Сохраните и запустите программу, используя команду `cargo run`. Будет выведено сообщение об ошибке:

[example]
----
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
3 |     println!("The value of x is: {x}");
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` due to previous error
----

Этот пример показывает, как компилятор помогает находить ошибки в ваших программах. Ошибки, о которых сообщает компилятор, могут расстраивать, но на самом деле они означают, что наша программа пока не делает то, что мы от нее хотим; в то же время, наличие ошибок еще не означает, что мы — плохие программисты! Ошибки компиляции получают и опытные разработчики Rust.

В нашем случае сообщение об ошибке указывает на ее причину: `cannot assign twice to immutable variable x` (нельзя дважды присвоить значение неизменяемой переменной `x`), к которой привела наша попытка присвоить второе значение неизменяемой переменной `x` в инструкции `x = 6`.

Важно, что мы получаем ошибки на этапе компиляции (compile-time errors), когда пытаемся изменить значение, обозначенное как неизменяемое, потому что сама эта ситуация может привести к ошибкам. Если одна часть нашего кода исходит из предположения, что значение никогда не изменится, а другая его часть изменяет это значение, то вполне возможно, что первая не будет делать то, для чего она была разработана. Причину такого рода ошибок может быть трудно отследить постфактум, особенно когда вторая часть кода изменяет значение только _иногда_. Если мы объявили переменную неизменяемой, то далее уже сам компилятор гарантирует, что ее значение действительно не изменится, поэтому нет никакой необходимости следить за переменной самостоятельно. При этом наш код становится легче понять.

Но изменяемость может быть очень полезной и сделать код более удобным для разработки. Хотя переменные неизменяемы по умолчанию, их можно сделать изменяемыми, добавив ключевое слово `mut` перед именем переменной, как это делалось в xref:_2_1_processing_user_input[Главе 2]. Добавление `mut` также говорит будущим читателям нашего кода, что значение этой переменной будет изменяться в других частях программы.

Давайте изменим _src/main.rs_ вот так:

Файл: src/main.rs

[source,rust]
----
fn main() {
    let mut x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}
----

После запуска получим следующее:

[example]
----
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
----

При использовании `mut` разрешается изменить значение, привязанное к `x`, с `5` до `6`. В конечном счете, решение о том, использовать изменяемость или нет, зависит от нас самих и того, что мы считаем нужным в каждой конкретной ситуации.

[#_3_1_1_constants]
==== Константы

Как и неизменяемые переменные, _константы_ — это значения, которые связаны с именем и не могут изменяться, но между константами и переменными есть несколько различий.

Во-первых, вам не разрешено использовать _mut_ с константами. Константы не просто неизменяемы по умолчанию — они неизменяемы всегда. Для объявления константы используется ключевое слово `const` вместо `let`, при этом в обязательном порядке _должен быть_ аннотирован ее тип. О типах и их аннотациях поговорим в следующем разделе «Типы данных», сейчас не будем вдаваться в детали. Просто знайте, что нужно всегда аннотировать тип констант.

Далее, константы можно объявлять в любой области, включая глобальную, что делает их полезными в случае необходимости использования во многих местах кода.

Последнее отличие состоит в том, что значение константы может быть задано только как константное выражение, а не как выражение, значение которого может быть вычислено во время выполнения программы.

Вот пример объявления константы:

[source,rust]
----
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
----

Наименование константы — `THREE_HOURS_IN_SECONDS`, а ее значение есть результат константного выражения, в котором 60 (количество секунд в минуте) умножается на 60 (количество минут в часе) и умножается на 3 (количество нужных нам часов). Соглашение об именах констант в Rust состоит в том, чтобы использовать все символы в верхнем регистре с символами подчеркивания между словами. Компилятор может выполнять ограниченное множество операций во время компиляции, что позволяет нам записать значение константы как вычисление, чтобы ее легче было понять и проверить, вместо того, чтобы устанавливать для нее сразу конечное значение 10 800. См. раздел справочника Rust, посвященный вычислению констант по адресу _https://doc.rust-lang.org/reference/const_eval.html_, для получения дополнительной информации о том, какие операции можно использовать при объявлении констант.

Константы действительны в течение всего времени работы программы в той области, в которой они были объявлены. Это свойство делает константы полезными для хранения глобальных значений, которые могут потребоваться в нескольких разных областях кода, например, максимальное количество очков игрока в игре, или скорость света.

Наименование жестко заданных значений в качестве констант полезно и для повышения эффективности последующего сопровождения кода, так как позволяет лучшим образом обозначить смысл этих значений. Также полезно иметь только одно место в вашем коде, которое нужно будет изменить, если жестко заданное значение потребуется обновить в будущем.

[#_3_1_2_shadowing]
==== Затенение

Как мы видели в программе игры в угадайку в xref:_2_3_shdowing_example[Главе 2], можно объявить новую переменную с тем же именем, что и предыдущая переменная. Опытные разработчики Rust говорят, что первая переменная _затенена_ (_shadowing_) второй. Это значит, что вторая переменная — это именно то, что увидит компилятор при использовании имени переменной. По сути, вторая переменная затмевает (overshadows) первую, присваивая себе любое использование имени переменной до тех пор, пока либо она сама не будет затенена, либо не закончится ее область действия.

Мы можем затенить переменную, используя то же имя переменной и повторив использование ключевого слова `let` следующим образом:

Файл: src/main.rs

[source,rust]
----
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {x}");
    }

    println!("The value of x is: {x}");
}
----

Эта программа сначала привязывает `x` к значению 5. Затем она создает новую переменную `x`, повторяя `let x =`, берет исходное значение и добавляет 1, чтобы значение `x` стало равным 6. Затем во внутренней области действия, созданной с помощью фигурных скобок, инструкция `let` затеняет `x` и создает новую переменную, умножая предыдущее значение на 2, чтобы дать `x` значение 12. При выходе из этой области внутреннее затенение закончится, и `x` вернется к значению `6`. Когда мы запустим эту программу, она выведет следующее:

[example]
----
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
The value of x in the inner scope is: 12
The value of x is: 6
----

Затенение отличается от пометки переменной как `mut`: мы получим ошибку времени компиляции, если случайно попытаемся переназначить эту переменную без использования ключевого слова `let`. Используя `let`, мы можем выполнить несколько преобразований значения, сохранив переменную неизменяемой после завершения этих преобразований.

Другое различие между `mut` и затенением заключается в том, что, поскольку мы фактически создаем новую переменную, когда снова используем ключевое слово `let`, то можем изменить тип значения, повторно используя то же имя. Например, в нашей программе пользователь вводит строчное значение из пробелов, а затем мы хотим сохранить этот ввод в виде количества пробелов, заданных в этом строчном значении:

[source,rust]
----
    let spaces = "   ";
    let spaces = spaces.len();
----

Первая переменная `spaces` — это строковый тип, а вторая переменная `spaces` — числовой тип. Таким образом, затенение избавляет нас от необходимости придумывать разные имена, такие как `space_str` и `space_num`; вместо этого мы можем повторно использовать более простое имя `spaces`. Однако, если мы попытаемся использовать для этого `mut`, как показано здесь

[source,rust]
----
    let mut spaces = "   ";
    spaces = spaces.len();
----

то получим ошибку компиляции:

[example]
----
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --> src/main.rs:3:14
  |
2 |     let mut spaces = "   ";
  |                      ----- expected due to this value
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&str`, found `usize`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables` due to previous error
----

Ошибка говорит, что нам не разрешено изменять тип переменной.

Теперь, когда мы изучили, как работают переменные, давайте рассмотрим дополнительные типы данных, которые они могут иметь.
