[#_2_1_processing_user_input]
=== 2.1. Обработка числа от пользователя

Первая часть программы игры в угадайку будет запрашивать ввод пользователя, обрабатывать этот ввод и проверять, соответствует ли ввод ожидаемой форме. Для начала дадим возможность игроку ввести свое число. Напишите код из листинга 2-1 в _src/main.rs_.

--
.Листинг 2-1: Код, который получает число от пользователя и выводит его

Файл: src/main.rs

[source,rust]
----
use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {guess}");
}
----
--

Этот код содержит много информации, поэтому давайте рассмотрим его построчно.

Чтобы получить пользовательский ввод, а затем распечатать результат в качестве вывода, нам нужно включить библиотеку ввода-вывода `io` в область действия. Библиотека `io` содержится в стандартной библиотеке, известной как `std`:

[source,rust]
----
use std::io;
----

По умолчанию в Rust есть набор элементов, определенных в стандартной библиотеке, которые добавляются в область действия (scope) каждой программы. Этот набор называется _прелюдией_ (_prelude_), и его содержимое можно просмотреть в документации стандартной библиотеки по ссылке _https://doc.rust-lang.org/std/prelude/index.html_. Если нужного элемента в прелюдии нет, его необходимо явно включить в область действия с помощью инструкции `use`. Библиотека `std::io` предоставляет ряд полезных функций, в том числе и для работы с пользовательским вводом.

Как известно из xref:_chapter_1[Главы 1], функция `main` — это точка входа в программу:

[source,rust]
----
fn main() {
----

Синтаксис `fn` объявляет новую функцию, круглые скобки `()` указывают на отсутствие параметров, а фигурная скобка `{` начинает тело функции.

Также из xref:_chapter_1[Главы 1] известно, что `println!` — это макрос, который выводит строку на экран:

[source,rust]
----
    println!("Guess the number!");

    println!("Please input your guess.");
----

Этот код печатает подсказку, сообщающую, что это за игра, и запрашивает ввод данных от пользователя.

==== Сохранение значений в переменных

Далее создается _переменная_ для хранения пользовательского ввода:

[source,rust]
----
    let mut guess = String::new();
----

С этого момента программа становится интереснее! В этой небольшой строке происходит многое. Для создания переменной используется инструкция `let`. Например:

[source,rust]
----
let apples = 5;
----

Эта строка создает новую переменную с именем `apples` и привязывает (bind) к ней значение 5. В Rust переменные по умолчанию являются неизменяемыми (immutable), то есть, после выполнения операции присваивания `=` изменить привязанное к переменной значение нельзя. Мы подробно обсудим эту концепцию в xref:_3_1_variables[разделе «Переменные и изменяемость»] в Главе 3. Чтобы сделать переменную изменяемой (mutable), нужно добавить `mut` перед именем переменной:

[source,rust]
----
let apples = 5; // неизменяемая переменная
let mut bananas = 5; // изменяемая переменная
----

[sidebar]
Синтаксис `//` начинает комментарий, который продолжается до конца строки. Rust игнорирует все комментарии. Более подробно мы обсудим комментарии в xref:_3_4_comments[Главе 3].

Вернемся к программе игры в угадайку. Итак, `let mut guess` вводит изменяемую переменную с именем `guess`. Знак равенства говорит Rust, что мы хотим прямо сейчас что-то привязать к переменной. Справа от знака равенства находится значение переменной `guess`, которое является результатом вызова `String::new`, функции, которая возвращает новый экземпляр `String`. String — это строковый тип, предоставляемый стандартной библиотекой, является расширяемым набором символов в кодировке UTF-8. Детально описание типа см. в документации по ссылке _https://doc.rust-lang.org/std/string/struct.String.html_

Двойное двоеточие `::` говорит о том, что `new` является ассоциированной функцией типа `String`. _Ассоциированная функция_ — это функция, реализованная для типа, в данном случае `String`. Ассоциированная с типом String функция `new` создает новую, пустую строку (экземпляр типа `String`). Наименование `new` является стандартным для функции, создающей новое значение типа, с которым она ассоциирована; такая функция встречается в большинстве типов Rust.

Итак, в строке `let mut guess = String::new();` создается изменяемая переменная, к которой в текущий момент привязана пустая строка. Отлично!

==== Получение пользовательского ввода

Напомним, что в первой строке программы с помощью `use std::io;` из стандартной библиотеки в наш код была добавлена библиотека ввода-вывода. Теперь из модуля `io` вызовем функцию `stdin`, которая позволяет обрабатывать пользовательский ввод:

[source,rust]
----
    io::stdin()
        .read_line(&mut guess)
----

Если бы мы не импортировали библиотеку `io` в начале программы, то все равно могли бы использовать функцию, написав вызов этой функции с указанием полного пути `std::io::stdin`. Функция `stdin` возвращает экземпляр `std::io::Stdin`, который является типом, представляющим дескриптор стандартного ввода консоли.

В строке `.read_line(&mut guess)` для дескриптора стандартного ввода вызывается метод `read_line` для получения ввода от пользователя. В качестве аргумента передается `&mut guess` для указания на переменную, в которой нужно сохранять пользовательский ввод. Метод принимает все, что вводит в стандартный ввод пользователь, и добавляет в конец значения типа `String` (называемого _буфером ввода_), поэтому мы передаем в аргументе переменную типа String. Аргумент должен быть изменяемым, чтобы метод мог изменять содержимое буфера ввода.

Символ `&` означает, что аргумент является _ссылкой_, с помощью которой можно предоставить доступ к одной и той же области данных из разных мест вашего кода без необходимости многократного копирования этих данных в памяти. Ссылки являются сложной концепцией (feature), и одно из главных преимуществ Rust заключается в их наиболее простом и безопасном использовании. Но для разработки такой программы как игра в угадайку глубокого понимания работы со ссылками не требуется; пока достаточно знать, что ссылки, как и переменные, неизменяемы по умолчанию. Следовательно, чтобы сделать ссылку изменяемой, нужно просто написать `&mut guess`, а не `&guess`. Ссылки подробно разбираются в xref:_4_2_referencing[Главе 4].

[#_2_1_handling_potential_failure_with_result]
==== Обработка потенциального сбоя с помощью типа Result

Давайте продолжим работу с текстом кода. Сейчас перейдем к третьей строке текста, но обратим внимание, что она по-прежнему является частью одной логической строки кода. Следующая часть этой строки — метод `expect`:

[source,rust]
----
        .expect("Failed to read line");
----

Можно было бы написать все в виде одной текстовой строки:

[source,rust]
----
io::stdin().read_line(&mut guess).expect("Failed to read line");
----

Однако одну длинную строку сложно читать, поэтому ее лучше разделить. Часто разумно разбивать длинные строки в тех местах, в которых вызываются методы с синтаксисом `.method_name()`, перенося их на новую строку и добавляя в нужном количестве пробелы. Теперь давайте обсудим, что делает код в этой строке.

Как упоминалось ранее, функция `read_line` помещает все, что вводит пользователь, в буфер ввода, и возвращает значение типа `Result`. Result — это _перечисление_, и представляет собой тип данных, который может находиться в одном из нескольких возможных состояний. Мы называем каждое возможное состояние _вариантом_. Перечисления будут рассмотрены более подробно в xref:_chapter_6[Главе 6]. Детальное описание типа см. в документации по ссылке _https://doc.rust-lang.org/std/result/enum.Result.html_.

Целью использования значений типа `Result` является представление данных для обработки ошибок.

Варианты `Result` — это `Ok` и `Err`. Вариант `Ok` указывает, что операция прошла успешно, при этом внутри `Ok` находится значение операции. Вариант `Err` означает, что операция не удалась, и в `Err` содержится информация о том, как и почему не получилось выполнить операцию.

Значения типа `Result`, как и значения любого типа, имеют определенные для них методы. В частности у `Result` есть метод `expect`, который в случае значения `Err` приведет к аварийному завершению программы и отображению сообщения, переданного в аргументе метода. Если `read_line` возвращает `Err`, это, скорее всего, результат ошибки операционной системы. Если значением `Result` будет `Ok`, метод `expect` вернет значение, содержащееся в `Ok`. В случае `read_line` таким значением будет количество байтов в буфере ввода. Детальное описание метода `expect` см. в документации по адресу _https://doc.rust-lang.org/std/result/enum.Result.html#method.expect_.

Если `expect` не использовать, то программа скомпилируется, но будет выведено предупреждение:

[example]
----
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `Result` that must be used
  --> src/main.rs:10:5
   |
10 |     io::stdin().read_line(&mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

warning: `guessing_game` (bin "guessing_game") generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
----

Rust предупреждает, что значение `Result`, возвращенное из `read_line`, не используется, указывая на то, что программа не обработала возможную ошибку.

Убрать это предупреждение можно только одним способом — написать обработчик ошибок, но мы поступаем иначе (логика программы нам это позволяет) — в случае возникновения проблемы просто завершим работу программы, поэтому использовать `expect` не будем. О работе с ошибками поговорим более детально в Главе 9.

==== Печать значений с помощью println!

Помимо закрывающей фигурной скобки, пока что в коде осталось обсудить только строку:

[source,rust]
----
    println!("You guessed: {guess}");
----

В этой строке на печать выводится строковое значение, которое теперь содержит еще и ввод пользователя. Пара фигурных скобок `{}` в строке формата является заполнителем (placeholder), работающим по принципу захвата значения, заданного либо внутри скобок, либо после форматной строки. С помощью фигурных скобок можно напечатать более одного значения: первая пара фигурных скобок "захватывает" первое значение, указанное либо внутри пары, либо после строки формата, вторая пара "захватывает" второе значение и так далее. Печать нескольких значений за один вызов `println!` будет выглядеть так:

[source,rust]
----
let x = 5;
let y = 10;

println!("x = {} and y = {}", x, y);
----

Этот код напечатает `x = 5 and y = 10`.

==== Тестирование первой части

Давайте проверим первую часть игры в угадайку. Запустите программу, используя `cargo run`:

[example]
----
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
----

На этом первая часть игры завершена: мы получаем ввод с клавиатуры, а затем печатаем его.
